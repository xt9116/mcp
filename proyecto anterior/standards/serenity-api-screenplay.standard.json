{
  "name": "Est√°ndar Serenity Screenplay - API REST",
  "version": "1.0.0",
  "purpose": "Definir una forma √∫nica, consistente y escalable de implementar pruebas de APIs REST usando Serenity BDD + Screenplay",
  "framework": "Serenity BDD",
  "pattern": "Screenplay",
  "scope": "API REST",
  "requestTypes": {
    "description": "Tipos de solicitudes soportadas por el MCP - No todo es Historia de Usuario",
    "types": {
      "INIT": {
        "name": "Inicializaci√≥n",
        "description": "Crear estructura base del proyecto, sin endpoints ni l√≥gica funcional",
        "requires": [
          "framework",
          "pattern",
          "scope",
          "basePackage"
        ],
        "generates": [
          "projectStructure",
          "mainRunner",
          "serenityProperties"
        ],
        "notRequires": [
          "endpoints",
          "validations",
          "builders",
          "tasks"
        ],
        "rules": {
          "generateStructureOnly": true,
          "noEndpoints": true,
          "noValidations": true,
          "noBuilders": true,
          "noTasks": true
        }
      },
      "API_HU": {
        "name": "Historia de Usuario API",
        "description": "Historia de usuario completa con endpoint, models, tasks, validaciones",
        "requires": [
          "id",
          "nombre",
          "endpoint",
          "metodo",
          "request",
          "response",
          "validaciones"
        ],
        "generates": [
          "feature",
          "stepDefinitions",
          "task",
          "interaction",
          "question",
          "model",
          "builder",
          "endpoint"
        ],
        "notRequires": [],
        "rules": {
          "generateAll": true,
          "validateBusiness": true
        },
        "howToRequest": {
          "description": "C√≥mo estructurar correctamente la solicitud de una Historia de Usuario completa",
          "requiredInfo": {
            "id": "Identificador de la HU (ej: HU-001)",
            "nombre": "Nombre descriptivo (ej: Visualizar todos los personajes)",
            "baseUrl": "URL base de la API (ej: https://rickandmortyapi.com/api)",
            "endpoint": "Path del endpoint (ej: /character)",
            "metodo": "M√©todo HTTP (GET, POST, PUT, DELETE)",
            "responseStructure": "Estructura del response esperado con tipos de datos",
            "validaciones": "Qu√© se debe validar (statusCode, campos espec√≠ficos)",
            "framework": "Mencionar que debe usar Serenity Screenplay correctamente"
          },
          "templateRequest": "Necesito implementar la {id} para {nombre} en la url \"{baseUrl}\" en el endpoint {metodo} {endpoint}.\nEl response debe devolver: {responseStructure}\nDebe validar: {validaciones}\nUtilizando de manera correcta Serenity Screenplay.",
          "exampleComplete": {
            "userRequest": "Necesito implementar la HU-001 para visualizar todos los personajes en la url \"https://rickandmortyapi.com/api\" en el endpoint GET /character.\nEl response debe devolver: info:{count:Integer,pages:Integer,next:String,prev:String}, results:List<Object>\nDebe validar que el statusCode sea 200.\nUtilizando de manera correcta Serenity Screenplay.",
            "parsedInfo": {
              "id": "HU-001",
              "nombre": "Visualizar todos los personajes",
              "baseUrl": "https://rickandmortyapi.com/api",
              "endpoint": "/character",
              "metodo": "GET",
              "responseFields": [
                {
                  "path": "info.count",
                  "type": "Integer",
                  "description": "Total de personajes"
                },
                {
                  "path": "info.pages",
                  "type": "Integer",
                  "description": "Total de p√°ginas"
                },
                {
                  "path": "info.next",
                  "type": "String",
                  "description": "URL siguiente p√°gina"
                },
                {
                  "path": "info.prev",
                  "type": "String",
                  "description": "URL p√°gina anterior"
                },
                {
                  "path": "results",
                  "type": "List<Object>",
                  "description": "Lista de personajes"
                }
              ],
              "validaciones": [
                {
                  "type": "statusCode",
                  "expectedValue": 200
                },
                {
                  "type": "field",
                  "path": "info",
                  "validation": "not null"
                },
                {
                  "type": "field",
                  "path": "results",
                  "validation": "not null"
                }
              ]
            },
            "artifactsToGenerate": [
              "Feature file (character.feature)",
              "StepDefinitions (CharacterStepDefinitions.java)",
              "Task (GetAllCharacters.java)",
              "Interaction (GetRequest.java)",
              "Questions (ResponseStatusCode.java, ResponseInfoField.java, ResponseResults.java)",
              "Model (CharacterResponse.java con Info y Results)",
              "Endpoint (CharacterEndpoints.java con BASE_URL y GET_ALL)",
              "Builder (CharacterResponseBuilder.java - si se necesita para tests)"
            ]
          },
          "bestPractices": [
            "‚úÖ Especificar SIEMPRE la URL base completa",
            "‚úÖ Indicar el m√©todo HTTP antes del endpoint (GET /character)",
            "‚úÖ Describir la estructura del response con tipos de datos",
            "‚úÖ Listar todas las validaciones esperadas",
            "‚úÖ Mencionar 'Serenity Screenplay' para aplicar el est√°ndar correcto",
            "‚úÖ Para objetos anidados usar notaci√≥n de puntos: info.count, data.user.name",
            "‚úÖ Especificar tipos Java: Integer, String, Boolean, List<Object>, etc."
          ],
          "commonMistakes": [
            "‚ùå No especificar la URL base (solo poner el endpoint)",
            "‚ùå No indicar los tipos de datos del response",
            "‚ùå Decir solo 'validar el response' sin especificar qu√©",
            "‚ùå No mencionar el m√©todo HTTP",
            "‚ùå Solicitud ambigua como 'hacer un test de la API'"
          ],
          "withJsonSchema": {
            "description": "C√≥mo hacer la solicitud cuando tienes el schema del response en un archivo JSON",
            "option1": {
              "name": "Pasar el JSON completo en el prompt",
              "template": "Necesito implementar la {id} para {nombre} en la url \"{baseUrl}\" en el endpoint {metodo} {endpoint}.\n\nEl response debe tener esta estructura:\n```json\n{schema JSON aqu√≠}\n```\n\nDebe validar:\n- {validaciones}\n\nUtilizando de manera correcta Serenity Screenplay.",
              "example": "Necesito implementar la HU-001 para visualizar todos los personajes en la url \"https://rickandmortyapi.com/api\" en el endpoint GET /character.\n\nEl response debe tener esta estructura:\n```json\n{\n  \"info\": {\n    \"count\": 826,\n    \"pages\": 42,\n    \"next\": \"https://rickandmortyapi.com/api/character?page=2\",\n    \"prev\": null\n  },\n  \"results\": [\n    {\n      \"id\": 1,\n      \"name\": \"Rick Sanchez\",\n      \"status\": \"Alive\",\n      \"species\": \"Human\",\n      \"type\": \"\",\n      \"gender\": \"Male\",\n      \"origin\": {\"name\": \"Earth (C-137)\", \"url\": \"https://rickandmortyapi.com/api/location/1\"},\n      \"location\": {\"name\": \"Citadel of Ricks\", \"url\": \"https://rickandmortyapi.com/api/location/3\"},\n      \"image\": \"https://rickandmortyapi.com/api/character/avatar/1.jpeg\",\n      \"episode\": [\"https://rickandmortyapi.com/api/episode/1\",\"https://rickandmortyapi.com/api/episode/2\"],\n      \"url\": \"https://rickandmortyapi.com/api/character/1\",\n      \"created\": \"2017-11-04T18:48:46.250Z\"\n    }\n  ]\n}\n```\n\nDebe validar:\n- statusCode sea 200\n- info no sea null\n- info.count sea mayor a 0\n- results no sea null\n- results contenga al menos 1 elemento\n\nUtilizando de manera correcta Serenity Screenplay.",
              "pros": "El sistema puede inferir autom√°ticamente los tipos de datos",
              "parsing": "El sistema analiza el JSON y determina: String, Integer, Boolean, Object, Array seg√∫n los valores"
            },
            "option2": {
              "name": "Referenciar archivo JSON externo",
              "template": "Necesito implementar la {id} para {nombre} en la url \"{baseUrl}\" en el endpoint {metodo} {endpoint}.\n\nEl response schema est√° en el archivo: {rutaArchivo}\n\nDebe validar:\n- {validaciones}\n\nUtilizando de manera correcta Serenity Screenplay.",
              "example": "Necesito implementar la HU-001 para visualizar todos los personajes en la url \"https://rickandmortyapi.com/api\" en el endpoint GET /character.\n\nEl response schema est√° en el archivo: schemas/character-response.json\n\nDebe validar:\n- statusCode sea 200\n- info no sea null\n- results contenga elementos\n\nUtilizando de manera correcta Serenity Screenplay.",
              "pros": "M√°s limpio cuando el schema es muy grande",
              "note": "El sistema puede leer el archivo y parsear el schema autom√°ticamente"
            },
            "jsonToJavaMapping": {
              "description": "Mapeo autom√°tico de tipos JSON a tipos Java",
              "mappings": {
                "number (entero)": "Integer o Long",
                "number (decimal)": "Double o Float",
                "string": "String",
                "boolean": "Boolean",
                "object": "Object o crear clase POJO",
                "array": "List<T> donde T es el tipo del contenido",
                "null": "Se ignora (usa @JsonIgnoreProperties)"
              },
              "examples": {
                "count: 826": "Integer count",
                "name: \"Rick\"": "String name",
                "alive: true": "Boolean alive",
                "price: 19.99": "Double price",
                "tags: []": "List<String> tags",
                "user: {}": "User user (crear clase User)"
              }
            },
            "validationsFromSchema": {
              "description": "Validaciones comunes que se pueden inferir del schema",
              "automatic": [
                "Campos requeridos (los que aparecen en el schema) ‚Üí validar not null",
                "Arrays ‚Üí validar que no est√© vac√≠o si se espera contenido",
                "N√∫meros ‚Üí validar tipo correcto (no String)",
                "Booleans ‚Üí validar true/false seg√∫n l√≥gica de negocio"
              ],
              "recommended": "Especificar validaciones expl√≠citas aunque el schema las implique"
    }
  },

  "crossReferences": {
    "description": "Referencias a est√°ndares relacionados para consistencia",
    "webStandard": {
      "file": "serenity-web-screenplay.standard.json",
      "version": "1.3.0",
      "sharedSections": [
        "principles.screenplayFirst",
        "namingConventions.language",
        "projectStructure.buildTools",
        "gherkinStandards (similar pero adaptado a Web)"
      ],
      "differences": [
        "API: Enfoque en HTTP methods y JSON",
        "Web: Enfoque en UI interactions y locators",
        "Ambos: Mismo patr√≥n Screenplay y estructura de proyecto"
      ]
    },
    "consistencyRules": [
      "Mismos principios de Screenplay en API y Web",
      "Convenciones de naming consistentes",
      "Estructura de proyecto similar",
      "Mismo approach para Gherkin (modular by default)",
      "Validaciones similares de patrones"
    ]
  }
}
      },
      "FEATURE": {
        "name": "Feature sin API",
        "description": "Solo archivo .feature sin implementaci√≥n t√©cnica",
        "requires": [
          "descripcion",
          "escenarios"
        ],
        "generates": [
          "feature"
        ],
        "notRequires": [
          "tasks",
          "interactions",
          "models",
          "endpoints"
        ],
        "rules": {
          "featureOnly": true,
          "noImplementation": true
        }
      },
      "REFACTOR": {
        "name": "Refactorizaci√≥n t√©cnica",
        "description": "Cambio t√©cnico en c√≥digo existente, sin generar features",
        "requires": [
          "objetivo",
          "modulosAfectados"
        ],
        "generates": [
          "analysis",
          "suggestions"
        ],
        "notRequires": [
          "features",
          "newCode"
        ],
        "rules": {
          "analyzeOnly": true,
          "noGeneration": true,
          "validateStandards": true
        }
      },
      "VALIDATION": {
        "name": "Validaci√≥n de c√≥digo",
        "description": "Validar c√≥digo existente contra est√°ndares",
        "requires": [
          "codigo",
          "tipo"
        ],
        "generates": [
          "validationReport"
        ],
        "notRequires": [
          "generation"
        ],
        "rules": {
          "validateOnly": true,
          "noGeneration": true
        }
      }
    }
  },
  "principles": {
    "screenplayFirst": {
      "enabled": true,
      "description": "Screenplay first - NO usar @Steps, NO l√≥gica en step definitions",
      "forbidden": [
        "@Steps annotation",
        "L√≥gica en step definitions"
      ],
      "required": [
        "Toda acci√≥n debe ser un Task, Interaction o Question"
      ]
    },
    "separationOfResponsibilities": {
      "enabled": true,
      "layers": {
        "feature": {
          "responsibility": "Lenguaje de negocio",
          "format": "Gherkin"
        },
        "stepDefinitions": {
          "responsibility": "Orquestaci√≥n m√≠nima",
          "maxLines": 3,
          "forbidden": [
            "L√≥gica",
            "Aserciones t√©cnicas"
          ]
        },
        "tasks": {
          "responsibility": "Acciones sobre la API",
          "language": "Lenguaje de negocio",
          "forbidden": [
            "HTTP directo"
          ]
        },
        "interactions": {
          "responsibility": "Acciones t√©cnicas (HTTP)",
          "allowed": [
            "HTTP calls"
          ],
          "forbidden": [
            "Aserciones"
          ]
        },
        "questions": {
          "responsibility": "Validaciones",
          "mustReturn": "Boolean o valor"
        },
        "models": {
          "responsibility": "Request / Response",
          "dataOnly": true,
          "forbidden": [
            "L√≥gica"
          ]
        },
        "builders": {
          "responsibility": "Construcci√≥n de requests",
          "purpose": "Generar escenarios de prueba"
        }
      }
    }
  },
  "projectStructure": {
    "mandatory": true,
    "buildTools": {
      "supported": [
        "Gradle",
        "Maven"
      ],
      "description": "El proyecto puede usar Gradle o Maven como herramienta de build"
    },
    "basePackage": "com.{company}",
    "example": "com.rimac, com.sistecredito, com.bancolombia",
    "rootStructureGradle": {
      "gradle/": "Configuraci√≥n de Gradle Wrapper",
      "src/": "C√≥digo fuente del proyecto",
      ".gitignore": "Archivos ignorados por Git",
      "README.md": "Documentaci√≥n del proyecto",
      "build.gradle": "Configuraci√≥n de build y dependencias",
      "gradlew": "Gradle Wrapper Unix",
      "gradlew.bat": "Gradle Wrapper Windows",
      "settings.gradle": "Configuraci√≥n del proyecto Gradle"
    },
    "rootStructureMaven": {
      "src/": "C√≥digo fuente del proyecto",
      ".gitignore": "Archivos ignorados por Git",
      "README.md": "Documentaci√≥n del proyecto",
      "pom.xml": "Configuraci√≥n de build y dependencias Maven",
      ".mvn/": "Maven Wrapper (opcional)",
      "mvnw": "Maven Wrapper Unix (opcional)",
      "mvnw.cmd": "Maven Wrapper Windows (opcional)"
    },
    "sourceStructure": {
      "src/main/java/com/{company}/": {
        "tasks/": {
          "description": "Tareas de negocio de alto nivel",
          "naming": "{Action}{Resource}.java",
          "examples": [
            "CreateUser.java",
            "GetPolicy.java",
            "UpdateCustomer.java"
          ]
        },
        "interactions/": {
          "description": "Acciones t√©cnicas HTTP (Post, Get, Put, Delete, Patch)",
          "naming": "{HttpMethod}Request.java",
          "examples": [
            "PostRequest.java",
            "GetRequest.java",
            "PutRequest.java",
            "DeleteRequest.java"
          ]
        },
        "questions/": {
          "description": "Validaciones que retornan valores",
          "naming": "{What}Question.java o {What}.java",
          "examples": [
            "ResponseStatusCode.java",
            "ResponseBodyField.java"
          ]
        },
        "models/": {
          "description": "POJOs Request/Response DTOs",
          "naming": "{Resource}Request.java, {Resource}Response.java",
          "examples": [
            "CreateUserRequest.java",
            "UserResponse.java"
          ]
        },
        "builders/": {
          "description": "Construcci√≥n de datos de prueba",
          "naming": "{Resource}Builder.java",
          "examples": [
            "UserBuilder.java",
            "PolicyBuilder.java"
          ]
        },
        "endpoints/": {
          "description": "URLs de la API",
          "naming": "{Resource}Endpoints.java",
          "examples": [
            "UserEndpoints.java",
            "PolicyEndpoints.java"
          ]
        },
        "utils/": {
          "description": "C√≥digo de utilidades (opcional)",
          "naming": "{Utility}.java",
          "examples": [
            "Constants.java",
            "DateUtils.java",
            "JsonUtils.java"
          ]
        }
      },
      "src/test/java/com/{company}/": {
        "stepdefinitions/": {
          "description": "Step Definitions - Glue code Cucumber (m√°x 3 l√≠neas por m√©todo)",
          "naming": "{Feature}StepDefinitions.java",
          "examples": [
            "UserStepDefinitions.java",
            "PolicyStepDefinitions.java"
          ]
        },
        "runners/": {
          "description": "Runners - Ejecutores de tests",
          "naming": "{Feature}Runner.java",
          "examples": [
            "UserManagementRunner.java",
            "PolicyRunner.java"
          ]
        }
      },
      "src/test/resources/": {
        "features/": {
          "description": "Feature files - Escenarios Gherkin",
          "naming": "{feature}.feature",
          "examples": [
            "user_management.feature",
            "policy_creation.feature"
          ]
        },
        "serenity.properties": "Configuraci√≥n de Serenity BDD"
      }
    },
    "notes": [
      "NO incluir carpeta 'api' en el package (usar com.{company} directamente)",
      "builders/ para construcci√≥n de datos de prueba (opcional)",
      "endpoints/ separado para URLs de la API",
      "utils/ solo para utilidades generales (opcional)",
      "serenity.properties DEBE estar en src/test/resources/",
      "stepdefinitions en min√∫scula (convenci√≥n)",
      "Order: tasks -> interactions -> questions -> models -> builders -> endpoints -> utils"
    ]
  },
  "namingConventions": {
    "language": {
      "rule": "TODO en ESPA√ëOL excepto nombres del framework y dependencias externas",
      "inSpanish": [
        "Nombres de clases personalizadas (Tasks, Interactions, Questions, Models)",
        "Nombres de m√©todos propios",
        "Variables locales",
        "Comentarios y documentaci√≥n",
        "Mensajes de validaci√≥n y excepciones",
        "Nombres de packages personalizados (com.empresa.proyecto)"
      ],
      "inEnglish": [
        "Palabras clave del framework: Task, Interaction, Question, Actor",
        "M√©todos del framework: performAs(), answeredBy(), attemptsTo()",
        "Clases de Serenity: SerenityRest, CallAnApi, OnStage",
        "Anotaciones: @Step, @When, @Then, @Given",
        "Imports de librer√≠as externas",
        "Tipos de datos Java: String, Integer, Boolean, List"
      ],
      "examples": {
        "taskName": {
          "incorrect": "CreateUser",
          "correct": "CrearUsuario",
          "reason": "Nombres propios deben estar en espa√±ol"
        },
        "methodName": {
          "incorrect": "public static CreateUser with(CreateUserRequest request)",
          "correct": "public static CrearUsuario con(SolicitudCrearUsuario request)",
          "reason": "M√©todos y par√°metros propios en espa√±ol"
        },
        "variable": {
          "incorrect": "String endpoint = \"/users\";",
          "correct": "String puntoFinal = \"/users\";",
          "reason": "Variables locales en espa√±ol"
        },
        "frameworkMethod": {
          "correct": "@Override\npublic <T extends Actor> void performAs(T actor)",
          "reason": "performAs() es del framework, se mantiene en ingl√©s"
        },
        "annotation": {
          "correct": "@Step(\"{0} crea un nuevo usuario\")",
          "reason": "Anotaci√≥n en ingl√©s, mensaje en espa√±ol"
        }
      }
    },
    "tasks": {
      "pattern": "Verbo en infinitivo + Recurso en espa√±ol",
      "examples": [
        "CrearUsuario",
        "ObtenerPoliza",
        "ActualizarCliente",
        "EliminarProducto"
      ],
      "format": "PascalCase",
      "factoryMethod": "con(), desde(), para(), usando()",
      "fullExample": {
        "className": "ObtenerTodosLosPersonajes",
        "factoryMethod": "desdeApi()",
        "usage": "ObtenerTodosLosPersonajes.desdeApi()"
      }
    },
    "interactions": {
      "pattern": "Acci√≥n t√©cnica + Request/Solicitud",
      "examples": [
        "SolicitudPost",
        "SolicitudGet",
        "SolicitudPut",
        "SolicitudDelete"
      ],
      "alternativePattern": "Mantener nombres t√©cnicos reconocibles",
      "recommended": [
        "PostRequest",
        "GetRequest",
        "PutRequest",
        "DeleteRequest"
      ],
      "format": "PascalCase",
      "reason": "Interactions son muy t√©cnicas, pueden mantenerse en ingl√©s para claridad",
      "factoryMethod": "a(), hacia(), desde()"
    },
    "questions": {
      "pattern": "Qu√© se obtiene + Del/De + Origen",
      "examples": [
        "CodigoDeEstadoRespuesta",
        "CampoDelCuerpo",
        "MensajeDeError",
        "ListaDeResultados"
      ],
      "mustReturn": true,
      "format": "PascalCase",
      "factoryMethod": "valor(), obtenido(), actual()",
      "fullExample": {
        "className": "CodigoDeEstadoRespuesta",
        "factoryMethod": "valor()",
        "usage": "CodigoDeEstadoRespuesta.valor()"
      }
    },
    "models": {
      "pattern": "Nombre del recurso + Solicitud/Respuesta",
      "examples": [
        "SolicitudCrearUsuario",
        "RespuestaUsuario",
        "SolicitudActualizarPoliza"
      ],
      "format": "PascalCase",
      "fields": "Nombres de campos en espa√±ol: nombre, correo, fechaCreacion",
      "fullExample": {
        "request": "SolicitudCrearUsuario",
        "response": "RespuestaUsuario",
        "fields": "private String nombre;\nprivate String correo;\nprivate Integer edad;"
      }
    },
    "builders": {
      "pattern": "Constructor + Nombre del Modelo",
      "examples": [
        "ConstructorSolicitudCrearUsuario",
        "ConstructorActualizarPoliza"
      ],
      "format": "PascalCase",
      "methods": "conDatosValidos(), conDatosInvalidos(), conCampoVacio()",
      "fullExample": {
        "className": "ConstructorSolicitudCrearUsuario",
        "method": "conDatosValidos()",
        "usage": "ConstructorSolicitudCrearUsuario.conDatosValidos()"
      }
    },
    "stepDefinitions": {
      "pattern": "Nombre del Recurso + DefinicionesDePasos",
      "examples": [
        "UsuarioDefinicionesDePasos",
        "PersonajeDefinicionesDePasos"
      ],
      "format": "PascalCase",
      "methods": "Nombres descriptivos en espa√±ol: elUsuarioConsultaTodosLosPersonajes()"
    },
    "endpoints": {
      "className": "Pattern: PuntosFinal + Recurso o Recurso + Endpoints (t√©cnico reconocible)",
      "examples": [
        "PersonajeEndpoints",
        "UsuarioEndpoints"
      ],
      "format": "PascalCase",
      "constants": "En espa√±ol: CREAR_USUARIO, OBTENER_TODOS, ACTUALIZAR_POR_ID",
      "reason": "Endpoints puede mantenerse por ser t√©rmino t√©cnico universal"
    }
  },
  "standards": {
    "endpoints": {
      "className": "Pattern: {Resource}Endpoints",
      "example": "UserEndpoints",
      "rules": [
        "NO hardcodear URLs en Tasks",
        "Siempre versionar (ej: /v1)",
        "Usar constantes public static final String"
      ],
      "template": "public class {Resource}Endpoints {\n    public static final String CREATE_{RESOURCE} = \"/v1/{resource}s\";\n    public static final String GET_{RESOURCE} = \"/v1/{resource}s/{id}\";\n}"
    },
    "models": {
      "rules": [
        "Solo datos (sin l√≥gica)",
        "Nombres alineados al contrato API",
        "Usar getters y setters",
        "Pueden usar Lombok para reducir boilerplate"
      ],
      "template": "public class {Name}Request {\n    private String field1;\n    private String field2;\n    \n    // getters & setters\n}"
    },
    "builders": {
      "rules": [
        "Builders generan escenarios",
        "No l√≥gica de env√≠o",
        "M√©todos est√°ticos con nombres descriptivos",
        "Prefijo: with..."
      ],
      "template": "public class {Name}RequestBuilder {\n    public static {Name}Request withValidData() {\n        return new {Name}Request(\"value1\", \"value2\");\n    }\n    \n    public static {Name}Request withInvalidData() {\n        return new {Name}Request(\"invalid1\", \"invalid2\");\n    }\n}",
      "methodPatterns": [
        "withValidData()",
        "withInvalidEmail()",
        "withMissingField()",
        "withEmptyData()"
      ]
    },
    "interactions": {
      "rules": [
        "HTTP vive aqu√≠",
        "Reutilizable",
        "Sin aserciones",
        "Implementa Interaction",
        "M√©todo est√°tico para construcci√≥n"
      ],
      "template": "public class {HttpMethod}Request implements Interaction {\n    private final String endpoint;\n    private final Object body;\n    \n    public {HttpMethod}Request(String endpoint, Object body) {\n        this.endpoint = endpoint;\n        this.body = body;\n    }\n    \n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            {HttpMethod}.to(endpoint)\n                .with(request -> request\n                    .contentType(ContentType.JSON)\n                    .body(body)\n                )\n        );\n    }\n    \n    public static {HttpMethod}Request to(String endpoint, Object body) {\n        return new {HttpMethod}Request(endpoint, body);\n    }\n}",
      "availableTypes": [
        "PostRequest",
        "GetRequest",
        "PutRequest",
        "DeleteRequest",
        "PatchRequest"
      ]
    },
    "tasks": {
      "rules": [
        "Lenguaje de negocio",
        "No HTTP directo",
        "Reutilizable",
        "Implementa Task",
        "M√©todo est√°tico para construcci√≥n"
      ],
      "template": "public class {TaskName} implements Task {\n    private final {Model}Request request;\n    \n    public {TaskName}({Model}Request request) {\n        this.request = request;\n    }\n    \n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            {Interaction}.to({Endpoint}, request)\n        );\n    }\n    \n    public static {TaskName} with({Model}Request request) {\n        return new {TaskName}(request);\n    }\n}"
    },
    "questions": {
      "rules": [
        "Implementa Question<T>",
        "Debe retornar un valor",
        "Sin l√≥gica compleja",
        "M√©todo est√°tico para construcci√≥n"
      ],
      "template": "public class {QuestionName} implements Question<{ReturnType}> {\n    @Override\n    public {ReturnType} answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().{method}();\n    }\n    \n    public static {QuestionName} value() {\n        return new {QuestionName}();\n    }\n}",
      "commonQuestions": [
        {
          "name": "ResponseStatusCode",
          "returns": "Integer",
          "method": "statusCode()"
        },
        {
          "name": "ResponseBodyField",
          "returns": "String",
          "method": "jsonPath().getString(field)"
        },
        {
          "name": "ErrorMessage",
          "returns": "String",
          "method": "jsonPath().getString(\"message\")"
        }
      ]
    },
    "stepDefinitions": {
      "rules": [
        "M√°ximo 3 l√≠neas",
        "No l√≥gica",
        "No aserciones t√©cnicas",
        "Solo orquestaci√≥n"
      ],
      "template": "@{Cucumber}(\"{text}\")\npublic void {methodName}({params}) {\n    actor.attemptsTo(\n        {Task}.with({Builder}.{method}())\n    );\n}",
      "validationTemplate": "@Then(\"{validation text}\")\npublic void {methodName}({type} {param}) {\n    actor.should(\n        seeThat({Question}.value(), equalTo({param}))\n    );\n}"
    }
  },
  "mandatoryValidations": {
    "description": "Cada escenario debe validar m√≠nimo:",
    "required": [
      {
        "validation": "Status code",
        "example": "actor.should(seeThat(ResponseStatusCode.value(), equalTo(200)))"
      },
      {
        "validation": "Un campo del body",
        "example": "actor.should(seeThat(ResponseBodyField.of(\"name\"), equalTo(\"Daniel\")))"
      },
      {
        "validation": "Mensaje de error (si aplica)",
        "example": "actor.should(seeThat(ErrorMessage.value(), containsString(\"invalid\")))"
      }
    ]
  },
  "completeExample": {
    "feature": "Feature: Gesti√≥n de usuarios\n  Scenario: Crear usuario v√°lido\n    When el usuario crea un usuario valido\n    Then la respuesta debe ser 201\n    And el body debe contener el nombre del usuario",
    "endpoint": "public class UserEndpoints {\n    public static final String CREATE_USER = \"/v1/users\";\n    public static final String GET_USER = \"/v1/users/{id}\";\n}",
    "model": "public class CreateUserRequest {\n    private String name;\n    private String email;\n    \n    public CreateUserRequest(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n    // getters & setters\n}",
    "builder": "public class CreateUserRequestBuilder {\n    public static CreateUserRequest withValidData() {\n        return new CreateUserRequest(\"Daniel\", \"daniel@test.com\");\n    }\n    \n    public static CreateUserRequest withInvalidEmail() {\n        return new CreateUserRequest(\"Daniel\", \"invalid-email\");\n    }\n}",
    "interaction": "public class PostRequest implements Interaction {\n    private final String endpoint;\n    private final Object body;\n    \n    public PostRequest(String endpoint, Object body) {\n        this.endpoint = endpoint;\n        this.body = body;\n    }\n    \n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            Post.to(endpoint)\n                .with(request -> request\n                    .contentType(ContentType.JSON)\n                    .body(body)\n                )\n        );\n    }\n    \n    public static PostRequest to(String endpoint, Object body) {\n        return new PostRequest(endpoint, body);\n    }\n}",
    "task": "public class CreateUser implements Task {\n    private final CreateUserRequest request;\n    \n    public CreateUser(CreateUserRequest request) {\n        this.request = request;\n    }\n    \n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            PostRequest.to(UserEndpoints.CREATE_USER, request)\n        );\n    }\n    \n    public static CreateUser with(CreateUserRequest request) {\n        return new CreateUser(request);\n    }\n}",
    "question": "public class ResponseStatusCode implements Question<Integer> {\n    @Override\n    public Integer answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().statusCode();\n    }\n    \n    public static ResponseStatusCode value() {\n        return new ResponseStatusCode();\n    }\n}",
    "stepDefinition": "@When(\"el usuario crea un usuario valido\")\npublic void createUser() {\n    actor.attemptsTo(\n        CreateUser.with(CreateUserRequestBuilder.withValidData())\n    );\n}\n\n@Then(\"la respuesta debe ser {int}\")\npublic void validateStatus(int status) {\n    actor.should(\n        seeThat(ResponseStatusCode.value(), equalTo(status))\n    );\n}\n\n@And(\"el body debe contener el nombre del usuario\")\npublic void validateBodyField() {\n    actor.should(\n        seeThat(ResponseBodyField.of(\"name\"), equalTo(\"Daniel\"))\n    );\n}"
  },
  "forbidden": [
    "Usar @Steps",
    "L√≥gica en step definitions",
    "HTTP directo en Tasks",
    "Aserciones en Interactions",
    "URLs hardcodeadas",
    "L√≥gica en Models",
    "Endpoints sin versi√≥n"
  ],
  "requiredArtifacts": [
    "Feature (.feature)",
    "StepDefinitions (Java)",
    "Task (Java - implements Task)",
    "Interaction (Java - implements Interaction)",
    "Question (Java - implements Question<T>)",
    "Model (Java POJO)",
    "Builder (Java con m√©todos est√°ticos)",
    "Endpoints (Java con constantes)"
  ],
  "serenityBdd4Migration": {
    "description": "Cambios cr√≠ticos en Serenity BDD 4.x que debes conocer",
    "deprecatedClasses": [
      {
        "old": "net.serenitybdd.cucumber.CucumberSerenityRunner",
        "new": "net.serenitybdd.cucumber.CucumberWithSerenity",
        "reason": "Clase deprecada y eliminada en Serenity 4.x",
        "severity": "CR√çTICO",
        "errorType": "Compilaci√≥n",
        "fix": {
          "import": "import net.serenitybdd.cucumber.CucumberWithSerenity;",
          "annotation": "@RunWith(CucumberWithSerenity.class)"
        }
      }
    ],
    "runnerTemplate": "package com.{company}.runners;\n\nimport io.cucumber.junit.CucumberOptions;\nimport net.serenitybdd.cucumber.CucumberWithSerenity;\nimport org.junit.runner.RunWith;\n\n/**\n * Runner principal para la ejecuci√≥n de tests con Serenity BDD y Cucumber\n * Proyecto: {projectName}\n */\n@RunWith(CucumberWithSerenity.class)\n@CucumberOptions(\n    features = \"src/test/resources/features\",\n    glue = \"com.{company}.stepdefinitions\",\n    tags = \"not @ignore\",\n    snippets = CucumberOptions.SnippetType.CAMELCASE,\n    plugin = {\"pretty\", \"json:target/cucumber-reports/cucumber.json\"}\n)\npublic class ApiTestRunner {\n    // Runner configurado para ejecutar features con Serenity Screenplay\n}"
  },
  "serenityRestApiChanges": {
    "description": "Cambios en la API de REST Assured con Serenity 4.x",
    "criticalChanges": [
      {
        "method": "Get.to()",
        "status": "DEPRECADO",
        "replacement": "Get.resource()",
        "severity": "CR√çTICO",
        "errorType": "Compilaci√≥n",
        "errorMessage": "cannot find symbol - method to(String)",
        "reason": "En Serenity BDD 4.x el m√©todo est√°tico cambi√≥ de nombre",
        "fix": {
          "before": "Get.to(endpoint)",
          "after": "Get.resource(endpoint)"
        },
        "example": {
          "incorrect": "actor.attemptsTo(\n    Get.to(\"/api/users\")\n        .with(request -> request.contentType(ContentType.JSON))\n);",
          "correct": "actor.attemptsTo(\n    Get.resource(\"/api/users\")\n        .with(request -> request.contentType(ContentType.JSON))\n);"
        }
      }
    ],
    "httpMethods": {
      "GET": "Get.resource(endpoint)",
      "POST": "Post.to(endpoint)",
      "PUT": "Put.to(endpoint)",
      "DELETE": "Delete.from(endpoint)",
      "PATCH": "Patch.to(endpoint)"
    },
    "interactionTemplate": "public class GetRequest implements Interaction {\n    \n    private final String endpoint;\n    \n    public GetRequest(String endpoint) {\n        if (endpoint == null || endpoint.isEmpty()) {\n            throw new IllegalArgumentException(\"Endpoint cannot be null or empty\");\n        }\n        this.endpoint = endpoint;\n    }\n    \n    @Step(\"{0} env√≠a petici√≥n GET a {1}\")\n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            Get.resource(endpoint)  // ‚úÖ CORRECTO: Get.resource()\n                .with(request -> request\n                    .contentType(ContentType.JSON)\n                    .relaxedHTTPSValidation()\n                )\n        );\n    }\n    \n    public static GetRequest to(String endpoint) {\n        return instrumented(GetRequest.class, endpoint);\n    }\n}"
  },
  "byteBuddyRequirements": {
    "description": "Serenity usa ByteBuddy para crear proxies din√°micos - Requisitos obligatorios",
    "reason": "ByteBuddy necesita instanciar clases para logging, screenshots y reportes",
    "criticalRules": [
      {
        "rule": "Tasks DEBEN tener constructor p√∫blico",
        "severity": "CR√çTICO",
        "errorType": "Runtime",
        "forbidden": "private constructor",
        "required": "public constructor o sin modificador (default = public)",
        "errorMessage": "java.lang.NoSuchMethodException: com.example.tasks.TaskName$ByteBuddy.<init>()",
        "fix": "Remover palabra 'private' del constructor"
      },
      {
        "rule": "Interactions DEBEN tener constructor p√∫blico",
        "severity": "CR√çTICO",
        "errorType": "Runtime",
        "forbidden": "private constructor",
        "required": "public constructor o sin modificador (default = public)",
        "errorMessage": "java.lang.NullPointerException: Cannot invoke Object.getClass()",
        "fix": "Remover palabra 'private' del constructor"
      },
      {
        "rule": "Questions NO requieren constructor p√∫blico (pueden ser default)",
        "severity": "INFO",
        "reason": "Questions usan 'new' directamente, no necesitan ByteBuddy",
        "recommended": "Sin modificador o public constructor",
        "notRequired": "instrumented() - NO usar con Questions"
      },
      {
        "rule": "Clases NO deben ser final",
        "severity": "CR√çTICO",
        "reason": "ByteBuddy no puede crear subclases de clases final",
        "forbidden": "final class"
      },
      {
        "rule": "NUNCA usar 'new' para instanciar Tasks/Interactions (S√ç para Questions)",
        "severity": "CR√çTICO",
        "errorType": "Runtime",
        "forbidden": "return new Task() o return new Interaction()",
        "required": "return instrumented(Task.class) o return instrumented(Interaction.class)",
        "allowed": "return new Question() - Questions S√ç usan new",
        "errorMessage": "java.lang.NoSuchMethodException: Cannot create StepFactory",
        "reason": "Tasks/Interactions necesitan instrumentaci√≥n ByteBuddy. Questions NO.",
        "fix": "Usar Tasks.instrumented() para Tasks/Interactions - usar new para Questions"
      }
    ],
    "instrumentationPattern": {
      "description": "Patr√≥n de instanciaci√≥n en Screenplay - CR√çTICO: Tasks/Interactions vs Questions",
      "import": "import static net.serenitybdd.screenplay.Tasks.instrumented;",
      "reason": "instrumented() permite a Serenity interceptar llamadas para generar reportes detallados",
      "criticalRule": "üìö Regla en Screenplay:\nTasks e Interactions ‚Üí Usar instrumented() (tienen l√≥gica compleja)\nQuestions ‚Üí Usar new directamente (solo consultan estado)",
      "rules": [
        "Tasks: SIEMPRE usar 'instrumented(Task.class)' en factory methods",
        "Interactions: SIEMPRE usar 'instrumented(Interaction.class)' en factory methods",
        "Questions: NUNCA usar instrumented() - usar 'new Question()' directamente",
        "Constructor debe ser p√∫blico para Tasks e Interactions (ByteBuddy)",
        "Questions pueden tener constructor sin modificador (default)"
      ],
      "examples": {
        "taskWithoutParameters": {
          "incorrect": "public static GetAllCharacters fromApi() {\n    return new GetAllCharacters();  // ‚ùå ERROR: Causa NoSuchMethodException\n}",
          "correct": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic static GetAllCharacters fromApi() {\n    return instrumented(GetAllCharacters.class);  // ‚úÖ CORRECTO\n}"
        },
        "taskWithParameters": {
          "incorrect": "public static CreateUser with(CreateUserRequest request) {\n    return new CreateUser(request);  // ‚ùå ERROR\n}",
          "correct": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic static CreateUser with(CreateUserRequest request) {\n    return instrumented(CreateUser.class, request);  // ‚úÖ CORRECTO\n}"
        },
        "interactionWithParameters": {
          "incorrect": "public static GetRequest to(String endpoint) {\n    return new GetRequest(endpoint);  // ‚ùå ERROR\n}",
          "correct": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic static GetRequest to(String endpoint) {\n    return instrumented(GetRequest.class, endpoint);  // ‚úÖ CORRECTO\n}"
        },
        "questionWithoutInstrumented": {
          "incorrect": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic static ResponseStatusCode value() {\n    return instrumented(ResponseStatusCode.class);  // ‚ùå ERROR: Questions NO usan instrumented()\n}",
          "correct": "public static ResponseStatusCode value() {\n    return new ResponseStatusCode();  // ‚úÖ CORRECTO: Questions usan new directamente\n}",
          "explanation": "Questions solo consultan estado, no ejecutan l√≥gica compleja. No necesitan instrumentaci√≥n de ByteBuddy."
        }
      }
    },
    "bestPractice": {
      "description": "Usar constructor p√∫blico + factory method con instrumented() para Tasks/Interactions - new para Questions",
      "taskExample": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic class CreateUser implements Task {\n    private final CreateUserRequest request;\n    \n    // Constructor p√∫blico (permite a ByteBuddy instrumentar)\n    public CreateUser(CreateUserRequest request) {\n        if (request == null) {\n            throw new IllegalArgumentException(\"Request cannot be null\");\n        }\n        this.request = request;\n    }\n    \n    @Step(\"{0} crea un usuario\")\n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            PostRequest.to(UserEndpoints.CREATE_USER, request)\n        );\n    }\n    \n    public static CreateUser with(CreateUserRequest request) {\n        return instrumented(CreateUser.class, request);  // ‚úÖ CORRECTO\n    }\n}",
      "interactionExample": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic class PostRequest implements Interaction {\n    private final String endpoint;\n    private final Object body;\n    \n    // Constructor p√∫blico\n    public PostRequest(String endpoint, Object body) {\n        if (endpoint == null || endpoint.isEmpty()) {\n            throw new IllegalArgumentException(\"Endpoint cannot be null or empty\");\n        }\n        this.endpoint = endpoint;\n        this.body = body;\n    }\n    \n    @Step(\"{0} env√≠a POST a {1}\")\n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            Post.to(endpoint).with(request -> request.contentType(ContentType.JSON).body(body))\n        );\n    }\n    \n    public static PostRequest to(String endpoint, Object body) {\n        return instrumented(PostRequest.class, endpoint, body);  // ‚úÖ CORRECTO\n    }\n}",
      "questionExample": "public class ResponseStatusCode implements Question<Integer> {\n    \n    @Step(\"{0} obtiene el status code de la respuesta\")\n    @Override\n    public Integer answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().statusCode();\n    }\n    \n    public static ResponseStatusCode value() {\n        return new ResponseStatusCode();  // ‚úÖ CORRECTO: Questions usan new\n    }\n}",
      "howToRequestQuestions": {
        "description": "Gu√≠a para solicitar la generaci√≥n de Questions con diferentes tipos de retorno",
        "tool": "generateQuestion",
        "requiredParameters": {
          "questionName": "Nombre de la clase (ej: ResponseStatusCode, UserName, ErrorMessage)",
          "returnType": "Tipo de dato Java que retorna (Integer, String, Boolean, Object, List<String>, etc.)",
          "method": "M√©todo de extracci√≥n de SerenityRest.lastResponse() que retorna ese tipo"
        },
        "examples": {
          "statusCode": {
            "request": "Necesito una Question para validar el status code de la respuesta",
            "parameters": {
              "questionName": "ResponseStatusCode",
              "returnType": "Integer",
              "method": "statusCode()"
            },
            "generated": "public class ResponseStatusCode implements Question<Integer> {\n    @Override\n    public Integer answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().statusCode();\n    }\n    public static ResponseStatusCode value() {\n        return new ResponseStatusCode();\n    }\n}"
          },
          "stringField": {
            "request": "Necesito una Question para obtener el campo 'name' del body de la respuesta",
            "parameters": {
              "questionName": "ResponseName",
              "returnType": "String",
              "method": "jsonPath().getString(\"name\")"
            },
            "generated": "public class ResponseName implements Question<String> {\n    @Override\n    public String answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().jsonPath().getString(\"name\");\n    }\n    public static ResponseName value() {\n        return new ResponseName();\n    }\n}"
          },
          "booleanField": {
            "request": "Necesito una Question para validar si el campo 'active' es true",
            "parameters": {
              "questionName": "IsUserActive",
              "returnType": "Boolean",
              "method": "jsonPath().getBoolean(\"active\")"
            },
            "generated": "public class IsUserActive implements Question<Boolean> {\n    @Override\n    public Boolean answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().jsonPath().getBoolean(\"active\");\n    }\n    public static IsUserActive value() {\n        return new IsUserActive();\n    }\n}"
          },
          "objectField": {
            "request": "Necesito una Question para obtener el objeto completo 'user' de la respuesta",
            "parameters": {
              "questionName": "ResponseUserObject",
              "returnType": "Object",
              "method": "jsonPath().getObject(\"user\", Object.class)"
            },
            "generated": "public class ResponseUserObject implements Question<Object> {\n    @Override\n    public Object answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().jsonPath().getObject(\"user\", Object.class);\n    }\n    public static ResponseUserObject value() {\n        return new ResponseUserObject();\n    }\n}"
          },
          "listField": {
            "request": "Necesito una Question para obtener la lista de 'results' de la respuesta",
            "parameters": {
              "questionName": "ResponseResultsList",
              "returnType": "List<Object>",
              "method": "jsonPath().getList(\"results\")"
            },
            "generated": "public class ResponseResultsList implements Question<List<Object>> {\n    @Override\n    public List<Object> answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().jsonPath().getList(\"results\");\n    }\n    public static ResponseResultsList value() {\n        return new ResponseResultsList();\n    }\n}"
          },
          "nestedField": {
            "request": "Necesito una Question para obtener el campo anidado 'data.user.email'",
            "parameters": {
              "questionName": "ResponseUserEmail",
              "returnType": "String",
              "method": "jsonPath().getString(\"data.user.email\")"
            },
            "generated": "public class ResponseUserEmail implements Question<String> {\n    @Override\n    public String answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().jsonPath().getString(\"data.user.email\");\n    }\n    public static ResponseUserEmail value() {\n        return new ResponseUserEmail();\n    }\n}"
          }
        },
        "jsonPathMethods": {
          "description": "M√©todos comunes de jsonPath() seg√∫n tipo de dato",
          "Integer": "jsonPath().getInt(\"campo\")",
          "String": "jsonPath().getString(\"campo\")",
          "Boolean": "jsonPath().getBoolean(\"campo\")",
          "Object": "jsonPath().getObject(\"campo\", Object.class)",
          "List": "jsonPath().getList(\"campo\")",
          "Map": "jsonPath().getMap(\"campo\")",
          "Long": "jsonPath().getLong(\"campo\")",
          "Float": "jsonPath().getFloat(\"campo\")",
          "Double": "jsonPath().getDouble(\"campo\")"
        },
        "bestPractices": [
          "Usar nombres descriptivos: ResponseStatusCode, UserName, ErrorMessage",
          "Tipo de retorno debe coincidir con el m√©todo jsonPath",
          "Para campos anidados usar dot notation: 'data.user.name'",
          "Para listas especificar el tipo gen√©rico: List<String>, List<Object>",
          "Siempre incluir el m√©todo completo: jsonPath().getString() no solo getString()"
        ]
      }
    }
  },
  "actorManagement": {
    "description": "Patr√≥n obligatorio para gesti√≥n de actores en Serenity Screenplay",
    "reason": "Actores creados con Actor.named() NO est√°n gestionados por Serenity",
    "problems": [
      "No lifecycle management",
      "No aparece en reportes",
      "Falta inyecci√≥n de dependencias",
      "State leaks entre escenarios"
    ],
    "required": {
      "beforeHook": "OBLIGATORIO en step definitions",
      "imports": [
        "import io.cucumber.java.Before;",
        "import net.serenitybdd.screenplay.actors.OnStage;",
        "import net.serenitybdd.screenplay.actors.OnlineCast;",
        "import static net.serenitybdd.screenplay.actors.OnStage.theActorCalled;",
        "import static net.serenitybdd.screenplay.actors.OnStage.theActorInTheSpotlight;"
      ]
    },
    "template": "public class UserStepDefinitions {\n    \n    @Before\n    public void setTheStage() {\n        OnStage.setTheStage(new OnlineCast());\n    }\n    \n    @When(\"el usuario crea un usuario valido\")\n    public void createUser() {\n        theActorCalled(\"Usuario\")\n            .whoCan(CallAnApi.at(UserEndpoints.BASE_URL));\n        \n        theActorInTheSpotlight()\n            .attemptsTo(CreateUser.with(CreateUserRequestBuilder.withValidData()));\n    }\n    \n    @Then(\"la respuesta debe ser {int}\")\n    public void validateStatus(int status) {\n        theActorInTheSpotlight()\n            .should(seeThat(ResponseStatusCode.value(), equalTo(status)));\n    }\n}",
    "methods": [
      {
        "name": "OnStage.setTheStage()",
        "description": "Inicializa el sistema de actores",
        "usage": "En @Before hook",
        "parameter": "new OnlineCast()"
      },
      {
        "name": "theActorCalled(String name)",
        "description": "Crea o recupera un actor por nombre",
        "usage": "Primera aparici√≥n del actor en el escenario",
        "returns": "Actor gestionado"
      },
      {
        "name": "theActorInTheSpotlight()",
        "description": "Obtiene el actor actual (√∫ltimo usado)",
        "usage": "En steps subsecuentes del mismo escenario",
        "returns": "Actor con el spotlight"
      }
    ],
    "forbidden": [
      "private Actor actor = Actor.named(\"Usuario\");",
      "Actor actor = Actor.named(\"Usuario\");",
      "Crear actores sin OnStage"
    ]
  },
  "jacksonAnnotations": {
    "description": "Anotaciones obligatorias para serializaci√≥n JSON con Jackson",
    "mandatory": "@JsonIgnoreProperties(ignoreUnknown = true)",
    "reason": "APIs externas pueden devolver m√°s campos de los que necesitas mapear",
    "severity": "CR√çTICO",
    "errorType": "Runtime - Deserializaci√≥n",
    "errorMessage": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field",
    "required": {
      "allModels": "Todos los modelos Request y Response DEBEN tener la anotaci√≥n",
      "import": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;"
    },
    "template": "@JsonIgnoreProperties(ignoreUnknown = true)\npublic class CreateUserRequest {\n    @JsonProperty(\"name\")\n    private String name;\n    \n    @JsonProperty(\"email\")\n    private String email;\n    \n    // Constructor, getters, setters\n}",
    "bestPractices": [
      "Mapear solo los campos necesarios para tus tests",
      "La API puede cambiar sin romper tus tests",
      "Facilita mantenimiento a largo plazo"
    ],
    "whenToUse": [
      "APIs externas (siempre)",
      "Testing (mapear solo lo necesario)",
      "Versionado de APIs (compatibilidad)",
      "Microservicios (contratos flexibles)"
    ]
  },
  "httpStatusCodes": {
    "description": "Status codes HTTP correctos seg√∫n operaci√≥n REST",
    "mandatory": "Usar el status code correcto seg√∫n el m√©todo HTTP",
    "rules": [
      {
        "method": "GET",
        "success": 200,
        "description": "OK - Recurso(s) encontrado(s) y devueltos",
        "error": 404,
        "errorDescription": "Not Found - Recurso no existe",
        "forbidden": [
          201
        ],
        "example": "GET /characters ‚Üí 200 OK"
      },
      {
        "method": "POST",
        "success": 201,
        "description": "Created - Recurso creado exitosamente",
        "alternatives": [
          200
        ],
        "alternativeNote": "200 OK es posible pero 201 es m√°s espec√≠fico",
        "error": 400,
        "errorDescription": "Bad Request - Datos inv√°lidos",
        "example": "POST /users ‚Üí 201 Created"
      },
      {
        "method": "PUT",
        "success": 200,
        "description": "OK - Recurso actualizado y devuelto",
        "alternatives": [
          204
        ],
        "alternativeNote": "204 No Content si no se devuelve el recurso",
        "error": 404,
        "errorDescription": "Not Found - Recurso no existe",
        "example": "PUT /users/1 ‚Üí 200 OK"
      },
      {
        "method": "PATCH",
        "success": 200,
        "description": "OK - Recurso parcialmente actualizado",
        "alternatives": [
          204
        ],
        "alternativeNote": "204 No Content si no se devuelve el recurso",
        "error": 404,
        "errorDescription": "Not Found - Recurso no existe",
        "example": "PATCH /users/1 ‚Üí 200 OK"
      },
      {
        "method": "DELETE",
        "success": 204,
        "description": "No Content - Recurso eliminado",
        "alternatives": [
          200
        ],
        "alternativeNote": "200 OK si se devuelve confirmaci√≥n",
        "error": 404,
        "errorDescription": "Not Found - Recurso no existe",
        "forbidden": [
          201
        ],
        "example": "DELETE /users/1 ‚Üí 204 No Content"
      }
    ],
    "commonMistakes": [
      {
        "mistake": "Usar 201 para GET",
        "correct": "200 OK",
        "explanation": "GET no crea recursos, solo los recupera"
      },
      {
        "mistake": "Usar 200 para POST de creaci√≥n",
        "correct": "201 Created",
        "explanation": "201 es m√°s sem√°nticamente correcto para creaci√≥n"
      },
      {
        "mistake": "Usar 201 para DELETE",
        "correct": "204 No Content",
        "explanation": "DELETE no crea recursos, los elimina"
      }
    ]
  },
  "stepAnnotations": {
    "description": "Anotaci√≥n @Step recomendada para mejor reporting",
    "optional": true,
    "recommended": true,
    "benefits": [
      "Mejora reportes HTML de Serenity",
      "Permite usar placeholders como {0} para el actor",
      "Hace el reporte m√°s legible",
      "Facilita debugging"
    ],
    "usage": {
      "import": "import net.serenitybdd.annotations.Step;",
      "taskExample": "@Step(\"{0} crea un usuario con datos v√°lidos\")\n@Override\npublic <T extends Actor> void performAs(T actor) {\n    actor.attemptsTo(\n        PostRequest.to(UserEndpoints.CREATE_USER, request)\n    );\n}",
      "interactionExample": "@Step(\"{0} env√≠a petici√≥n POST a {1}\")\n@Override\npublic <T extends Actor> void performAs(T actor) {\n    actor.attemptsTo(\n        Post.to(endpoint).with(request -> request.contentType(ContentType.JSON).body(body))\n    );\n}",
      "questionExample": "@Step(\"{0} obtiene el status code de la respuesta\")\n@Override\npublic Integer answeredBy(Actor actor) {\n    return SerenityRest.lastResponse().statusCode();\n}"
    },
    "placeholders": [
      "{0} - Nombre del actor",
      "{1} - Primer par√°metro del m√©todo",
      "{2} - Segundo par√°metro del m√©todo"
    ]
  },
  "troubleshooting": {
    "description": "Gu√≠a r√°pida para resolver errores comunes - Basado en casos reales",
    "errors": [
      {
        "id": 1,
        "error": "cannot find symbol - method to(String)",
        "type": "Compilaci√≥n",
        "component": "Get Interaction",
        "cause": "M√©todo Get.to() deprecado en Serenity 4.x",
        "solution": "Cambiar Get.to() por Get.resource()",
        "fix": "// ‚ùå Incorrecto\nGet.to(endpoint)\n\n// ‚úÖ Correcto\nGet.resource(endpoint)",
        "severity": "CR√çTICO"
      },
      {
        "id": 2,
        "error": "cannot find symbol: class CucumberSerenityRunner",
        "type": "Compilaci√≥n",
        "component": "MainRunner",
        "cause": "Clase deprecada en Serenity 4.x",
        "solution": "Cambiar a CucumberWithSerenity",
        "fix": "// ‚ùå Incorrecto\nimport net.serenitybdd.cucumber.CucumberSerenityRunner;\n@RunWith(CucumberSerenityRunner.class)\n\n// ‚úÖ Correcto\nimport net.serenitybdd.cucumber.CucumberWithSerenity;\n@RunWith(CucumberWithSerenity.class)",
        "severity": "CR√çTICO"
      },
      {
        "id": 3,
        "error": "java.lang.NoSuchMethodException: com.example.tasks.TaskName$ByteBuddy.<init>()",
        "type": "Runtime",
        "component": "Task/Interaction",
        "cause": "Constructor privado o uso de 'new' en lugar de instrumented()",
        "solution": "Constructor p√∫blico + usar Tasks.instrumented()",
        "fix": "// ‚ùå Incorrecto\nprivate GetAllCharacters() {}\npublic static GetAllCharacters fromApi() {\n    return new GetAllCharacters();\n}\n\n// ‚úÖ Correcto\nimport static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic GetAllCharacters() {}  // Constructor p√∫blico\npublic static GetAllCharacters fromApi() {\n    return instrumented(GetAllCharacters.class);\n}",
        "severity": "CR√çTICO",
        "relatedError": "ByteBuddy no puede crear proxy de la clase"
      },
      {
        "id": 4,
        "error": "java.lang.NullPointerException: Cannot invoke Object.getClass() because object is null",
        "type": "Runtime",
        "component": "Actor/StepDefinitions",
        "cause": "Actor sin habilidad CallAnApi configurada",
        "solution": "Configurar CallAnApi en el actor",
        "fix": "// ‚ùå Incorrecto\nprivate Actor actor = Actor.named(\"Usuario\");\nactor.attemptsTo(GetRequest.to(\"/endpoint\"));\n\n// ‚úÖ Correcto - Opci√≥n 1 (Constructor)\npublic StepDefinitions() {\n    this.actor = Actor.named(\"Usuario\");\n    this.actor.whoCan(CallAnApi.at(BASE_URL));\n}\n\n// ‚úÖ Correcto - Opci√≥n 2 (Mejor: @Before hook)\n@Before\npublic void setTheStage() {\n    OnStage.setTheStage(new OnlineCast());\n    OnStage.theActorCalled(\"Usuario\")\n        .whoCan(CallAnApi.at(BASE_URL));\n}",
        "severity": "CR√çTICO",
        "additionalInfo": "Tambi√©n puede ocurrir si el constructor es privado"
      },
      {
        "id": 5,
        "error": "UnrecognizedPropertyException: Unrecognized field",
        "type": "Runtime - Deserializaci√≥n",
        "component": "Model",
        "cause": "Falta @JsonIgnoreProperties en modelo",
        "solution": "Agregar anotaci√≥n al modelo",
        "fix": "// ‚ùå Incorrecto\npublic class UserResponse {\n    private String name;\n}\n\n// ‚úÖ Correcto\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class UserResponse {\n    private String name;\n}",
        "severity": "MEDIO"
      },
      {
        "id": 6,
        "error": "AssertionError: Expected status 201 but was 200",
        "type": "Assertion",
        "component": "Question/Validation",
        "cause": "Status code incorrecto para operaci√≥n GET",
        "solution": "Usar 200 para GET, 201 para POST",
        "fix": "# ‚ùå Incorrecto\nCuando el usuario consulta todos los personajes\nEntonces la respuesta debe ser 201\n\n# ‚úÖ Correcto\nCuando el usuario consulta todos los personajes\nEntonces la respuesta debe ser 200",
        "severity": "BAJO",
        "reference": "Ver httpStatusCodes section"
      }
    ],
    "checklist": [
      "‚úì Runner usa CucumberWithSerenity (no CucumberSerenityRunner)",
      "‚úì Usar Get.resource() en vez de Get.to() para peticiones GET",
      "‚úì Tasks/Interactions tienen constructor p√∫blico (sin 'private')",
      "‚úì Factory methods usan Tasks.instrumented() (NO usar 'new')",
      "‚úì Actor configurado con CallAnApi.at(BASE_URL)",
      "‚úì Step Definitions usan OnStage pattern",
      "‚úì Existe @Before hook con OnStage.setTheStage()",
      "‚úì Modelos tienen @JsonIgnoreProperties(ignoreUnknown = true)",
      "‚úì Status codes correctos (GET=200, POST=201, DELETE=204)",
      "‚úì Anotaci√≥n @Step en Tasks/Interactions (opcional pero recomendada)"
    ],
    "realWorldCasesFixed": {
      "description": "Errores reales encontrados durante implementaci√≥n HU-001 (Rick and Morty API)",
      "project": "rickandmorty-api-automation",
      "totalErrors": 4,
      "errorsSummary": [
        "Error #1: Get.to() ‚Üí Get.resource() (M√©todo deprecado)",
        "Error #2: CucumberSerenityRunner ‚Üí CucumberWithSerenity (Clase deprecada)",
        "Error #3: new Task() ‚Üí instrumented() (Instanciaci√≥n incorrecta)",
        "Error #4: Actor sin CallAnApi (Habilidad faltante)"
      ],
      "result": "BUILD SUCCESSFUL - Todos los errores corregidos aplicando este est√°ndar",
      "testsPassed": true
    }
  },

  "gherkinStandards": {
    "description": "Est√°ndares para escribir escenarios Gherkin modulares y descriptivos seg√∫n el tipo de HU",
  "version": "1.1.0",
    "philosophy": {
      "modularByDefault": "Los escenarios DEBEN ser modulares por defecto para favorecer reutilizaci√≥n y mantenimiento",
      "descriptiveWhenRequired": "Usar escenarios descriptivos solo cuando la HU espec√≠ficamente lo requiera para comunicaci√≥n con negocio",
      "businessReadable": "Los escenarios deben ser legibles para negocio, pero t√©cnicamente ejecutables"
    },

    "scenarioTypes": {
      "modularScenarios": {
        "description": "Escenarios modulares enfocados en acciones t√©cnicas reutilizables",
        "whenToUse": [
          "HU t√©cnicas con operaciones CRUD est√°ndar",
          "APIs con comportamientos repetitivos",
          "Testing de integraci√≥n y contrato",
          "Automatizaci√≥n de regression"
        ],
        "characteristics": [
          "Acciones t√©cnicas claras (GET, POST, PUT, DELETE)",
          "Validaciones espec√≠ficas (status codes, campos)",
          "Par√°metros data-driven con Examples",
          "Reutilizables entre diferentes HU"
        ],
        "patterns": {
          "getOperation": {
            "template": "Feature: Consulta de recursos API\n\n  @HU-001 @api\n  Scenario Outline: Consultar <recurso> por <parametro>\n    Given el servicio de <API> est√° disponible\n    When env√≠o una petici√≥n GET a \"<endpoint>\" con par√°metro \"<parametro>\" = \"<valor>\"\n    Then el c√≥digo de respuesta debe ser <status>\n    And el body debe contener el campo \"<campo>\" con valor \"<valorEsperado>\"\n\n    Examples:\n      | recurso | parametro | valor | endpoint | status | campo | valorEsperado |\n      | usuario | id       | 1     | /users   | 200    | name  | John Doe      |",
            "benefits": [
              "Reutilizable para diferentes recursos",
              "Data-driven con Examples table",
              "Par√°metros configurables",
              "F√°cil mantenimiento"
            ]
          },
          "createOperation": {
            "template": "Feature: Creaci√≥n de recursos API\n\n  @HU-002 @api\n  Scenario Outline: Crear <recurso> con datos v√°lidos\n    Given el servicio de <API> est√° disponible\n    When env√≠o una petici√≥n POST a \"<endpoint>\" con body:\n      \"\"\"\n      <json_template>\n      \"\"\"\n    Then el c√≥digo de respuesta debe ser <status>\n    And el body debe contener el campo \"id\" generado\n    And el campo \"<campo>\" debe ser \"<valor>\"\n\n    Examples:\n      | recurso | endpoint | status | json_template | campo | valor |\n      | usuario | /users   | 201    | {\"name\":\"John\"} | name | John |",
            "benefits": [
              "Plantillas JSON reutilizables",
              "Validaci√≥n de campos requeridos",
              "Idempotencia verificada"
            ]
          },
          "updateOperation": {
            "template": "Feature: Actualizaci√≥n de recursos API\n\n  @HU-003 @api\n  Scenario Outline: Actualizar <recurso> existente\n    Given existe un <recurso> con id <id>\n    When env√≠o una petici√≥n PUT a \"<endpoint>/<id>\" con body:\n      \"\"\"\n      <json_update>\n      \"\"\"\n    Then el c√≥digo de respuesta debe ser <status>\n    And el campo \"<campo>\" debe ser \"<valor_actualizado>\"\n\n    Examples:\n      | recurso | id | endpoint | status | json_update | campo | valor_actualizado |\n      | usuario | 1  | /users   | 200    | {\"name\":\"Jane\"} | name | Jane |",
            "benefits": [
              "Precondiciones claras (Given existe...)",
              "Validaci√≥n de estado final",
              "Pruebas de modificaci√≥n"
            ]
          },
          "deleteOperation": {
            "template": "Feature: Eliminaci√≥n de recursos API\n\n  @HU-004 @api\n  Scenario Outline: Eliminar <recurso> existente\n    Given existe un <recurso> con id <id>\n    When env√≠o una petici√≥n DELETE a \"<endpoint>/<id>\"\n    Then el c√≥digo de respuesta debe ser <status>\n    And al consultar GET \"<endpoint>/<id>\" obtengo status <status_get>\n\n    Examples:\n      | recurso | id | endpoint | status | status_get |\n      | usuario | 1  | /users   | 204    | 404        |",
            "benefits": [
              "Validaci√≥n de eliminaci√≥n efectiva",
              "Verificaci√≥n de idempotencia",
              "Pruebas de integridad"
            ]
          }
        }
      },

      "descriptiveScenarios": {
        "description": "Escenarios descriptivos enfocados en valor de negocio y legibilidad",
        "whenToUse": [
          "HU de negocio complejas",
          "Casos de uso espec√≠ficos del negocio",
          "Documentaci√≥n viva para stakeholders",
          "HU que requieren explicaci√≥n detallada del flujo"
        ],
        "characteristics": [
          "Lenguaje de negocio natural",
          "Flujos completos end-to-end",
          "Menos par√°metros t√©cnicos",
          "Enfocados en valor de negocio"
        ],
        "patterns": {
          "businessWorkflow": {
            "template": "Feature: Gesti√≥n de pedidos de cliente\n\n  @HU-010 @business\n  Scenario: Cliente completa compra exitosamente\n    Given Juan es un cliente registrado en la plataforma\n    And tiene productos en su carrito de compras\n    When completa el proceso de checkout\n    And proporciona informaci√≥n de pago v√°lida\n    And confirma la orden\n    Then debe recibir confirmaci√≥n de la orden\n    And debe recibir un email con los detalles de la compra\n    And el inventario debe actualizarse correctamente",
            "benefits": [
              "Lenguaje natural del negocio",
              "Flujo completo visible",
              "Ideal para documentaci√≥n",
              "F√°cil comprensi√≥n por stakeholders"
            ]
          },
          "errorHandling": {
            "template": "Feature: Manejo de errores en autenticaci√≥n\n\n  @HU-015 @error-handling\n  Scenario: Usuario intenta login con credenciales inv√°lidas\n    Given Mar√≠a intenta acceder al sistema\n    When ingresa un usuario v√°lido pero contrase√±a incorrecta\n    And hace clic en el bot√≥n de login\n    Then debe ver un mensaje de error \"Usuario o contrase√±a incorrectos\"\n    And debe permanecer en la p√°gina de login\n    And no debe tener acceso al sistema",
            "benefits": [
              "Casos de error documentados",
              "Comportamiento esperado claro",
              "Validaci√≥n de UX en errores"
            ]
          },
          "integrationScenario": {
            "template": "Feature: Integraci√≥n con pasarela de pagos\n\n  @HU-020 @integration\n  Scenario: Procesamiento exitoso de pago\n    Given el sistema de pagos est√° disponible\n    And un cliente ha seleccionado productos\n    When inicia el proceso de pago con tarjeta de cr√©dito\n    And la pasarela procesa la transacci√≥n\n    Then debe recibir confirmaci√≥n de pago aprobado\n    And el estado del pedido debe cambiar a \"Pagado\"\n    And debe generarse recibo de compra",
            "benefits": [
              "Integraciones cr√≠ticas documentadas",
              "Flujos cross-system visibles",
              "Validaci√≥n de contratos de integraci√≥n"
            ]
          }
        }
      }
    },

    "gherkinBestPractices": {
      "structure": {
        "feature": {
          "rules": [
            "Una Feature por HU o conjunto de HU relacionadas",
            "Nombre descriptivo en imperativo (Gesti√≥n de..., Consulta de...)",
            "Descripci√≥n opcional pero recomendada",
            "Tags: @HU-XXX, @api/@web, @smoke/@regression"
          ],
          "template": "Feature: <Nombre descriptivo de la funcionalidad>\n\n  Como <rol>\n  Quiero <funcionalidad>\n  Para <beneficio>\n\n  @HU-XXX @<tipo>\n  Scenario: <Descripci√≥n del escenario>"
        },
        "scenario": {
          "rules": [
            "Nombre descriptivo que explique qu√© hace",
            "Estructura Given-When-Then clara",
            "Background para pasos comunes",
            "Scenario Outline para data-driven",
            "Tags espec√≠ficos del escenario"
          ],
          "maxLength": "M√°ximo 3 l√≠neas por step para mantener legibilidad"
        }
      },

      "stepPatterns": {
        "givenPatterns": [
          "Given el servicio est√° disponible",
          "Given existe un <recurso> con <propiedad>",
          "Given el usuario est√° autenticado como <rol>",
          "Given tengo acceso a <sistema/funcionalidad>"
        ],
        "whenPatterns": [
          "When env√≠o una petici√≥n <METHOD> a \"<endpoint>\"",
          "When completo el formulario con datos v√°lidos",
          "When realizo la acci√≥n \"<acci√≥n>\"",
          "When ejecuto la operaci√≥n <operaci√≥n>"
        ],
        "thenPatterns": [
          "Then el c√≥digo de respuesta debe ser <status>",
          "Then el body debe contener <campo> = \"<valor>\"",
          "Then debe mostrar el mensaje \"<mensaje>\"",
          "Then el sistema debe <acci√≥n esperada>"
        ]
      },

      "dataDriven": {
        "whenToUse": [
          "M√∫ltiples combinaciones de datos",
          "Validaci√≥n de edge cases",
          "Pruebas de compatibilidad",
          "Regresi√≥n con diferentes inputs"
        ],
        "examplesTemplate": "Examples:\n  | parametro1 | parametro2 | resultadoEsperado |\n  | valor1     | valor2     | esperado1          |\n  | valor3     | valor4     | esperado2          |",
        "bestPractices": [
          "Nombres descriptivos en headers",
          "Valores representativos del negocio",
          "Incluir casos positivos y negativos",
          "No m√°s de 5-7 columnas por tabla"
        ]
      },

      "tagsStrategy": {
        "featureLevel": [
          "@HU-XXX - Identificador √∫nico de HU",
          "@api/@web - Tipo de automatizaci√≥n",
          "@smoke/@regression - Nivel de prueba",
          "@manual - Solo pruebas manuales",
          "@deprecated - HU obsoleta"
        ],
        "scenarioLevel": [
          "@happy-path - Flujo principal exitoso",
          "@negative - Casos de error",
          "@edge-case - Casos l√≠mite",
          "@integration - Pruebas de integraci√≥n",
          "@performance - Pruebas de performance"
        ],
        "executionTags": [
          "@smokeTest - Ejecuci√≥n r√°pida diaria",
          "@fullRegression - Suite completa",
          "@critical - HU cr√≠ticas para negocio",
          "@blocked - HU bloqueada por dependencias"
        ]
      }
    },

    "modularVsDescriptive": {
      "decisionMatrix": {
        "chooseModularWhen": [
          "HU es t√©cnica y reutilizable",
          "Operaciones CRUD est√°ndar",
          "API testing puro",
          "Necesitas data-driven testing",
          "Mantenimiento t√©cnico frecuente"
        ],
        "chooseDescriptiveWhen": [
          "HU es de negocio cr√≠tico",
          "Necesitas documentaci√≥n viva",
          "Stakeholders requieren legibilidad",
          "Flujo end-to-end complejo",
          "Comunicaci√≥n con negocio no t√©cnico"
        ],
        "hybridApproach": "Usar modular para la implementaci√≥n t√©cnica y descriptive para casos de negocio espec√≠ficos"
      },

      "migrationGuide": {
        "fromDescriptiveToModular": {
          "steps": [
            "Identificar patrones repetitivos en escenarios",
            "Extraer acciones comunes a step definitions reutilizables",
            "Convertir datos hardcodeados en par√°metros",
            "Crear Examples tables para variaciones",
            "Documentar el patr√≥n para reutilizaci√≥n futura"
          ],
          "benefits": "Reducci√≥n de duplicaci√≥n, mejor mantenimiento, ejecuci√≥n m√°s r√°pida"
        },
        "fromModularToDescriptive": {
          "steps": [
            "Traducir t√©rminos t√©cnicos a lenguaje de negocio",
            "Agregar contexto del flujo completo",
            "Incluir precondiciones y postcondiciones de negocio",
            "Documentar el valor de negocio entregado",
            "Agregar explicaciones para stakeholders no t√©cnicos"
          ],
          "benefits": "Mejor comunicaci√≥n, documentaci√≥n viva, alineaci√≥n con negocio"
        }
      }
    },

    "validationRules": {
      "syntaxValidation": [
        "Feature debe tener nombre descriptivo",
        "Scenario debe tener Given-When-Then",
        "Steps deben ser imperativos (no 'I should see')",
        "Tags deben seguir convenci√≥n @HU-XXX",
        "Examples tables deben tener headers descriptivos"
      ],
      "businessValidation": [
        "Escenario debe representar valor de negocio real",
        "Precondiciones deben ser verificables",
        "Validaciones deben ser observables por usuario",
        "Flujo debe ser realista y completo"
      ],
      "technicalValidation": [
        "Step definitions deben existir para cada step",
        "Par√°metros deben mapear correctamente",
        "Examples data debe ser v√°lida",
        "Tags deben estar configurados en runners"
      ]
    },

    "commonPitfalls": [
      {
        "problem": "Steps demasiado t√©cnicos",
        "solution": "Usar lenguaje de negocio en Given/When/Then",
        "example": "‚ùå When env√≠o petici√≥n GET\n‚úÖ When consulto la informaci√≥n del usuario"
      },
      {
        "problem": "Escenarios demasiado largos",
        "solution": "Dividir en escenarios m√°s peque√±os y enfocados",
        "example": "Un escenario de 15 steps ‚Üí 3 escenarios de 5 steps cada uno"
      },
      {
        "problem": "Datos hardcodeados",
        "solution": "Usar Examples tables y par√°metros",
        "example": "‚ùå Given usuario con id 123\n‚úÖ Given usuario con id <userId>"
      },
      {
        "problem": "Validaciones UI en API testing",
        "solution": "Enfocarse en respuestas HTTP y datos",
        "example": "‚ùå Then debe mostrar popup\n‚úÖ Then response status es 201"
      }
    ]
  }
}