{
  "name": "Estándar de Mejores Prácticas Java",
  "version": "1.0.0",
  "purpose": "Definir estándares completos de desarrollo Java desde lo básico hasta lo avanzado, incluyendo validaciones automáticas para asegurar calidad de código",
  "scope": "Desarrollo Java completo",
  "framework": "Java SE/EE",

  "basicPractices": {
    "description": "Fundamentos de Java - Variables, tipos, convenciones",
    "version": "1.0.0",

    "namingConventions": {
      "packages": {
        "pattern": "com.{company}.{project}.{module}",
        "rules": [
          "Todo minúsculas",
          "Sin guiones bajos",
          "Dominio invertido",
          "Máximo 4 niveles de profundidad"
        ],
        "examples": [
          "com.rimac.automation.api",
          "com.sistecredito.web.userinterfaces",
          "com.screenplay.tasks"
        ],
        "validation": "Debe empezar con com|org|net seguido de dominio válido"
      },
      "classes": {
        "pattern": "PascalCase",
        "rules": [
          "Sustantivos descriptivos",
          "Sin abreviaturas excepto comunes (API, HTTP, ID)",
          "Máximo 25 caracteres",
          "No usar números al inicio"
        ],
        "examples": [
          "UserRepository",
          "PaymentProcessor",
          "SearchResult",
          "DataValidator"
        ],
        "forbidden": ["user", "data", "manager", "handler", "util"]
      },
      "interfaces": {
        "pattern": "PascalCase con adjetivo o capacidad",
        "rules": [
          "Terminar en 'able' cuando aplique",
          "Describir capacidad, no implementación",
          "Máximo 20 caracteres"
        ],
        "examples": [
          "Serializable",
          "Validatable",
          "Processable",
          "Repository"
        ]
      },
      "methods": {
        "pattern": "camelCase",
        "rules": [
          "Verbos descriptivos",
          "Parámetros descriptivos",
          "Máximo 15 caracteres",
          "Boolean: is/has/can/should"
        ],
        "examples": [
          "processPayment()",
          "validateInput()",
          "findById(id)",
          "isValidEmail(email)",
          "calculateTotal(items)"
        ],
        "forbidden": ["get()", "set()", "doSomething()"]
      },
      "variables": {
        "pattern": "camelCase",
        "rules": [
          "Descriptivos pero concisos",
          "No abreviaturas excepto i,j,k en loops",
          "Boolean: starts with is/has/can/should",
          "Máximo 20 caracteres"
        ],
        "examples": [
          "userName",
          "paymentAmount",
          "isValid",
          "totalItems",
          "customerEmail"
        ],
        "forbidden": ["a", "b", "c", "data", "temp", "var1"]
      },
      "constants": {
        "pattern": "UPPER_SNAKE_CASE",
        "rules": [
          "Final static",
          "Palabras completas",
          "No números mágicos",
          "Agrupadas en interfaces o clases"
        ],
        "examples": [
          "MAX_RETRY_ATTEMPTS = 3",
          "DEFAULT_TIMEOUT = 5000",
          "API_BASE_URL = \"https://api.example.com\"",
          "MAX_FILE_SIZE = 10485760"
        ]
      }
    },

    "dataTypes": {
      "primitives": {
        "usage": {
          "int": "Números enteros (-2^31 a 2^31-1)",
          "long": "Números enteros grandes (-2^63 a 2^63-1)",
          "double": "Números decimales (64-bit IEEE 754)",
          "boolean": "Valores true/false",
          "char": "Caracteres Unicode (16-bit)"
        },
        "bestPractices": [
          "Usar int para conteos y índices",
          "Usar long para timestamps y IDs grandes",
          "Usar double para cálculos financieros",
          "Evitar float por precisión",
          "Usar boolean para flags"
        ]
      },
      "wrappers": {
        "usage": {
          "Integer": "Cuando necesitas null o collections",
          "Long": "Para IDs de base de datos",
          "Double": "Para cálculos que admiten null",
          "Boolean": "Para lógica nullable",
          "Character": "Para caracteres nullable"
        },
        "rules": [
          "Usar wrappers solo cuando necesario",
          "Preferir primitivos para performance",
          "Usar wrappers en generics",
          "Evitar autoboxing excesivo"
        ]
      },
      "strings": {
        "bestPractices": [
          "Usar StringBuilder para concatenación en loops",
          "String.intern() solo cuando necesario",
          "Validar strings antes de usar",
          "Usar equals() no == para comparación",
          "Considerar StringUtils para validaciones"
        ],
        "patterns": {
          "validation": "if (str != null && !str.trim().isEmpty())",
          "comparison": "string1.equals(string2)",
          "caseInsensitive": "string1.equalsIgnoreCase(string2)"
        }
      }
    },

    "operators": {
      "arithmetic": {
        "rules": [
          "Espacios alrededor de operadores",
          "Paréntesis para claridad",
          "Evitar división por cero",
          "Cast explícito cuando necesario"
        ],
        "examples": [
          "result = (a + b) * c / d;",
          "percentage = (double) obtained / total * 100;",
          "increment = ++counter;"
        ]
      },
      "comparison": {
        "rules": [
          "== para primitivos, equals() para objetos",
          "Evitar autoboxing en comparaciones",
          "Usar compareTo() para rangos",
          "Objects.equals() para null-safety"
        ],
        "examples": [
          "if (Objects.equals(str1, str2))",
          "if (num1.compareTo(num2) > 0)",
          "if (obj1 == null ? obj2 == null : obj1.equals(obj2))"
        ]
      },
      "logical": {
        "rules": [
          "Usar && y || en cortocircuito",
          "Paréntesis para claridad en expresiones complejas",
          "Evitar expresiones demasiado complejas"
        ],
        "examples": [
          "if (isValid && hasPermission)",
          "if ((age >= 18) && (country.equals(\"CO\")))",
          "boolean result = condition1 || (condition2 && condition3)"
        ]
      }
    },

    "comments": {
      "classComments": {
        "pattern": "/**\n * Descripción de la clase\n * @author Nombre\n * @version 1.0\n */",
        "rules": [
          "Describir responsabilidad principal",
          "Mencionar invariantes importantes",
          "Incluir @author y @version",
          "Referenciar HU o requerimiento"
        ]
      },
      "methodComments": {
        "pattern": "/**\n * Descripción del método\n * @param param descripción\n * @return descripción del retorno\n * @throws Exception descripción\n */",
        "rules": [
          "Explicar qué hace, no cómo",
          "Documentar pre/post condiciones",
          "Mencionar algoritmos complejos",
          "Incluir ejemplos cuando ayude"
        ]
      },
      "inlineComments": {
        "rules": [
          "Explicar código no obvio",
          "Documentar algoritmos complejos",
          "Marcar TODO y FIXME",
          "Comentarios en inglés si equipo internacional"
        ],
        "examples": [
          "// Calculate compound interest using formula A = P(1+r)^t",
          "// TODO: Implement caching for better performance",
          "// Edge case: Handle empty collection"
        ]
      }
    }
  },

  "intermediatePractices": {
    "description": "Prácticas intermedias - Clases, métodos, excepciones, collections",
    "version": "1.0.0",

    "classDesign": {
      "structure": {
        "order": [
          "Constantes estáticas",
          "Variables de instancia",
          "Constructores",
          "Métodos públicos",
          "Métodos privados/protegidos",
          "Getters/setters (si necesarios)",
          "toString/equals/hashCode"
        ],
        "rules": [
          "Una responsabilidad por clase",
          "Máximo 500 líneas por clase",
          "Máximo 10 métodos públicos",
          "Campos finales cuando posible"
        ]
      },
      "constructors": {
        "rules": [
          "Validar parámetros",
          "Asignar valores por defecto",
          "Llamar a setters si hay lógica",
          "Documentar efectos secundarios"
        ],
        "patterns": {
          "basic": "public ClassName(String param) {\n    this.param = Objects.requireNonNull(param);\n}",
          "validation": "public ClassName(String param) {\n    if (param == null || param.trim().isEmpty()) {\n        throw new IllegalArgumentException(\"Param cannot be null or empty\");\n    }\n    this.param = param;\n}",
          "builder": "public static Builder builder() {\n    return new Builder();\n}"
        }
      },
      "methods": {
        "design": {
          "rules": [
            "Máximo 30 líneas por método",
            "Máximo 5 parámetros",
            "Nombre descriptivo",
            "Una sola responsabilidad",
            "Validar parámetros de entrada"
          ],
          "patterns": {
            "singleReturn": "Método con un solo punto de retorno",
            "earlyReturn": "Validaciones al inicio, return temprano",
            "guardClauses": "Condiciones de guarda al inicio"
          }
        },
        "parameters": {
          "rules": [
            "Usar tipos específicos, no Object",
            "Validar null cuando no se permita",
            "Usar @NotNull cuando aplique",
            "Considerar objetos parameter para >3 params"
          ],
          "patterns": {
            "validation": "Objects.requireNonNull(param, \"param cannot be null\");",
            "optional": "Optional.ofNullable(param).orElse(defaultValue)",
            "collection": "Collection<? extends T> items"
          }
        }
      }
    },

    "exceptions": {
      "hierarchy": {
        "checked": [
          "IOException",
          "SQLException",
          "InterruptedException",
          "Custom business exceptions"
        ],
        "unchecked": [
          "IllegalArgumentException",
          "IllegalStateException",
          "NullPointerException (evitar lanzar)",
          "UnsupportedOperationException"
        ]
      },
      "handling": {
        "rules": [
          "No suprimir excepciones",
          "Loggear con contexto",
          "Convertir a excepciones de negocio",
          "Usar try-with-resources",
          "Manejar excepciones específicas"
        ],
        "patterns": {
          "tryWithResources": "try (FileReader reader = new FileReader(file)) {\n    // use reader\n} catch (IOException e) {\n    logger.error(\"Error reading file: {}\", file, e);\n}",
          "businessException": "catch (SQLException e) {\n    throw new BusinessException(\"Database error: \" + e.getMessage(), e);\n}",
          "finallyCleanup": "try {\n    // risky operation\n} finally {\n    // cleanup resources\n}"
        }
      },
      "creation": {
        "rules": [
          "Mensaje descriptivo",
          "Incluir causa original",
          "Usar constructores apropiados",
          "No crear excepciones genéricas"
        ],
        "patterns": {
          "withCause": "throw new BusinessException(\"Operation failed\", originalException);",
          "validation": "throw new IllegalArgumentException(\"Invalid parameter: \" + param);",
          "custom": "throw new UserNotFoundException(String.format(\"User with id %d not found\", userId));"
        }
      }
    },

    "collections": {
      "interfaces": {
        "List": {
          "implementations": ["ArrayList", "LinkedList", "Vector (legacy)"],
          "whenToUse": "Acceso por índice, elementos ordenados, duplicados permitidos",
          "bestPractice": "ArrayList para acceso aleatorio, LinkedList para inserciones frecuentes"
        },
        "Set": {
          "implementations": ["HashSet", "TreeSet", "LinkedHashSet"],
          "whenToUse": "Elementos únicos, sin orden garantizado",
          "bestPractice": "HashSet para performance, TreeSet para ordenamiento natural"
        },
        "Map": {
          "implementations": ["HashMap", "TreeMap", "LinkedHashMap"],
          "whenToUse": "Pares clave-valor, acceso rápido por clave",
          "bestPractice": "HashMap para performance, TreeMap para ordenamiento por clave"
        },
        "Queue": {
          "implementations": ["LinkedList", "PriorityQueue", "ArrayDeque"],
          "whenToUse": "Procesamiento FIFO, prioridades",
          "bestPractice": "ArrayDeque para stack/queue operations"
        }
      },
      "bestPractices": {
        "initialization": [
          "Usar Arrays.asList() para listas inmutables pequeñas",
          "Usar List.of() (Java 9+) para listas inmutables",
          "Especificar capacidad inicial cuando conozcas el tamaño",
          "Considerar Collections.unmodifiable*() para defensiva"
        ],
        "iteration": [
          "Usar for-each para legibilidad",
          "Usar streams para operaciones funcionales",
          "Evitar remove() mientras iterates (ConcurrentModificationException)",
          "Usar Iterator.remove() si necesitas modificar durante iteración"
        ],
        "nullHandling": [
          "Validar collections no null",
          "Usar Collections.emptyList() en lugar de null",
          "Considerar Optional para métodos que pueden no retornar elementos"
        ]
      },
      "performance": {
        "considerations": [
          "ArrayList: O(1) acceso, O(n) inserción/remoción",
          "LinkedList: O(n) acceso, O(1) inserción/remoción en extremos",
          "HashMap: O(1) operaciones promedio",
          "TreeMap: O(log n) operaciones"
        ],
        "tips": [
          "Especificar capacidad inicial para evitar resize",
          "Usar primitive collections cuando aplique (Trove, HPPC)",
          "Considerar concurrencia: ConcurrentHashMap, CopyOnWriteArrayList"
        ]
      }
    },

    "inheritance": {
      "rules": [
        "Composición sobre herencia",
        "Herencia solo para IS-A relationships",
        "No más de 3 niveles de herencia",
        "Usar interfaces para capacidades",
        "Marcar métodos final cuando no deban sobrescribirse"
      ],
      "patterns": {
        "templateMethod": "Clase base define algoritmo, subclases implementan pasos",
        "strategy": "Interfaz común, múltiples implementaciones",
        "decorator": "Wrapper que agrega funcionalidad",
        "factory": "Método que decide qué subclase instanciar"
      },
      "antiPatterns": [
        "Herencia por reutilización de código",
        "Jerarquías profundas (>3 niveles)",
        "Override que rompe Liskov Substitution",
        "Herencia de clases concretas"
      ]
    }
  },

  "advancedPractices": {
    "description": "Prácticas avanzadas - Generics, lambdas, streams, concurrencia",
    "version": "1.0.0",

    "generics": {
      "typeParameters": {
        "conventions": {
          "T": "Type (tipo general)",
          "E": "Element (en collections)",
          "K": "Key (en maps)",
          "V": "Value (en maps)",
          "N": "Number",
          "S,U": "Segundos y terceros tipos"
        },
        "rules": [
          "Usar letras mayúsculas",
          "Significativas cuando posible",
          "Consistentes en la clase"
        ]
      },
      "wildcards": {
        "extends": "? extends T - Producer (solo lectura)",
        "super": "? super T - Consumer (solo escritura)",
        "unbounded": "? - Sin restricciones",
        "rules": [
          "PECS: Producer Extends, Consumer Super",
          "Evitar wildcards sin restricciones",
          "Documentar restricciones cuando necesarias"
        ]
      },
      "methods": {
        "genericMethods": "<T> T process(List<T> items)",
        "boundedTypes": "<T extends Number> double sum(List<T> numbers)",
        "rules": [
          "Inferir tipos cuando posible",
          "Evitar raw types",
          "Usar wildcards apropiadamente"
        ]
      }
    },

    "functionalProgramming": {
      "lambdas": {
        "rules": [
          "Usar para expresiones simples (1-3 líneas)",
          "Paréntesis opcionales para un parámetro",
          "Referencias a métodos cuando aplique",
          "No capturar variables mutables"
        ],
        "patterns": {
          "predicate": "list.stream().filter(item -> item.isValid())",
          "function": "list.stream().map(item -> item.getName())",
          "consumer": "list.forEach(item -> System.out.println(item))",
          "supplier": "Optional.ofNullable(value).orElseGet(() -> defaultValue())"
        }
      },
      "streams": {
        "operations": {
          "intermediate": ["filter", "map", "flatMap", "distinct", "sorted", "limit"],
          "terminal": ["collect", "forEach", "reduce", "count", "anyMatch", "allMatch"]
        },
        "bestPractices": [
          "Usar parallel streams solo cuando valga la pena",
          "Evitar side effects en lambdas",
          "Usar Optional para evitar null checks",
          "Collect a collections específicas cuando posible"
        ],
        "patterns": {
          "filterMap": "items.stream().filter(Item::isValid).map(Item::getName).collect(Collectors.toList())",
          "grouping": "items.stream().collect(Collectors.groupingBy(Item::getCategory))",
          "partitioning": "items.stream().collect(Collectors.partitioningBy(Item::isActive))"
        }
      },
      "optional": {
        "rules": [
          "No usar Optional como parámetro de método",
          "Usar Optional como retorno para valores que pueden no existir",
          "Preferir orElse() sobre orElseGet() para valores simples",
          "Usar ifPresent() para side effects"
        ],
        "patterns": {
          "avoidNull": "Optional.ofNullable(value).orElse(defaultValue)",
          "transform": "optional.map(String::toUpperCase).orElse(\"DEFAULT\")",
          "conditional": "optional.ifPresent(System.out::println)"
        }
      }
    },

    "concurrency": {
      "threadSafety": {
        "rules": [
          "Campos finales son thread-safe",
          "Usar Atomic* para contadores",
          "Synchronized blocks sobre métodos",
          "Considerar inmutabilidad"
        ],
        "patterns": {
          "atomic": "private final AtomicInteger counter = new AtomicInteger(0);",
          "volatile": "private volatile boolean flag;",
          "synchronized": "synchronized (lock) { /* critical section */ }"
        }
      },
      "collections": {
        "concurrent": {
          "ConcurrentHashMap": "Thread-safe HashMap",
          "CopyOnWriteArrayList": "Thread-safe ArrayList para lecturas frecuentes",
          "BlockingQueue": "Para producer-consumer patterns"
        },
        "rules": [
          "Usar collections concurrentes cuando necesario",
          "Evitar synchronized collections (performance)",
          "Considerar locks explícitos para lógica compleja"
        ]
      },
      "executors": {
        "types": {
          "FixedThreadPool": "Número fijo de threads",
          "CachedThreadPool": "Threads según demanda",
          "ScheduledThreadPool": "Para tareas programadas",
          "SingleThreadExecutor": "Un solo thread"
        },
        "bestPractices": [
          "Siempre shutdown() executors",
          "Usar try-with-resources cuando posible",
          "Configurar timeouts apropiados",
          "Manejar RejectedExecutionException"
        ]
      }
    },

    "designPatterns": {
      "creational": {
        "singleton": {
          "implementation": "enum o clase con instancia privada",
          "when": "Recurso global único (logger, configuración)",
          "avoid": "Estados mutables, dependencias ocultas"
        },
        "factory": {
          "method": "Método que decide qué clase instanciar",
          "abstractFactory": "Factory de factories",
          "when": "Lógica de creación compleja"
        },
        "builder": {
          "pattern": "Clase Builder con métodos fluentes",
          "when": "Objetos con muchos parámetros opcionales",
          "benefits": "Inmutabilidad, legibilidad"
        }
      },
      "structural": {
        "adapter": "Convertir interfaz incompatible",
        "decorator": "Agregar funcionalidad dinámicamente",
        "facade": "Simplificar interfaz compleja",
        "composite": "Tratar objetos individuales y compuestos igual"
      },
      "behavioral": {
        "strategy": "Encapsular algoritmos intercambiables",
        "observer": "Notificar cambios a múltiples objetos",
        "command": "Encapsular peticiones como objetos",
        "templateMethod": "Definir esqueleto de algoritmo"
      }
    },

    "performance": {
      "memory": {
        "rules": [
          "Evitar memory leaks (listeners, caches)",
          "Usar WeakHashMap para caches",
          "Limpiar referencias en finally blocks",
          "Profilear con VisualVM o JProfiler"
        ],
        "patterns": {
          "objectPooling": "Para objetos caros de crear",
          "flyweight": "Compartir estado inmutable",
          "lazyInitialization": "Inicializar cuando necesario"
        }
      },
      "cpu": {
        "rules": [
          "Evitar algoritmos O(n²) cuando posible",
          "Usar StringBuilder para concatenación",
          "Cachear resultados de operaciones costosas",
          "Usar primitivos en lugar de wrappers en loops"
        ],
        "optimization": {
          "loops": "for (int i = 0; i < array.length; i++)",
          "collections": "for (Item item : items)",
          "streams": "items.stream().filter(...).count()"
        }
      },
      "io": {
        "rules": [
          "Usar try-with-resources",
          "Buffering para archivos grandes",
          "Async I/O para operaciones no bloqueantes",
          "Connection pooling para databases"
        ]
      }
    }
  },

  "cleanCodePrinciples": {
    "description": "Principios de Clean Code aplicados a Java",
    "version": "1.0.0",

    "solidPrinciples": {
      "singleResponsibility": {
        "classLevel": "Una clase = una responsabilidad",
        "methodLevel": "Un método = una acción",
        "indicators": [
          "Nombre de clase responde 'qué hace'",
          "Métodos cohesivos",
          "Cambios en una clase no afectan otras responsabilidades"
        ]
      },
      "openClosed": {
        "implementation": "Interfaces + implementación",
        "benefits": "Extensible sin modificar código existente",
        "indicators": [
          "Uso de interfaces",
          "Método factory para crear instancias",
          "Switch statements mínimos"
        ]
      },
      "liskovSubstitution": {
        "rule": "Subtipo debe ser sustituible por supertipo",
        "indicators": [
          "No override que estreche precondiciones",
          "No override que amplíe excepciones",
          "Comportamiento consistente"
        ]
      },
      "interfaceSegregation": {
        "rule": "Interfaces específicas mejor que generales",
        "indicators": [
          "Interfaces con pocos métodos",
          "No métodos que no todos implementen",
          "Interfaces por rol/capability"
        ]
      },
      "dependencyInversion": {
        "rule": "Depender de abstracciones, no concreciones",
        "indicators": [
          "Inyección de dependencias",
          "Interfaces en lugar de clases concretas",
          "Constructor injection preferido"
        ]
      }
    },

    "codeMetrics": {
      "cyclomaticComplexity": {
        "max": 10,
        "indicators": "Número de caminos independientes en método",
        "refactoring": "Extraer métodos cuando >10"
      },
      "cognitiveComplexity": {
        "max": 15,
        "indicators": "Dificultad de comprensión",
        "refactoring": "Simplificar estructuras anidadas"
      },
      "linesOfCode": {
        "class": 500,
        "method": 30,
        "refactoring": "Extraer clases/métodos"
      },
      "parameters": {
        "max": 5,
        "refactoring": "Crear objeto parameter"
      }
    },

    "codeSmells": {
      "bloaters": [
        "Long Method (>30 líneas)",
        "Large Class (>500 líneas)",
        "Long Parameter List (>5 params)",
        "Data Clumps (parámetros relacionados)"
      ],
      "objectOriented_abusers": [
        "Switch Statements",
        "Temporary Field",
        "Refused Bequest",
        "Alternative Classes with Different Interfaces"
      ],
      "changePreventers": [
        "Divergent Change",
        "Shotgun Surgery",
        "Parallel Inheritance Hierarchies"
      ],
      "dispensables": [
        "Comments (cuando código es claro)",
        "Duplicate Code",
        "Lazy Class",
        "Data Class",
        "Dead Code"
      ]
    }
  },

  "validationRules": {
    "description": "Reglas de validación automática para código Java generado",
    "version": "1.0.0",

    "syntaxValidation": {
      "compilation": "Código debe compilar sin errores",
      "imports": "Imports necesarios presentes y correctos",
      "braces": "Llaves balanceadas y estilo consistente",
      "semicolons": "Punto y coma al final de statements"
    },

    "namingValidation": {
      "packages": "Seguir patrón com.{company}.{project}.{module}",
      "classes": "PascalCase, sustantivos descriptivos",
      "methods": "camelCase, verbos descriptivos",
      "variables": "camelCase, descriptivos",
      "constants": "UPPER_SNAKE_CASE",
      "forbiddenWords": ["util", "helper", "manager", "data", "temp"]
    },

    "structureValidation": {
      "classStructure": [
        "Constantes → Variables → Constructores → Métodos públicos → Privados",
        "Máximo 500 líneas por clase",
        "Máximo 10 métodos públicos"
      ],
      "methodStructure": [
        "Máximo 30 líneas",
        "Máximo 5 parámetros",
        "Validación de parámetros al inicio",
        "Un solo punto de retorno"
      ],
      "imports": [
        "No unused imports",
        "Orden: java.*, javax.*, org.*, com.*",
        "Imports específicos, no *"
      ]
    },

    "qualityValidation": {
      "solidCompliance": {
        "srp": "Una responsabilidad por clase/método",
        "ocp": "Abierto a extensión, cerrado a modificación",
        "lsp": "Subtipos sustituibles",
        "isp": "Interfaces específicas",
        "dip": "Dependencias de abstracciones"
      },
      "cleanCode": {
        "nombresIntencionReveladores": true,
        "funcionesPequeñas": true,
        "evitarComentarios": "Cuando código es claro",
        "manejoErrores": "Excepciones específicas, no genéricas"
      },
      "performance": {
        "noMemoryLeaks": true,
        "efficientCollections": true,
        "primitiveTypes": "Cuando aplique",
        "lazyInitialization": "Cuando beneficie"
      }
    },

    "securityValidation": {
      "inputValidation": "Validar todos los inputs externos",
      "sqlInjection": "Usar PreparedStatement, no concatenación",
      "xss": "Sanitizar output HTML",
      "authentication": "No hardcodear credenciales",
      "sensitiveData": "No loggear información sensible"
    },

    "testingValidation": {
      "testability": "Clases fáciles de testear unitariamente",
      "mockable": "Dependencias inyectables",
      "assertions": "Validaciones claras y específicas",
      "edgeCases": "Casos límite considerados"
    }
  },

  "antiPatterns": {
    "description": "Patrones a evitar en código Java",
    "version": "1.0.0",

    "designAntiPatterns": [
      {
        "name": "God Class",
        "symptoms": ["Clase con miles de líneas", "Múltiples responsabilidades", "Nombre genérico"],
        "solution": "Dividir en clases específicas por responsabilidad"
      },
      {
        "name": "Feature Envy",
        "symptoms": ["Método usa más datos de otra clase", "Lógica que pertenece a otra clase"],
        "solution": "Mover método a la clase que contiene los datos"
      },
      {
        "name": "Data Class",
        "symptoms": ["Solo getters/setters", "Sin lógica de negocio", "Usado como struct"],
        "solution": "Agregar validaciones o mover comportamiento"
      },
      {
        "name": "Primitive Obsession",
        "symptoms": ["Exceso de tipos primitivos", "Validaciones repetidas", "Sin objetos de dominio"],
        "solution": "Crear Value Objects (Email, Money, etc.)"
      }
    ],

    "implementationAntiPatterns": [
      {
        "name": "Magic Numbers",
        "symptoms": ["Números hardcodeados", "Sin significado claro"],
        "solution": "Crear constantes con nombres descriptivos"
      },
      {
        "name": "String Concatenation in Loops",
        "symptoms": ["String + en loops", "Performance degradada"],
        "solution": "Usar StringBuilder"
      },
      {
        "name": "Exception Swallowing",
        "symptoms": ["catch (Exception e) {}", "Sin logging ni re-throw"],
        "solution": "Loggear y manejar apropiadamente"
      },
      {
        "name": "Resource Leaks",
        "symptoms": ["Streams/Connections no cerrados", "finally vacío"],
        "solution": "Usar try-with-resources"
      }
    ],

    "performanceAntiPatterns": [
      {
        "name": "Premature Optimization",
        "symptoms": ["Código complejo por 'performance'", "Sin medición real"],
        "solution": "Medir primero, optimizar después"
      },
      {
        "name": "Micro-optimization",
        "symptoms": ["Cambios mínimos de performance", "Código menos legible"],
        "solution": "Enfocarse en bottlenecks reales"
      },
      {
        "name": "Inefficient Collections",
        "symptoms": ["ArrayList para acceso aleatorio frecuente", "HashSet con elementos duplicados"],
        "solution": "Elegir colección apropiada para el caso de uso"
      }
    ]
  },

  "refactoringPatterns": {
    "description": "Patrones para refactorizar código Java",
    "version": "1.0.0",

    "extractMethod": {
      "when": "Método largo con lógica clara",
      "how": "Seleccionar código → Extract Method",
      "benefit": "Mejor legibilidad y reutilización"
    },
    "extractClass": {
      "when": "Clase con múltiples responsabilidades",
      "how": "Crear nueva clase y mover campos/métodos",
      "benefit": "Aplica SRP, reduce complejidad"
    },
    "introduceParameterObject": {
      "when": "Método con >3 parámetros relacionados",
      "how": "Crear clase que agrupe parámetros",
      "benefit": "Mejor legibilidad, encapsulación"
    },
    "replaceConditionalWithPolymorphism": {
      "when": "Switch/if sobre tipo de objeto",
      "how": "Crear jerarquía con método polimórfico",
      "benefit": "Aplica OCP, más extensible"
    },
    "extractInterface": {
      "when": "Múltiples clases comparten comportamiento",
      "how": "Extraer interfaz común",
      "benefit": "Aplica DIP, mejor testabilidad"
    },
    "replaceInheritanceWithComposition": {
      "when": "Herencia no representa IS-A real",
      "how": "Usar composición con interfaces",
      "benefit": "Más flexible, menos acoplamiento"
    }
  },

  "crossReferences": {
    "description": "Referencias a estándares relacionados",
    "apiStandard": {
      "file": "serenity-api-screenplay.standard.json",
      "shared": [
        "namingConventions (consistent)",
        "classDesign (Java basics)",
        "exceptions (handling patterns)",
        "cleanCodePrinciples (SOLID)"
      ],
      "differences": "API estándar enfocado en HTTP, este es Java general"
    },
    "webStandard": {
      "file": "serenity-web-screenplay.standard.json",
      "shared": [
        "namingConventions (consistent)",
        "classDesign (Java basics)",
        "collections (usage patterns)",
        "cleanCodePrinciples (SOLID)"
      ],
      "differences": "Web estándar enfocado en UI, este es Java general"
    },
    "consistency": [
      "Mismas convenciones de naming",
      "Mismos principios SOLID",
      "Mismos patrones de diseño",
      "Validaciones consistentes"
    ]
  },

  "implementationChecklist": {
    "description": "Checklist para validar implementación Java",
    "basic": [
      "✅ Nombres siguen convenciones",
      "✅ Tipos de datos apropiados",
      "✅ Comentarios útiles y necesarios",
      "✅ Código compila sin warnings"
    ],
    "intermediate": [
      "✅ Clases cohesivas y de tamaño apropiado",
      "✅ Métodos pequeños y enfocados",
      "✅ Manejo adecuado de excepciones",
      "✅ Collections eficientes"
    ],
    "advanced": [
      "✅ Uso correcto de generics",
      "✅ Streams y lambdas apropiados",
      "✅ Thread-safety cuando necesario",
      "✅ Patrones de diseño correctos"
    ],
    "quality": [
      "✅ Principios SOLID aplicados",
      "✅ Métricas de código aceptables",
      "✅ Sin code smells conocidos",
      "✅ Tests unitarios posibles"
    ],
    "performance": [
      "✅ Sin memory leaks",
      "✅ Algoritmos eficientes",
      "✅ Resources liberados correctamente",
      "✅ Concurrencia apropiada"
    ]
  }
}