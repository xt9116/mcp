{
  "name": "Estándar de Programación Orientada a Objetos y Principios SOLID",
  "version": "1.1.0",
  "purpose": "Definir una forma única, consistente y escalable de implementar código orientado a objetos siguiendo los principios SOLID",
  "scope": "Programación Orientada a Objetos",
  
  "oopPrinciples": {
    "encapsulation": {
      "name": "Encapsulación",
      "description": "Ocultar los detalles de implementación y exponer solo lo necesario",
      "rules": [
        "Campos privados (private) por defecto",
        "Usar getters y setters para acceso controlado",
        "No exponer estructuras de datos internas",
        "Validar datos en setters",
        "Mantener invariantes de clase"
      ],
      "examples": {
        "good": "public class BankAccount {\n    private double balance;\n    \n    public void deposit(double amount) {\n        if (amount <= 0) throw new IllegalArgumentException();\n        this.balance += amount;\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n}",
        "bad": "public class BankAccount {\n    public double balance;\n}"
      },
      "violations": [
        "Campos públicos",
        "Exponer colecciones mutables",
        "Permitir modificación directa de estado interno"
      ]
    },
    
    "abstraction": {
      "name": "Abstracción",
      "description": "Simplificar la complejidad exponiendo solo los detalles relevantes",
      "rules": [
        "Usar interfaces para contratos",
        "Clases abstractas para comportamiento común",
        "Métodos bien nombrados que expresen intención",
        "Ocultar detalles de implementación complejos",
        "Exponer APIs simples y claras"
      ],
      "examples": {
        "good": "public interface PaymentProcessor {\n    PaymentResult process(Payment payment);\n}\n\npublic class CreditCardProcessor implements PaymentProcessor {\n    @Override\n    public PaymentResult process(Payment payment) {\n        // Detalles complejos ocultos\n        return validateAndCharge(payment);\n    }\n}",
        "bad": "public class PaymentHandler {\n    public void doPayment(String card, String cvv, double amount, String currency) {\n        // Todo expuesto, sin abstracción\n    }\n}"
      },
      "violations": [
        "Métodos con demasiados parámetros",
        "Lógica compleja sin abstraer",
        "Nombres técnicos en lugar de conceptuales"
      ]
    },
    
    "inheritance": {
      "name": "Herencia",
      "description": "Reutilizar código mediante relaciones 'es-un'",
      "rules": [
        "Usar herencia solo para relaciones IS-A verdaderas",
        "Preferir composición sobre herencia",
        "Clases base deben ser completas y usables",
        "No más de 3 niveles de herencia",
        "Marcar métodos como final si no deben sobrescribirse"
      ],
      "examples": {
        "good": "public abstract class Animal {\n    protected String name;\n    \n    public abstract void makeSound();\n}\n\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Woof!\");\n    }\n}",
        "bad": "public class Rectangle {\n    protected int width, height;\n}\n\npublic class Square extends Rectangle {\n    // Viola LSP, Square no es Rectangle\n}"
      },
      "violations": [
        "Herencia solo por reutilización de código",
        "Jerarquías profundas (>3 niveles)",
        "Clases base abstractas vacías"
      ]
    },
    
    "polymorphism": {
      "name": "Polimorfismo",
      "description": "Permitir que objetos de diferentes tipos sean tratados de manera uniforme",
      "rules": [
        "Usar interfaces para definir comportamientos",
        "Implementar métodos sobrescritos correctamente",
        "Evitar instanceof y casting excesivo",
        "Diseñar para el tipo abstracto, no la implementación",
        "Usar polimorfismo en lugar de condicionales"
      ],
      "examples": {
        "good": "public interface Shape {\n    double calculateArea();\n}\n\npublic class Circle implements Shape {\n    private double radius;\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\n// Uso polimórfico\nList<Shape> shapes = Arrays.asList(new Circle(), new Rectangle());\nshapes.forEach(shape -> System.out.println(shape.calculateArea()));",
        "bad": "public double calculateArea(Object obj) {\n    if (obj instanceof Circle) {\n        Circle c = (Circle) obj;\n        return Math.PI * c.radius * c.radius;\n    } else if (obj instanceof Rectangle) {\n        // ...\n    }\n}"
      },
      "violations": [
        "Uso excesivo de instanceof",
        "Switch/if sobre tipos",
        "Casting no seguro"
      ]
    }
  },
  
  "solidPrinciples": {
    "singleResponsibility": {
      "initial": "S",
      "name": "Single Responsibility Principle (SRP)",
      "description": "Una clase debe tener una única razón para cambiar",
      "definition": "Cada clase debe tener una única responsabilidad o propósito",
      "rules": [
        "Una clase = una responsabilidad",
        "Métodos cohesivos relacionados con esa responsabilidad",
        "Si se describe con 'Y' u 'O', probablemente viola SRP",
        "Cambios en diferentes partes del sistema no deben afectar la misma clase"
      ],
      "examples": {
        "violation": "public class Employee {\n    private String name;\n    private double salary;\n    \n    // Responsabilidad 1: Datos del empleado\n    public String getName() { return name; }\n    \n    // Responsabilidad 2: Cálculo de salario\n    public double calculateSalary() { /*...*/ }\n    \n    // Responsabilidad 3: Persistencia\n    public void saveToDatabase() { /*...*/ }\n    \n    // Responsabilidad 4: Reportes\n    public void generateReport() { /*...*/ }\n}",
        "correct": "// Responsabilidad 1: Datos\npublic class Employee {\n    private String name;\n    private double salary;\n    \n    public String getName() { return name; }\n    public double getSalary() { return salary; }\n}\n\n// Responsabilidad 2: Cálculo\npublic class SalaryCalculator {\n    public double calculate(Employee employee) { /*...*/ }\n}\n\n// Responsabilidad 3: Persistencia\npublic class EmployeeRepository {\n    public void save(Employee employee) { /*...*/ }\n}\n\n// Responsabilidad 4: Reportes\npublic class EmployeeReportGenerator {\n    public Report generate(Employee employee) { /*...*/ }\n}"
      },
      "benefits": [
        "Código más fácil de entender",
        "Reducción de acoplamiento",
        "Facilita testing",
        "Menor impacto de cambios"
      ],
      "violations": [
        "Clases \"God Object\" con múltiples responsabilidades",
        "Mezclar lógica de negocio con persistencia",
        "UI y lógica en la misma clase"
      ]
    },
    
    "openClosed": {
      "initial": "O",
      "name": "Open/Closed Principle (OCP)",
      "description": "Las entidades de software deben estar abiertas para extensión pero cerradas para modificación",
      "definition": "Debe poder extender el comportamiento sin modificar el código existente",
      "rules": [
        "Usar abstracciones (interfaces/clases abstractas)",
        "Nuevo comportamiento = nueva clase, no modificación",
        "Diseñar puntos de extensión",
        "Plugin architecture cuando sea apropiado"
      ],
      "examples": {
        "violation": "public class AreaCalculator {\n    public double calculate(Object shape) {\n        if (shape instanceof Circle) {\n            Circle circle = (Circle) shape;\n            return Math.PI * circle.radius * circle.radius;\n        } else if (shape instanceof Rectangle) {\n            Rectangle rect = (Rectangle) shape;\n            return rect.width * rect.height;\n        }\n        // Para agregar Square, hay que MODIFICAR esta clase\n        return 0;\n    }\n}",
        "correct": "public interface Shape {\n    double calculateArea();\n}\n\npublic class Circle implements Shape {\n    private double radius;\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class Rectangle implements Shape {\n    private double width, height;\n    \n    @Override\n    public double calculateArea() {\n        return width * height;\n    }\n}\n\n// Para agregar Square, EXTENDEMOS sin modificar\npublic class Square implements Shape {\n    private double side;\n    \n    @Override\n    public double calculateArea() {\n        return side * side;\n    }\n}\n\n// AreaCalculator no necesita cambios\npublic class AreaCalculator {\n    public double calculate(Shape shape) {\n        return shape.calculateArea();\n    }\n}"
      },
      "benefits": [
        "Código más mantenible",
        "Menos riesgo de bugs en código existente",
        "Facilita agregar nuevas funcionalidades"
      ],
      "violations": [
        "Switch/if sobre tipos",
        "Modificar clases existentes para nuevo comportamiento",
        "Falta de abstracción"
      ]
    },
    
    "liskovSubstitution": {
      "initial": "L",
      "name": "Liskov Substitution Principle (LSP)",
      "description": "Los objetos de una clase derivada deben poder reemplazar objetos de la clase base sin alterar el correcto funcionamiento del programa",
      "definition": "Si S es subtipo de T, entonces objetos de tipo T pueden ser reemplazados por objetos de tipo S",
      "rules": [
        "La subclase debe cumplir el contrato de la clase base",
        "No fortalecer precondiciones",
        "No debilitar postcondiciones",
        "Mantener invariantes de la clase base",
        "No lanzar nuevas excepciones no declaradas"
      ],
      "examples": {
        "violation": "public class Rectangle {\n    protected int width, height;\n    \n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    public int getArea() { return width * height; }\n}\n\npublic class Square extends Rectangle {\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width; // Viola LSP\n    }\n    \n    @Override\n    public void setHeight(int height) {\n        this.width = height; // Viola LSP\n        this.height = height;\n    }\n}\n\n// Prueba que falla:\nRectangle rect = new Square();\nrect.setWidth(5);\nrect.setHeight(4);\nassert rect.getArea() == 20; // Falla! Es 16",
        "correct": "public interface Shape {\n    double getArea();\n}\n\npublic class Rectangle implements Shape {\n    private final int width, height;\n    \n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    @Override\n    public double getArea() {\n        return width * height;\n    }\n}\n\npublic class Square implements Shape {\n    private final int side;\n    \n    public Square(int side) {\n        this.side = side;\n    }\n    \n    @Override\n    public double getArea() {\n        return side * side;\n    }\n}"
      },
      "benefits": [
        "Jerarquías de herencia correctas",
        "Código más predecible",
        "Polimorfismo confiable"
      ],
      "violations": [
        "Subclases que no cumplen el contrato",
        "Lanzar excepciones inesperadas",
        "Cambiar comportamiento esperado"
      ]
    },
    
    "interfaceSegregation": {
      "initial": "I",
      "name": "Interface Segregation Principle (ISP)",
      "description": "Los clientes no deben ser forzados a depender de interfaces que no usan",
      "definition": "Es mejor tener muchas interfaces específicas que una interfaz general",
      "rules": [
        "Interfaces pequeñas y cohesivas",
        "Una interfaz por rol o capacidad",
        "No obligar a implementar métodos innecesarios",
        "Separar interfaces por cliente"
      ],
      "examples": {
        "violation": "public interface Worker {\n    void work();\n    void eat();\n    void sleep();\n    void getSalary();\n}\n\npublic class HumanWorker implements Worker {\n    public void work() { /*...*/ }\n    public void eat() { /*...*/ }\n    public void sleep() { /*...*/ }\n    public void getSalary() { /*...*/ }\n}\n\npublic class RobotWorker implements Worker {\n    public void work() { /*...*/ }\n    public void eat() { /* No aplica! */ }\n    public void sleep() { /* No aplica! */ }\n    public void getSalary() { /* No aplica! */ }\n}",
        "correct": "public interface Workable {\n    void work();\n}\n\npublic interface Eatable {\n    void eat();\n}\n\npublic interface Sleepable {\n    void sleep();\n}\n\npublic interface Payable {\n    void getSalary();\n}\n\npublic class HumanWorker implements Workable, Eatable, Sleepable, Payable {\n    public void work() { /*...*/ }\n    public void eat() { /*...*/ }\n    public void sleep() { /*...*/ }\n    public void getSalary() { /*...*/ }\n}\n\npublic class RobotWorker implements Workable {\n    public void work() { /*...*/ }\n}"
      },
      "benefits": [
        "Interfaces más fáciles de implementar",
        "Menor acoplamiento",
        "Mayor flexibilidad"
      ],
      "violations": [
        "Interfaces \"fat\" con muchos métodos",
        "Métodos que no todos los implementadores necesitan",
        "Implementaciones vacías o con throw UnsupportedOperationException"
      ]
    },
    
    "dependencyInversion": {
      "initial": "D",
      "name": "Dependency Inversion Principle (DIP)",
      "description": "Los módulos de alto nivel no deben depender de módulos de bajo nivel. Ambos deben depender de abstracciones",
      "definition": "Depender de abstracciones, no de concreciones",
      "rules": [
        "Depender de interfaces/abstracciones, no de clases concretas",
        "Inyectar dependencias (constructor, setter, interface)",
        "No usar 'new' para dependencias, usar factories o DI containers",
        "Las abstracciones no deben depender de detalles"
      ],
      "examples": {
        "violation": "public class UserService {\n    private MySQLDatabase database; // Dependencia concreta\n    \n    public UserService() {\n        this.database = new MySQLDatabase(); // Acoplamiento fuerte\n    }\n    \n    public User getUser(int id) {\n        return database.query(\"SELECT * FROM users WHERE id = \" + id);\n    }\n}",
        "correct": "// Abstracción\npublic interface UserRepository {\n    User findById(int id);\n}\n\n// Implementación concreta\npublic class MySQLUserRepository implements UserRepository {\n    @Override\n    public User findById(int id) {\n        // Detalles de MySQL\n    }\n}\n\n// Servicio de alto nivel depende de abstracción\npublic class UserService {\n    private final UserRepository repository;\n    \n    // Inyección por constructor\n    public UserService(UserRepository repository) {\n        this.repository = repository;\n    }\n    \n    public User getUser(int id) {\n        return repository.findById(id);\n    }\n}\n\n// Uso\nUserRepository repo = new MySQLUserRepository();\nUserService service = new UserService(repo);"
      },
      "benefits": [
        "Bajo acoplamiento",
        "Fácil de testear (mocks/stubs)",
        "Flexible para cambios"
      ],
      "violations": [
        "Usar 'new' para crear dependencias",
        "Dependencia directa de clases concretas",
        "No usar inyección de dependencias"
      ]
    }
  },
  
  "designPatterns": {
    "creational": {
      "singleton": "Garantizar una única instancia de una clase",
      "factory": "Crear objetos sin especificar la clase exacta",
      "builder": "Construir objetos complejos paso a paso",
      "prototype": "Clonar objetos existentes"
    },
    "structural": {
      "adapter": "Adaptar interfaces incompatibles",
      "decorator": "Agregar funcionalidad dinámicamente",
      "facade": "Simplificar interfaces complejas",
      "proxy": "Controlar acceso a un objeto"
    },
    "behavioral": {
      "strategy": "Encapsular algoritmos intercambiables",
      "observer": "Notificar cambios a múltiples objetos",
      "command": "Encapsular peticiones como objetos",
      "template": "Definir esqueleto de algoritmo"
    }
  },
  
  "bestPractices": {
    "naming": {
      "classes": "Sustantivos, PascalCase (User, OrderProcessor)",
      "interfaces": "Adjetivos o capacidades (Readable, Serializable)",
      "methods": "Verbos, camelCase (calculateTotal, saveUser)",
      "constants": "UPPER_SNAKE_CASE (MAX_SIZE, DEFAULT_TIMEOUT)"
    },
    "cohesion": "Métodos y datos de una clase deben estar fuertemente relacionados",
    "coupling": "Minimizar dependencias entre clases",
    "immutability": "Preferir objetos inmutables cuando sea posible",
    "composition": "Favorecer composición sobre herencia",
    "fail-fast": "Validar temprano y lanzar excepciones claras"
  },
  
  "codeSmells": {
    "longMethod": "Métodos con más de 20 líneas",
    "longParameterList": "Más de 3-4 parámetros",
    "largeClass": "Clases con más de 200-300 líneas",
    "dataClass": "Clases solo con getters/setters sin lógica",
    "godClass": "Clase que hace demasiado",
    "featureEnvy": "Método que usa más datos de otra clase",
    "primitiveObsession": "Usar primitivos en lugar de objetos",
    "switchStatements": "Múltiples switch sobre el mismo tipo",
    "duplicateCode": "Código duplicado entre clases",
    "inappropriateIntimacy": "Clases que acceden excesivamente a datos privados de otras",
    "indecentExposure": "Exponer datos internos que deberían ser privados",
    "lazyClass": "Clase que no justifica su existencia",
    "middleMan": "Clase que solo delega a otra sin agregar valor"
  },
  
  "metrics": {
    "cyclomaticComplexity": "Máximo 10 por método",
    "linesOfCode": "Máximo 200-300 por clase",
    "methodLength": "Máximo 20-30 líneas",
    "classDepth": "Máximo 3 niveles de herencia",
    "coupling": "Bajo acoplamiento (máximo 7 dependencias)",
    "cohesion": "Alta cohesión (LCOM < 0.5)",
    "efferentCoupling": "Máximo 10 dependencias salientes",
    "afferentCoupling": "Máximo 20 dependencias entrantes",
    "instability": "I = Ce/(Ca+Ce) < 0.5 para estabilidad",
    "abstractness": "A = Na/Nc, mantener balance con I"
  },

  "antiPatterns": {
    "godObject": {
      "description": "Objeto que sabe demasiado o hace demasiado",
      "symptoms": ["Clase con cientos de líneas", "Múltiples responsabilidades", "Nombre genérico como 'Manager' o 'Handler'"],
      "refactoring": "Extraer clases específicas por responsabilidad"
    },
    "featureEnvy": {
      "description": "Método más interesado en datos de otra clase que en los propios",
      "symptoms": ["Método que llama muchos getters de otra clase", "Lógica que pertenece a otra clase"],
      "refactoring": "Mover método a la clase que contiene los datos"
    },
    "dataClass": {
      "description": "Clase que solo contiene datos sin comportamiento",
      "symptoms": ["Solo getters y setters", "Sin lógica de negocio", "Usada como estructura de datos"],
      "refactoring": "Agregar validaciones o mover comportamiento desde otras clases"
    },
    "primitiveObsession": {
      "description": "Uso excesivo de tipos primitivos donde deberían usarse objetos",
      "symptoms": ["Múltiples parámetros primitivos", "Validaciones repetidas", "Tipos primitivos como String para emails, fechas, etc."],
      "refactoring": "Crear Value Objects (ej: Email, Money, DateRange)"
    }
  },

  "refactoringPatterns": {
    "extractClass": {
      "when": "Una clase tiene dos o más responsabilidades",
      "how": "Crear nueva clase y mover campos/métodos relacionados",
      "benefit": "Aplica SRP, mejora mantenibilidad"
    },
    "extractMethod": {
      "when": "Método demasiado largo o hace múltiples cosas",
      "how": "Extraer lógica en métodos más pequeños y descriptivos",
      "benefit": "Mejora legibilidad y testabilidad"
    },
    "introduceParameterObject": {
      "when": "Método con demasiados parámetros relacionados",
      "how": "Crear objeto que agrupe los parámetros",
      "benefit": "Reduce complejidad de métodos, mejora encapsulación"
    },
    "replaceConditionalWithPolymorphism": {
      "when": "Condicionales que cambian según el tipo",
      "how": "Crear jerarquía de clases con método polimórfico",
      "benefit": "Aplica OCP, elimina switches, facilita extensión"
    },
    "extractInterface": {
      "when": "Múltiples clases comparten comportamiento común",
      "how": "Extraer interfaz con métodos comunes",
      "benefit": "Aplica DIP, mejora testabilidad"
    }
  },
  
  "testingAndSOLID": {
    "unitTesting": {
      "description": "SOLID facilita el testing unitario",
      "srp": "Clases pequeñas con una responsabilidad = fáciles de testear",
      "ocp": "Extensiones no afectan tests existentes",
      "lsp": "Subclases pueden ser testeadas con mismos tests",
      "isp": "Interfaces pequeñas = menos mocks",
      "dip": "Dependencias inyectadas = fácil mocking"
    },
    "mockingStrategies": {
      "interfaces": "Mockear interfaces en lugar de clases concretas",
      "dependencyInjection": "Constructor injection facilita reemplazo de dependencias",
      "composition": "Favorecer composición para facilitar testing"
    }
  },

  "advancedPractices": {
    "domainDrivenDesign": {
      "entities": "Objetos con identidad única y estado mutable",
      "valueObjects": "Objetos inmutables que representan conceptos del dominio",
      "aggregates": "Grupos de entidades tratadas como unidad",
      "repositories": "Abstracciones para acceso a datos",
      "services": "Operaciones que no pertenecen a una entidad específica"
    },
    "cleanArchitecture": {
      "layers": {
        "entities": "Reglas de negocio centrales",
        "useCases": "Casos de uso de la aplicación",
        "interfaceAdapters": "Adaptadores para UI, BD, etc.",
        "frameworks": "Herramientas externas (frameworks, drivers)"
      },
      "dependencyRule": "Las dependencias solo apuntan hacia adentro"
    },
    "compositionVsInheritance": {
      "whenToUseInheritance": "Relación 'es-un' verdadera, polimorfismo",
      "whenToUseComposition": "Relación 'tiene-un', mayor flexibilidad",
      "favorComposition": "Composición es más flexible y testable"
    }
  },

  "mandatoryChecks": [
    "Validar que cada clase tiene una única responsabilidad (SRP)",
    "Verificar que las abstracciones están correctamente definidas",
    "Comprobar inyección de dependencias (DIP)",
    "Validar que interfaces son específicas (ISP)",
    "Verificar que herencia cumple LSP",
    "Analizar métricas de complejidad y tamaño",
    "Verificar que no hay code smells conocidos",
    "Comprobar que el código es testable (mocks posibles)",
    "Validar que cumple con principios de clean code"
  ]
}