{
  "name": "Estándar Serenity Screenplay - WEB UI (Alineado con Robots Rimac)",
  "version": "1.4.0",
  "versionNote": "Updated with ByteBuddy requirements, Actor Management patterns, Serenity 4.x migration, and mandatory validations aligned with API standard",
  "purpose": "Definir los estándares de automatización web usando Serenity BDD + Screenplay + Selenium WebDriver según las prácticas establecidas en los proyectos Rimac (rimac-auto-web, rimac-auto-mobile)",
  "framework": "Serenity BDD",
  "pattern": "Screenplay",
  "scope": "WEB UI",
  "requestTypes": {
    "description": "Tipos de solicitudes soportadas por el MCP - No todo es Historia de Usuario",
    "types": {
      "INIT": {
        "name": "Inicialización",
        "description": "Crear estructura base del proyecto, sin páginas ni lógica funcional",
        "requires": [
          "framework",
          "pattern",
          "scope",
          "basePackage"
        ],
        "generates": [
          "projectStructure",
          "mainRunner",
          "serenityProperties"
        ],
        "notRequires": [
          "pages",
          "validaciones",
          "ui",
          "tasks"
        ],
        "rules": {
          "generateStructureOnly": true,
          "noPages": true,
          "noValidaciones": true,
          "noUI": true,
          "noTasks": true
        }
      },
      "WEB_HU": {
        "name": "Historia de Usuario WEB",
        "description": "Historia de usuario completa con páginas, locators, tasks, interactions y validaciones",
        "requires": [
          "id",
          "nombre",
          "url",
          "paginas",
          "selectores",
          "acciones",
          "validaciones"
        ],
        "generates": [
          "feature",
          "stepDefinitions",
          "task",
          "interaction",
          "question",
          "pageObject",
          "locators"
        ],
        "notRequires": [],
        "rules": {
          "generateAll": true,
          "validateBusiness": true
        }
      },
      "FEATURE": {
        "name": "Feature",
        "description": "Agregar nueva funcionalidad sin necesidad de una HU completa. Puede ser una página nueva, un task nuevo, o una interaction nueva.",
        "requires": [
          "descripción clara de la funcionalidad",
          "tipo de componente (page/task/interaction/question)"
        ],
        "generates": [
          "Componentes específicos solicitados"
        ],
        "notRequires": [
          "feature completo",
          "stepDefinitions si no son necesarios"
        ],
        "rules": {
          "generateOnlyRequested": true,
          "validateBusiness": false
        }
      },
      "REFACTOR": {
        "name": "Refactor",
        "description": "Mejora de código existente sin cambiar funcionalidad. Puede incluir renombrado, reorganización, mejora de patrones.",
        "requires": [
          "descripción del refactor",
          "archivos afectados"
        ],
        "generates": [
          "Código mejorado sin cambios funcionales"
        ],
        "notRequires": [
          "nuevas funcionalidades",
          "nuevos tests"
        ],
        "rules": {
          "noFunctionalChanges": true,
          "maintainTests": true,
          "improveCodeQuality": true
        }
      }
    }
  },
  "principles": {
    "screenplayFirst": {
      "enabled": true,
      "description": "Screenplay first - NO usar @Steps, NO lógica en step definitions",
      "forbidden": [
        "@Steps annotation",
        "Lógica en step definitions"
      ],
      "required": [
        "Toda acción debe ser un Task, Interaction o Question"
      ]
    },
    "separationOfResponsibilities": {
      "enabled": true,
      "layers": {
        "feature": {
          "responsibility": "Lenguaje de negocio",
          "format": "Gherkin"
        },
        "stepDefinitions": {
          "responsibility": "Orquestación mínima",
          "maxLines": 3,
          "forbidden": [
            "Lógica",
            "Aserciones técnicas"
          ]
        },
        "tasks": {
          "responsibility": "Acciones sobre la API",
          "language": "Lenguaje de negocio",
          "forbidden": [
            "HTTP directo"
          ]
        },
        "interactions": {
          "responsibility": "Acciones técnicas (HTTP)",
          "allowed": [
            "HTTP calls"
          ],
          "forbidden": [
            "Aserciones"
          ]
        },
        "questions": {
          "responsibility": "Validaciones",
          "mustReturn": "Boolean o valor"
        },
        "models": {
          "responsibility": "Request / Response",
          "dataOnly": true,
          "forbidden": [
            "Lógica"
          ]
        },
        "builders": {
          "responsibility": "Construcción de requests",
          "noSendLogic": true
        }
      }
    }
  },
  "byteBuddyRequirements": {
    "description": "ByteBuddy es usado por Serenity para instrumentar clases (Tasks, Interactions, PageObjects). Estos requisitos son CRÍTICOS para que funcione la instrumentación.",
    "required": {
      "publicConstructors": {
        "description": "TODAS las clases de UI, Tasks, Interactions y Questions DEBEN tener constructores públicos",
        "reason": "ByteBuddy necesita poder instanciar las clases para instrumentarlas",
        "severity": "CRITICAL",
        "examples": {
          "correct": "public class DiligenciarFormulario implements Task {\n    private final String nombre;\n    \n    public DiligenciarFormulario(String nombre) {\n        this.nombre = nombre;\n    }\n}",
          "incorrect": "public class DiligenciarFormulario implements Task {\n    private final String nombre;\n    \n    private DiligenciarFormulario(String nombre) { // ❌ PRIVATE\n        this.nombre = nombre;\n    }\n}"
        }
      },
      "nonFinalClasses": {
        "description": "Las clases NO deben ser final",
        "reason": "ByteBuddy necesita extender las clases para instrumentarlas",
        "severity": "CRITICAL",
        "examples": {
          "correct": "public class ClickearBoton implements Interaction { }",
          "incorrect": "public final class ClickearBoton implements Interaction { } // ❌ FINAL"
        }
      }
    },
    "instantiationPatterns": {
      "tasks": {
        "correct": "Tasks.instrumented(MiTask.class, param1, param2)",
        "incorrect": "new MiTask(param1, param2)",
        "description": "NUNCA usar 'new' para Tasks - SIEMPRE usar Tasks.instrumented()",
        "reason": "Tasks.instrumented() crea un proxy instrumentado que registra acciones en el reporte",
        "severity": "CRITICAL"
      },
      "interactions": {
        "correct": "Interaction.where(\"{actor} clicks button\", actor -> actor.attemptsTo(Click.on(target)))",
        "alternativeCorrect": "public static Interaction clickOn(Target target) { return Tasks.instrumented(ClickOn.class, target); }",
        "incorrect": "new ClickOn(target)",
        "description": "NUNCA usar 'new' para Interactions - usar Interaction.where() o Tasks.instrumented()",
        "reason": "Interactions también se instrumentan para el reporte",
        "severity": "CRITICAL"
      },
      "questions": {
        "correct": "new VerificarElemento(target)",
        "description": "Questions SIEMPRE usan 'new' directamente",
        "reason": "Questions no se instrumentan de la misma manera, usan 'new' directamente",
        "severity": "MEDIUM",
        "note": "A diferencia de Tasks/Interactions, Questions SÍ usan 'new' en sus factory methods"
      },
      "pageObjects": {
        "correct": "PageObject classes extended automatically by Serenity",
        "description": "PageObjects (UI classes) son instrumentados automáticamente por Serenity cuando extends PageObject",
        "requirement": "DEBE tener constructor público",
        "severity": "CRITICAL"
      }
    },
    "factoryMethods": {
      "description": "Factory methods para encapsular la creación de instancias",
      "tasks": {
        "pattern": "public static {TaskName} {factoryMethod}({params}) { return Tasks.instrumented({TaskName}.class, {params}); }",
        "examples": [
          "public static DiligenciarFormulario con(String nombre) { return Tasks.instrumented(DiligenciarFormulario.class, nombre); }",
          "public static AbrirPagina en(PageObject page) { return Tasks.instrumented(AbrirPagina.class, page); }"
        ]
      },
      "interactions": {
        "pattern": "public static Interaction {factoryMethod}({params}) { return Tasks.instrumented({InteractionName}.class, {params}); }",
        "examples": [
          "public static Interaction clickOn(Target target) { return Tasks.instrumented(ClickOn.class, target); }",
          "public static Interaction enterValue(Target target, String value) { return Tasks.instrumented(EnterValue.class, target, value); }"
        ]
      },
      "questions": {
        "pattern": "public static {QuestionName} as({params}) { return new {QuestionName}({params}); }",
        "examples": [
          "public static VerificarElemento as(Target target) { return new VerificarElemento(target); }",
          "public static VerificarTexto del(Target target) { return new VerificarTexto(target); }"
        ],
        "note": "Questions usan 'new' directamente en el factory method"
      }
    },
    "commonErrors": {
      "privateConstructor": {
        "error": "Cannot instantiate class - constructor is not accessible",
        "solution": "Cambiar constructor de private a public"
      },
      "finalClass": {
        "error": "Cannot subclass final class",
        "solution": "Remover 'final' de la declaración de la clase"
      },
      "usingNewForTasks": {
        "error": "Task no aparece en reporte Serenity",
        "solution": "Usar Tasks.instrumented() en lugar de 'new'"
      },
      "usingNewForInteractions": {
        "error": "Interaction no aparece en reporte Serenity",
        "solution": "Usar Tasks.instrumented() o Interaction.where() en lugar de 'new'"
      }
    }
  },
  "actorManagement": {
    "description": "Gestión correcta de actores en Serenity Screenplay usando OnStage",
    "mandatory": {
      "separateHooksClass": {
        "description": "OBLIGATORIO: Crear una clase separada Hooks.java para @Before y @After",
        "severity": "CRITICAL",
        "reason": "Los hooks de inicialización (@Before) y limpieza (@After) DEBEN estar en una clase separada, NO en StepDefinitions",
        "location": "src/test/java/{package}/stepdefinitions/Hooks.java"
      }
    },
    "hooksTemplate": {
      "description": "Template para la clase Hooks con OnStage",
      "code": "package rimac.auto.web.stepdefinitions;\n\nimport io.cucumber.java.Before;\nimport io.cucumber.java.After;\nimport net.serenitybdd.screenplay.actors.OnStage;\nimport net.serenitybdd.screenplay.actors.Cast;\n\npublic class Hooks {\n\n    @Before\n    public void setTheStage() {\n        OnStage.setTheStage(new Cast());\n    }\n\n    @After\n    public void drawTheCurtain() {\n        OnStage.drawTheCurtain();\n    }\n}",
      "required": [
        "OnStage.setTheStage(new Cast()) en @Before",
        "OnStage.drawTheCurtain() en @After"
      ]
    },
    "stepDefinitionsTemplate": {
      "description": "Template para StepDefinitions usando actores",
      "code": "package rimac.auto.web.stepdefinitions;\n\nimport io.cucumber.java.en.*;\nimport net.serenitybdd.screenplay.actors.OnStage;\nimport static net.serenitybdd.screenplay.actors.OnStage.theActorCalled;\nimport static net.serenitybdd.screenplay.actors.OnStage.theActorInTheSpotlight;\n\npublic class LoginStepDefinitions {\n\n    @Given(\"{string} abre la página de login\")\n    public void abrePaginaLogin(String actor) {\n        theActorCalled(actor).attemptsTo(\n            AbrirPaginaLogin.go()\n        );\n    }\n\n    @When(\"ingresa sus credenciales\")\n    public void ingresaCredenciales() {\n        theActorInTheSpotlight().attemptsTo(\n            IngresarCredenciales.con(\"usuario\", \"password\")\n        );\n    }\n\n    @Then(\"debe ver el dashboard\")\n    public void debeVerDashboard() {\n        theActorInTheSpotlight().should(\n            seeThat(\"El dashboard debe estar visible\", DashboardVisibility.check(), equalTo(true))\n        );\n    }\n}",
      "patterns": {
        "firstStep": "theActorCalled(actor) - usado en el primer step para crear/obtener actor",
        "subsequentSteps": "theActorInTheSpotlight() - usado en steps siguientes para obtener el actor activo"
      }
    },
    "forbiddenPatterns": {
      "actorNamed": {
        "pattern": "Actor.named(\"nombre\")",
        "severity": "CRITICAL",
        "reason": "NO usar Actor.named() - usar theActorCalled() de OnStage",
        "correct": "theActorCalled(\"nombre\")"
      },
      "beforeInStepDefinitions": {
        "pattern": "@Before en StepDefinitions",
        "severity": "CRITICAL",
        "reason": "NUNCA poner @Before/@After en StepDefinitions - crear clase Hooks separada",
        "correct": "Clase Hooks.java separada con @Before/@After"
      },
      "manualCastManagement": {
        "pattern": "Cast cast = new Cast(); Actor actor = cast.actorNamed(\"nombre\");",
        "severity": "HIGH",
        "reason": "NO gestionar Cast manualmente - usar OnStage",
        "correct": "OnStage.setTheStage(new Cast()) en @Before, theActorCalled() en steps"
      }
    },
    "correctPatterns": {
      "initialization": {
        "where": "Hooks.java - @Before",
        "code": "OnStage.setTheStage(new Cast());"
      },
      "cleanup": {
        "where": "Hooks.java - @After",
        "code": "OnStage.drawTheCurtain();"
      },
      "firstInteraction": {
        "where": "StepDefinitions - primer step del escenario",
        "code": "theActorCalled(\"Juan\").attemptsTo(AbrirPagina.go());"
      },
      "subsequentInteractions": {
        "where": "StepDefinitions - steps siguientes",
        "code": "theActorInTheSpotlight().attemptsTo(Clickear.en(BTN_LOGIN));"
      }
    },
    "criticalRules": {
      "rule1": "NUNCA poner @Before/@After en StepDefinitions - SIEMPRE en clase Hooks separada",
      "rule2": "SIEMPRE usar theActorCalled() en el primer step de un escenario",
      "rule3": "SIEMPRE usar theActorInTheSpotlight() en los steps siguientes",
      "rule4": "NUNCA usar Actor.named() - usar theActorCalled()",
      "rule5": "SIEMPRE llamar OnStage.setTheStage() en @Before del Hooks",
      "rule6": "SIEMPRE llamar OnStage.drawTheCurtain() en @After del Hooks"
    }
  },
  "serenityBdd4Migration": {
    "description": "Cambios necesarios para Serenity BDD 4.x (aplica tanto a proyectos WEB como API)",
    "runnerClass": {
      "deprecated": {
        "class": "CucumberSerenityRunner",
        "import": "import net.serenitybdd.cucumber.CucumberSerenityRunner;"
      },
      "current": {
        "class": "CucumberWithSerenity",
        "import": "import io.cucumber.junit.CucumberWithSerenity;"
      },
      "severity": "HIGH",
      "description": "CucumberSerenityRunner está deprecated en Serenity 4.x - usar CucumberWithSerenity"
    },
    "runnerTemplate": {
      "code": "package rimac.auto.web;\n\nimport io.cucumber.junit.CucumberOptions;\nimport io.cucumber.junit.CucumberWithSerenity;\nimport org.junit.runner.RunWith;\n\n@RunWith(CucumberWithSerenity.class)\n@CucumberOptions(\n    features = \"src/test/resources/features\",\n    glue = \"rimac.auto.web.stepdefinitions\",\n    plugin = {\"pretty\", \"json:target/cucumber-reports/cucumber.json\"},\n    snippets = io.cucumber.junit.CucumberOptions.SnippetType.CAMELCASE\n)\npublic class RunnerTags { }",
      "requiredImports": [
        "io.cucumber.junit.CucumberOptions",
        "io.cucumber.junit.CucumberWithSerenity",
        "org.junit.runner.RunWith"
      ]
    }
  },
  "serenityWebChanges": {
    "description": "Cambios específicos de Serenity Web para la versión 4.x",
    "stablePatterns": {
      "targetLocators": {
        "description": "Los Target locators permanecen estables en Serenity 4.x",
        "patterns": [
          "Target.the(\"description\").locatedBy(\"selector\")",
          "Target.the(\"description\").located(By.xpath(\"xpath\"))",
          "Target.the(\"description\").located(By.cssSelector(\"css\"))"
        ],
        "note": "No hay cambios en la forma de definir Target locators"
      },
      "webInteractions": {
        "description": "Las interacciones web básicas permanecen estables",
        "interactions": [
          "Click.on(target)",
          "Enter.theValue(value).into(target)",
          "Clear.field(target)",
          "SelectFromOptions.byVisibleText(text).from(target)",
          "Open.browserOn().the(pageObject)"
        ],
        "note": "No hay cambios en las interacciones web estándar de Serenity"
      },
      "webQuestions": {
        "description": "Las questions web permanecen estables",
        "questions": [
          "Text.of(target)",
          "Visibility.of(target)",
          "Value.of(target)",
          "Attribute.of(target).named(attributeName)"
        ],
        "note": "No hay cambios en las questions web estándar de Serenity"
      }
    },
    "pageObjectPattern": {
      "description": "PageObjects siguen usando el mismo patrón en Serenity 4.x",
      "template": "public class UiLoginPage extends PageObject {\n    public static final Target TXT_USERNAME = Target.the(\"campo username\").locatedBy(\"#username\");\n    public static final Target BTN_LOGIN = Target.the(\"botón login\").locatedBy(\"//button[@type='submit']\");\n}",
      "note": "El patrón PageObject permanece sin cambios en Serenity 4.x"
    }
  },
  "mandatoryValidations": {
    "description": "Validaciones obligatorias que DEBEN incluirse en cada escenario",
    "minimumRequired": {
      "elementValidation": {
        "description": "Validar visibilidad o presencia de elementos clave",
        "severity": "HIGH",
        "examples": [
          "actor.should(seeThat(\"El botón debe estar visible\", Visibility.of(BTN_LOGIN), equalTo(true)))",
          "actor.should(seeThat(\"El mensaje debe estar presente\", Text.of(LBL_MESSAGE), containsString(\"Bienvenido\")))"
        ]
      },
      "businessValidation": {
        "description": "Al menos UNA validación de negocio por escenario",
        "severity": "CRITICAL",
        "examples": [
          "actor.should(seeThat(\"El usuario debe ver el dashboard\", DashboardVisibility.check(), equalTo(true)))",
          "actor.should(seeThat(\"El formulario debe procesarse correctamente\", FormSubmissionStatus.check(), equalTo(\"SUCCESS\")))"
        ]
      },
      "errorValidation": {
        "description": "Validar mensajes de error cuando aplique (escenarios negativos)",
        "severity": "HIGH",
        "examples": [
          "actor.should(seeThat(\"El mensaje de error debe mostrarse\", Text.of(LBL_ERROR), equalTo(\"Usuario o contraseña incorrectos\")))",
          "actor.should(seeThat(\"El campo debe marcar error de validación\", Visibility.of(LBL_FIELD_ERROR), equalTo(true)))"
        ]
      }
    },
    "validationPattern": {
      "correct": "actor.should(seeThat(\"DESCRIPCIÓN\", question, matcher))",
      "incorrect": "actor.should(seeThat(question, matcher))",
      "description": "SIEMPRE usar seeThat() con descripción como PRIMER parámetro",
      "severity": "HIGH",
      "reason": "La descripción mejora los reportes y ayuda con la inferencia de tipos en el compilador",
      "examples": {
        "correct": [
          "actor.should(seeThat(\"El elemento debe estar visible\", ElementVisibility.of(target), equalTo(true)))",
          "actor.should(seeThat(\"El texto debe contener el nombre\", Text.of(LBL_NAME), containsString(\"Juan\")))",
          "actor.should(seeThat(\"La página debe cargar correctamente\", PageLoadStatus.check(), equalTo(\"LOADED\")))"
        ],
        "incorrect": [
          "actor.should(seeThat(ElementVisibility.of(target), equalTo(true)))",
          "actor.should(seeThat(Text.of(LBL_NAME), containsString(\"Juan\")))"
        ]
      }
    },
    "webSpecificValidations": {
      "visibility": "Visibility.of(target) - validar que elementos estén visibles",
      "text": "Text.of(target) - validar texto de elementos",
      "value": "Value.of(target) - validar valores de campos",
      "attribute": "Attribute.of(target).named(name) - validar atributos HTML",
      "customQuestions": "Questions personalizadas que implementen Question<T>"
    }
  },
  "namingConventions": {
    "userinterfaces": {
      "folderName": "userInterfaces",
      "description": "Carpeta para UI classes según prácticas Rimac",
      "note": "NOTA: En proyectos Rimac se usa 'userInterfaces' con mayúscula en 'I'. Esta es la práctica establecida."
    },
    "uiClassPrefix": {
      "pattern": "Ui{PageName}",
      "description": "Prefijo para clases UI según prácticas Rimac",
      "note": "NOTA: En proyectos Rimac se usa 'Ui' con minúscula. Esta es la práctica establecida.",
      "alternativePattern": "UI{PageName}",
      "alternativeNote": "Opcional: UI con ambas mayúsculas. Ambos patrones son aceptados."
    },
    "questionFactoryMethods": {
      "primary": ".as()",
      "description": "Factory method más usado en proyectos Rimac",
      "examples": [
        "VerificarElemento.as(target)",
        "VerificarLogin.as()"
      ],
      "alternatives": [
        ".en(target)",
        ".del(target)",
        ".de(target)"
      ],
      "note": "NOTA: Se prefiere .as() por ser el patrón más usado en los proyectos. Los métodos .en(), .del() y .de() también son válidos."
    },
    "targetLocators": {
      "preferred": ".locatedBy()",
      "description": "Método recomendado para locators Target",
      "examples": [
        "Target.the(\"descripción\").locatedBy(\"selector\")"
      ],
      "alternatives": [
        ".located(By.xpath(\"selector\"))",
        ".located(By.cssSelector(\"selector\"))",
        ".located(By.id(\"selector\"))"
      ],
      "note": "NOTA: En proyectos Rimac se usa un enfoque mixto. Se prefiere .locatedBy() pero el uso de .located(By.*) también es aceptado."
    }
  },
  "standards": {
    "dependencies": {
      "serenity": {
        "version": "4.3.4",
        "description": "Versión de Serenity BDD usada en rimac-auto-web",
        "note": "Versión estable probada en producción."
      },
      "serenity_cucumber": "4.3.4",
      "selenium": {
        "java": "4.35.0",
        "description": "Versión de Selenium Java usada en rimac-auto-web",
        "devtools_v144": "4.40.0",
        "chrome_driver": "4.35.0",
        "note": "Versión estable probada en producción."
      },
      "junit": {
        "version": "4.13.2",
        "description": "Versión de JUnit usada en proyectos Rimac"
      },
      "assertj": {
        "version": "3.27.4",
        "description": "Versión de AssertJ usada en proyectos Rimac"
      },
      "slf4j": {
        "version": "2.0.9",
        "description": "Versión de SLF4J usada en rimac-auto-web"
      },
      "aspectj": {
        "version": "1.9.21",
        "description": "Versión de AspectJ usada en proyectos Rimac"
      },
      "allure": {
        "version": "2.32.0",
        "description": "Versión de Allure usada para reportes"
      }
    },
    "java": {
      "compiler": {
        "source": "21",
        "target": "21",
        "description": "Versión de Java usada en proyectos Rimac"
      }
    },
    "dependencies_mobile": {
      "serenity": {
        "version": "4.3.4",
        "description": "Versión de Serenity BDD recomendada para proyectos mobile",
        "note": "Versión estable actualizada a 4.3.4"
      },
      "selenium": {
        "java": "4.33.0",
        "description": "Versión de Selenium Java usada en rimac-auto-mobile"
      },
      "appium": {
        "java_client": "9.2.2",
        "description": "Versión de Appium Java Client usada en rimac-auto-mobile"
      },
      "junit": {
        "version": "4.13.2",
        "description": "Versión de JUnit usada en proyectos Rimac"
      },
      "assertj": {
        "version": "3.27.4",
        "description": "Versión de AssertJ usada en proyectos Rimac"
      },
      "slf4j": {
        "version": "2.0.13",
        "description": "Versión de SLF4J usada en rimac-auto-mobile"
      },
      "aspectj": {
        "version": "1.9.21",
        "description": "Versión de AspectJ usada en proyectos Rimac"
      },
      "logback": {
        "version": "1.5.13",
        "description": "Versión de Logback alternativa a SLF4J usada en rimac-auto-mobile"
      }
    }
  },
  "structure": {
    "packages": {
      "mainCode": {
        "name": "rimac.auto.web",
        "pattern": "rimac.auto.web",
        "description": "Paquete para código principal (Tasks, Questions, Interactions)",
        "folder": "src/main/java/rimac/auto/web/"
      },
      "testCode": {
        "name": "rimac.auto.web.stepdefinitions",
        "pattern": "rimac.auto.web.stepdefinitions",
        "description": "Paquete para StepDefinitions",
        "folder": "src/test/java/rimac/auto/web/stepdefinitions/"
      }
    },
    "folders": {
      "userInterfaces": {
        "name": "userInterfaces",
        "pattern": "src/main/java/rimac/auto/web/userInterfaces/",
        "description": "Carpeta para UI classes con Target locators",
        "note": "NOTA: Carpeta se llama 'userInterfaces' con 'I' mayúscula según prácticas Rimac."
      },
      "tasks": {
        "name": "tasks",
        "pattern": "src/main/java/rimac/auto/web/tasks/",
        "description": "Tasks de negocio de alto nivel"
      },
      "interactions": {
        "name": "interactions",
        "pattern": "src/main/java/rimac/auto/web/interactions/",
        "description": "Interactions técnicas reutilizables"
      },
      "questions": {
        "name": "questions",
        "pattern": "src/main/java/rimac/auto/web/questions/",
        "description": "Questions para validaciones"
      },
      "models": {
        "name": "models",
        "pattern": "src/main/java/rimac/auto/web/models/",
        "description": "Carpeta para modelos de datos que manejan DataTables",
        "note": "NOTA: Los modelos se usan para convertir datos de tablas en features a objetos Java"
      }
    }
  },
  "components": {
    "userInterfaces": {
      "className": {
        "pattern": "Ui{PageName}",
        "description": "Nombres de clases UI según prácticas Rimac",
        "examples": [
          "UiSoatDigital",
          "UiBBVA",
          "UiBBVAAgente",
          "UiSoatBanbif",
          "UiGildemeister",
          "UiGerencia",
          "UiSegurosViajes",
          "UIAlerts",
          "TransversalUI",
          "UiPagina"
        ],
        "alternatives": [
          "UISoatDigital",
          "UIBBVA",
          "UIBBVAAgente",
          "UISoatBanbif",
          "UIGildemeister",
          "UIGerencia",
          "UISegurosViajes",
          "UIAlerts",
          "UITransversalUI"
        ],
        "note": "NOTA: Ambos patrones (Ui* y UI*) son aceptados. Se prefiere Ui* según prácticas Rimac pero UI* con mayúsculas también es válido."
      },
      "extends": {
        "value": "PageObject",
        "description": "Todas las clases UI deben extender PageObject",
        "mandatory": true,
        "reason": "Necesario para usar @DefaultUrl y para la instrumentación de Serenity BDD",
        "criticality": "NO NEGOCIABLE - Es requisito obligatorio para usar Open.browserOn() en Tasks"
      },
      "annotations": {
        "defaultUrl": {
          "name": "@DefaultUrl",
          "description": "Anotación para URL base de la página",
          "mandatory": true,
          "usage": "@DefaultUrl(\"https://www.example.com/\")",
          "note": "OBLIGATORIO: Siempre se debe usar @DefaultUrl en la clase UI principal que contiene la URL del sitio web. Esto permite usar Open.browserOn(uiPage) en las Tasks.",
          "criticality": "NO NEGOCIABLE - Open.browserOn() requiere que la clase UI tenga @DefaultUrl"
        }
      },
      "imports": {
        "description": "Imports obligatorios para clases UI",
        "mandatory": [
          "net.serenitybdd.annotations.DefaultUrl",
          "net.serenitybdd.core.pages.PageObject",
          "net.serenitybdd.screenplay.targets.Target",
          "org.openqa.selenium.By"
        ],
        "note": "Estos imports son OBLIGATORIOS para la estructura correcta de las clases UI"
      },
      "structure": {
        "description": "Estructura obligatoria de las clases UI",
        "template": "import net.serenitybdd.annotations.DefaultUrl;\nimport net.serenitybdd.core.pages.PageObject;\nimport net.serenitybdd.screenplay.targets.Target;\nimport org.openqa.selenium.By;\n\n@DefaultUrl(\"https://www.ejemplo.com/\")\npublic class UiPagina extends PageObject {\n\n    // Elementos de la pagina\n    public static final Target BTN_INCREMENTAR = Target.the(\"Boton incrementar\").located(By.xpath(\"//button[@id='ejemplo']\"));\n    \n}",
        "elements": [
          {
            "name": "Annotation",
            "value": "@DefaultUrl",
            "mandatory": true
          },
          {
            "name": "Class declaration",
            "value": "public class Ui{PageName} extends PageObject",
            "mandatory": true
          },
          {
            "name": "Target elements",
            "value": "public static final Target {PREFIX}_{NAME}",
            "mandatory": true
          }
        ]
      },
      "locators": {
        "prefixes": [
          "TXT_",
          "BTN_",
          "LBL_",
          "DDL_",
          "CHK_",
          "RDB_",
          "LNK_",
          "IMG_",
          "TBL_"
        ],
        "description": "Prefijos para constantes de Target",
        "pattern": "public static final Target {PREFIX}_{ELEMENT_NAME} = Target.the(\"{description}\").located(By.{locator}(...));",
        "note": "En proyectos Rimac se usan todos estos prefijos"
      },
      "strategies": {
        "preferred": ".located(By.xpath(...))",
        "description": "Método preferido para Target usando By locators",
        "alternatives": [
          ".located(By.xpath(...))",
          ".located(By.cssSelector(...))",
          ".located(By.id(...))",
          ".locatedBy(\"xpath-string\")"
        ],
        "note": "PREFERENCIA: Se debe usar .located(By.*) para mayor claridad y consistencia. También se acepta .locatedBy() pero se prefiere By.*"
      }
    },
    "tasks": {
      "implements": {
        "value": "Task",
        "description": "Todas las clases Task deben implementar Task"
      },
      "factoryMethod": {
        "pattern": "Tasks.instrumented()",
        "method": "urlWeb",
        "alternativeMethods": [
          "llamado",
          "con",
          "ir",
          "go"
        ],
        "description": "Factory method para Tasks - el nombre puede variar según el contexto",
        "examples": [
          "AbrirPagina.urlWeb()",
          "OpenPagePublicWeb.ir(new UiSoatDigital())",
          "DiligenciarDatosPlan.go(plan, medioPago, false)"
        ],
        "note": "NOTA: El método factory puede tener diferentes nombres según el contexto: 'urlWeb', 'llamado', 'con', 'ir', 'go', etc. Todos son aceptados."
      },
      "actorActions": "actor.attemptsTo()",
      "description": "Todos los tasks deben usar actor.attemptsTo()",
      "openBrowserPattern": {
        "description": "Patrón para abrir navegador con URL desde clase UI",
        "mandatory": true,
        "structure": {
          "privateField": {
            "description": "Campo privado para la clase UI",
            "pattern": "private UiPagina uiPagina;",
            "mandatory": true,
            "note": "Este campo NO se inicializa en el constructor, Serenity lo inyecta automáticamente"
          },
          "performAs": {
            "description": "Método performAs que usa Open.browserOn()",
            "pattern": "actor.attemptsTo(Open.browserOn(uiPagina));",
            "mandatory": true,
            "note": "Open.browserOn(uiPagina) abre el navegador en la URL especificada en @DefaultUrl de la clase UI"
          },
          "factoryMethod": {
            "description": "Factory method estático",
            "pattern": "public static AbrirPagina urlWeb() { return Tasks.instrumented(AbrirPagina.class); }",
            "mandatory": true
          }
        },
        "template": "package com.sistecredito.web.tasks;\n\nimport com.sistecredito.web.userinterfaces.UiPagina;\nimport net.serenitybdd.screenplay.Actor;\nimport net.serenitybdd.screenplay.Task;\nimport net.serenitybdd.screenplay.Tasks;\nimport net.serenitybdd.screenplay.actions.Click;\nimport net.serenitybdd.screenplay.actions.Open;\nimport net.serenitybdd.screenplay.waits.WaitUntil;\n\nimport static com.sistecredito.web.userinterfaces.UiMenu.BTN_CERRAR_MODAL;\nimport static net.serenitybdd.screenplay.matchers.WebElementStateMatchers.isClickable;\n\npublic class AbrirPagina implements Task {\n    private UiPagina uiPagina;\n\n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n                Open.browserOn(uiPagina),\n\n                // Puede tener acciones como en este ejemplo de esperar y cerrar un modal\n                WaitUntil.the(BTN_CERRAR_MODAL, isClickable()).forNoMoreThan(120).seconds(),\n                Click.on(BTN_CERRAR_MODAL)\n        );\n    }\n\n    public static AbrirPagina urlWeb() {\n        return Tasks.instrumented(AbrirPagina.class);\n    }\n}",
        "imports": {
          "description": "Imports necesarios para Tasks que abren páginas",
          "mandatory": [
            "net.serenitybdd.screenplay.Actor",
            "net.serenitybdd.screenplay.Task",
            "net.serenitybdd.screenplay.Tasks",
            "net.serenitybdd.screenplay.actions.Open",
            "{package}.userinterfaces.UiPagina"
          ]
        },
        "usage": {
          "description": "Cómo usar el Task en StepDefinitions",
          "example": "actor.attemptsTo(AbrirPagina.urlWeb());",
          "note": "El actor ejecuta el task que abre el navegador en la URL definida en @DefaultUrl de UiPagina"
        },
        "requirements": {
          "description": "Requisitos NO NEGOCIABLES para usar Open.browserOn()",
          "mandatory": true,
          "rules": [
            {
              "rule": "Uso de campo privado",
              "description": "Open.browserOn() DEBE usarse con un campo privado de la clase UI",
              "example": "private UILoginPage uiLoginPage; ... Open.browserOn(uiLoginPage)",
              "reason": "Permite que Serenity BDD inyecte automáticamente la instancia y use @DefaultUrl"
            },
            {
              "rule": "UI extiende PageObject",
              "description": "La clase UI DEBE extender PageObject",
              "example": "public class UILoginPage extends PageObject { ... }",
              "reason": "Es requisito obligatorio para que @DefaultUrl funcione correctamente"
            },
            {
              "rule": "UI tiene @DefaultUrl",
              "description": "La clase UI DEBE tener la anotación @DefaultUrl con la URL del sitio",
              "example": "@DefaultUrl(\"https://www.saucedemo.com/\")",
              "reason": "Define la URL base que Open.browserOn() utilizará para abrir el navegador"
            }
          ],
          "antipatterns": [
            {
              "pattern": "Open.browserOn().the(page)",
              "reason": "NO usar .the() - usar directamente el campo privado UI"
            },
            {
              "pattern": "Open.browserOn(new UILoginPage())",
              "reason": "NO instanciar manualmente - usar campo privado inyectado por Serenity"
            },
            {
              "pattern": "public UILoginPage uiLoginPage;",
              "reason": "El campo DEBE ser private, no public"
            }
          ]
        }
      }
    },
    "questions": {
      "factoryMethod": {
        "pattern": ".as()",
        "description": "Factory method para Questions según prácticas Rimac",
        "examples": [
          "VerificarElemento.as(LBL_MENSAJE)",
          "VerificarLogin.as()"
        ],
        "alternatives": [
          ".en(target)",
          ".del(target)",
          ".de(target)"
        ],
        "note": "NOTA: Se prefiere .as() según prácticas Rimac pero .en(), .del(), .de() también son válidos."
      },
      "implements": {
        "value": "Question<T>",
        "description": "Todas las clases Question deben implementar Question<T>"
      },
      "returnType": "Boolean o valor",
      "actorValidation": "actor.should(seeThat(\"descripción\", question, matcher))",
      "description": "Usar seeThat() con descripción como PRIMER parámetro para validaciones (mejora reportes y ayuda con inferencia de tipos)",
      "validationExamples": {
        "correct": [
          "actor.should(seeThat(\"El botón debe estar visible\", Visibility.of(BTN_LOGIN), equalTo(true)))",
          "actor.should(seeThat(\"El mensaje debe contener bienvenida\", Text.of(LBL_MESSAGE), containsString(\"Bienvenido\")))",
          "actor.should(seeThat(\"La página debe cargar\", PageLoadStatus.check(), equalTo(true)))"
        ],
        "incorrect": [
          "actor.should(seeThat(Visibility.of(BTN_LOGIN), equalTo(true)))",
          "actor.should(seeThat(Text.of(LBL_MESSAGE), containsString(\"Bienvenido\")))"
        ]
      }
    },
    "stepDefinitions": {
      "maxLines": 3,
      "description": "Máximo de líneas por método según estándar general",
      "note": "En proyectos Rimac hay métodos que exceden este límite. Esto es aceptado en contexto real pero se debe mantener en 3 líneas cuando sea posible."
    },
    "setTheStage": {
      "hooks": {
        "before": "@Before",
        "after": "@After",
        "drawTheCurtain": {
          "required": false,
          "description": "No se requiere drawTheCurtain() en proyectos Rimac",
          "note": "Se maneja el cierre del driver de otras formas en SetTheStage y @AfterAll."
        }
      },
      "actorInitialization": {
        "pattern": "OnStage.theActor(\"{nombre}\")",
        "description": "Inicialización de actores según prácticas Rimac",
        "alternatives": [
          "theActorCalled(\"{nombre}\")"
        ],
        "note": "NOTA: En proyectos Rimac se usa OnStage.theActor(). También es válido el uso de theActorCalled()."
      }
    },
    "interactions": {
      "implements": {
        "value": "Interaction",
        "description": "Todas las clases Interaction deben implementar Interaction"
      },
      "actorActions": "actor.attemptsTo()",
      "description": "Todos los interactions deben usar actor.attemptsTo()"
    },
    "models": {
      "description": "Componente para manejo de datos de prueba desde DataTables en archivos .feature",
      "mandatory": true,
      "purpose": "Los modelos se usan para convertir datos de tablas en archivos .feature a objetos Java usando Jackson",
      "structure": {
        "fields": {
          "description": "Campos privados con getters y setters",
          "pattern": "private String {fieldName};",
          "mandatory": true,
          "note": "Todos los campos deben ser privados y tener métodos getter y setter públicos"
        },
        "gettersSetters": {
          "description": "Métodos getter y setter para cada campo",
          "mandatory": true,
          "pattern": "public String get{FieldName}() { return {fieldName}; }\npublic void set{FieldName}(String {fieldName}) { this.{fieldName} = {fieldName}; }"
        },
        "setDataMethod": {
          "description": "Método estático para convertir DataTable a List de objetos del modelo",
          "mandatory": true,
          "pattern": "public static List<{ModelName}> setData(DataTable dataTable) {\n    List<{ModelName}> dates = new ArrayList<>();\n    List<Map<String, String>> mapInfo = dataTable.asMaps();\n    for (Map<String, String> map : mapInfo) {\n        dates.add(new ObjectMapper().convertValue(map, {ModelName}.class));\n    }\n    return dates;\n}",
          "note": "Este método es OBLIGATORIO para convertir DataTable de Cucumber a objetos Java"
        }
      },
      "imports": {
        "description": "Imports obligatorios para modelos",
        "mandatory": [
          "com.fasterxml.jackson.databind.ObjectMapper",
          "io.cucumber.datatable.DataTable",
          "java.util.ArrayList",
          "java.util.List",
          "java.util.Map"
        ],
        "note": "Estos imports son necesarios para el manejo de DataTables con Jackson"
      },
      "template": "package rimac.auto.web.models;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport io.cucumber.datatable.DataTable;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class AdultoExistenteDos {\n\n    private String tipoDocumenAdultoDosExiste;\n    private String numDocumenAdultoDosExiste;\n    private String tipoDocumenAdultoTresExiste;\n    private String numDocumenAdultoTresExiste;\n    private String tipoDocumenAdultoCuatroExiste;\n    private String numDocumenAdultoCuatroExiste;\n\n    public String getTipoDocumenAdultoDosExiste() {\n        return tipoDocumenAdultoDosExiste;\n    }\n\n    public void setTipoDocumenAdultoDosExiste(String tipoDocumenAdultoDosExiste) {\n        this.tipoDocumenAdultoDosExiste = tipoDocumenAdultoDosExiste;\n    }\n\n    public String getNumDocumenAdultoDosExiste() {\n        return numDocumenAdultoDosExiste;\n    }\n\n    public void setNumDocumenAdultoDosExiste(String numDocumenAdultoDosExiste) {\n        this.numDocumenAdultoDosExiste = numDocumenAdultoDosExiste;\n    }\n\n    public String getTipoDocumenAdultoTresExiste() {\n        return tipoDocumenAdultoTresExiste;\n    }\n\n    public void setTipoDocumenAdultoTresExiste(String tipoDocumenAdultoTresExiste) {\n        this.tipoDocumenAdultoTresExiste = tipoDocumenAdultoTresExiste;\n    }\n\n    public String getNumDocumenAdultoTresExiste() {\n        return numDocumenAdultoTresExiste;\n    }\n\n    public void setNumDocumenAdultoTresExiste(String numDocumenAdultoTresExiste) {\n        this.numDocumenAdultoTresExiste = numDocumenAdultoTresExiste;\n    }\n\n    public String getTipoDocumenAdultoCuatroExiste() {\n        return tipoDocumenAdultoCuatroExiste;\n    }\n\n    public void setTipoDocumenAdultoCuatroExiste(String tipoDocumenAdultoCuatroExiste) {\n        this.tipoDocumenAdultoCuatroExiste = tipoDocumenAdultoCuatroExiste;\n    }\n\n    public String getNumDocumenAdultoCuatroExiste() {\n        return numDocumenAdultoCuatroExiste;\n    }\n\n    public void setNumDocumenAdultoCuatroExiste(String numDocumenAdultoCuatroExiste) {\n        this.numDocumenAdultoCuatroExiste = numDocumenAdultoCuatroExiste;\n    }\n\n    public static List<AdultoExistenteDos> setData(DataTable dataTable) {\n        List<AdultoExistenteDos> dates = new ArrayList<>();\n        List<Map<String, String>> mapInfo = dataTable.asMaps();\n        for (Map<String, String> map : mapInfo) {\n            dates.add(new ObjectMapper().convertValue(map, AdultoExistenteDos.class));\n        }\n        return dates;\n    }\n}",
      "usage": {
        "description": "Cómo usar el modelo en StepDefinitions",
        "example": "List<AdultoExistenteDos> datos = AdultoExistenteDos.setData(dataTable);",
        "note": "El método setData convierte automáticamente la DataTable del feature a una lista de objetos del modelo"
      },
      "featureExample": {
        "description": "Ejemplo de DataTable en archivo .feature",
        "example": "Scenario: Ejemplo con datos\n  When el usuario ingresa los siguientes datos:\n    | tipoDocumenAdultoDosExiste | numDocumenAdultoDosExiste |\n    | DNI                        | 12345678                  |\n    | CE                         | 87654321                  |"
      },
      "location": {
        "folder": "models",
        "pattern": "src/main/java/{basePackage}/models/",
        "description": "Carpeta donde se deben ubicar los modelos"
      }
    }
  },
  "validation": {
    "principles": {
      "screenplayFirst": {
        "enabled": true,
        "description": "Validar Screenplay first - NO usar @Steps, NO lógica en step definitions"
      }
    },
    "components": {
      "tasks": {
        "validatesScreenplay": true,
        "noDirectHttp": true,
        "usesActorAttemptsTo": true,
        "hasPublicConstructor": true
      },
      "interactions": {
        "validatesScreenplay": true,
        "noAssertions": true,
        "usesActorAttemptsTo": true,
        "hasPublicConstructor": true
      },
      "questions": {
        "validatesScreenplay": true,
        "returnsValue": true,
        "noActions": true,
        "hasPublicConstructor": true
      },
      "userInterfaces": {
        "extendsPageObject": true,
        "usesTarget": true,
        "acceptsBothPatterns": true,
        "acceptsMixedStrategies": true
      },
      "stepDefinitions": {
        "maxLines": 3,
        "acceptsExistingPatterns": true,
        "note": "Validar máximo 3 líneas cuando sea posible"
      },
      "setTheStage": {
        "hasBefore": true,
        "hasAfter": true,
        "acceptsInitializationPattern": true
      }
    },
    "nonBlockingViolations": {
      "description": "Prácticas que NO se consideran violations según experiencias Rimac",
      "items": [
        {
          "item": "Carpeta userInterfaces",
          "pattern": "userInterfaces",
          "reason": "Es la práctica establecida en proyectos Rimac y funciona correctamente"
        },
        {
          "item": "Prefijo Ui* en clases UI",
          "pattern": "Ui{PageName}",
          "reason": "Es el patrón establecido en proyectos Rimac y funciona correctamente"
        },
        {
          "item": "Uso de .located(By.*) en locators",
          "pattern": ".located(By.xpath(...))",
          "reason": "Es aceptado en proyectos Rimac. Se prefiere .locatedBy() pero no es un error"
        },
        {
          "item": "Factory method .as() en Questions",
          "pattern": ".as()",
          "reason": "Es el patrón predominante en proyectos Rimac. .en(), .del(), .de() también son válidos"
        },
        {
          "item": "SetTheStage sin drawTheCurtain()",
          "pattern": "No drawTheCurtain() en @After",
          "reason": "Los proyectos Rimac manejan el cierre de driver de otras formas en SetTheStage/@AfterAll"
        },
        {
          "item": "OnStage.theActor() vs theActorCalled()",
          "pattern": "OnStage.theActor(\"nombre\")",
          "reason": "Ambos son válidos según experiencias Rimac"
        },
        {
          "item": "OnStage.theActor() en StepDefinitions",
          "pattern": "OnStage.theActor()",
          "reason": "Es el patrón predominante en proyectos Rimac. También se acepta theActorCalled()"
        },
        {
          "item": "Factory method llamado() en Tasks",
          "pattern": ".llamado()",
          "reason": "Es el patrón usado en proyectos Rimac. 'con()' también es aceptado"
        },
        {
          "item": "StepDefinitions con lógica compleja",
          "pattern": "try-catch, if-else",
          "reason": "En proyectos Rimac se acepta en algunos casos. Se debe mantener simple cuando sea posible pero no bloquea la funcionalidad existente"
        }
      ]
    },
    "blockingViolations": {
      "description": "Prácticas que SÍ se consideran violations y deben corregirse",
      "items": [
        {
          "item": "@Steps annotation",
          "severity": "critical",
          "description": "NO usar @Steps annotation - usar Screenplay",
          "pattern": "@Steps"
        },
        {
          "item": "Lógica en StepDefinitions",
          "severity": "high",
          "description": "StepDefinitions con más de 3 líneas y con lógica compleja",
          "pattern": "try, catch, if, else, for, while"
        },
        {
          "item": "HTTP directo en Tasks",
          "severeity": "high",
          "description": "Usar HTTP directo (Get.resource, Post.to) en Tasks en lugar de Interactions",
          "pattern": "Get.resource, Post.to"
        },
        {
          "item": "Aserciones en Interactions",
          "severity": "high",
          "description": "Interactions no deben tener aserciones (assert, should)",
          "pattern": "assert, should"
        },
        {
          "item": "UI sin Target locators",
          "severity": "high",
          "description": "UI classes deben usar Target locators",
          "pattern": "By.xpath, By.cssSelector, By.id"
        },
        {
          "item": "Modelo sin Jackson",
          "severity": "medium",
          "description": "Models de request/response deben usar Jackson annotations",
          "pattern": "sin @JsonProperty, sin @JsonIgnoreProperties"
        },
        {
          "item": "Constructor sin público",
          "severity": "critical",
          "description": "Constructores deben ser públicos para ByteBuddy",
          "pattern": "private constructor"
        },
        {
          "item": "Factory method sin instrumented()",
          "severity": "critical",
          "description": "Factory methods deben usar Tasks.instrumented()",
          "pattern": "new Task(), new Question()"
        }
      ]
    }
  }
}
