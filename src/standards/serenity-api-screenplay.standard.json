{
  "name": "Estándar Serenity Screenplay - API REST",
  "version": "1.0.0",
  "purpose": "Definir una forma única, consistente y escalable de implementar pruebas de APIs REST usando Serenity BDD + Screenplay",
  "framework": "Serenity BDD",
  "pattern": "Screenplay",
  "scope": "API REST",
  "requestTypes": {
    "description": "Tipos de solicitudes soportadas por el MCP - No todo es Historia de Usuario",
    "types": {
      "INIT": {
        "name": "Inicialización",
        "description": "Crear estructura base del proyecto, sin endpoints ni lógica funcional",
        "requires": [
          "framework",
          "pattern",
          "scope",
          "basePackage"
        ],
        "generates": [
          "projectStructure",
          "mainRunner",
          "serenityProperties"
        ],
        "notRequires": [
          "endpoints",
          "validations",
          "builders",
          "tasks"
        ],
        "rules": {
          "generateStructureOnly": true,
          "noEndpoints": true,
          "noValidations": true,
          "noBuilders": true,
          "noTasks": true
        }
      },
      "API_HU": {
        "name": "Historia de Usuario API",
        "description": "Historia de usuario completa con endpoint, models, tasks, validaciones",
        "requires": [
          "id",
          "nombre",
          "endpoint",
          "metodo",
          "request",
          "response",
          "validaciones"
        ],
        "generates": [
          "feature",
          "stepDefinitions",
          "task",
          "interaction",
          "question",
          "model",
          "builder",
          "endpoint"
        ],
        "notRequires": [],
        "rules": {
          "generateAll": true,
          "validateBusiness": true
        },
        "howToRequest": {
          "description": "Cómo estructurar correctamente la solicitud de una Historia de Usuario completa",
          "requiredInfo": {
            "id": "Identificador de la HU (ej: HU-001)",
            "nombre": "Nombre descriptivo (ej: Visualizar todos los personajes)",
            "baseUrl": "URL base de la API (ej: https://rickandmortyapi.com/api)",
            "endpoint": "Path del endpoint (ej: /character)",
            "metodo": "Método HTTP (GET, POST, PUT, DELETE)",
            "responseStructure": "Estructura del response esperado con tipos de datos",
            "validaciones": "Qué se debe validar (statusCode, campos específicos)",
            "framework": "Mencionar que debe usar Serenity Screenplay correctamente"
          },
          "templateRequest": "Necesito implementar la {id} para {nombre} en la url \"{baseUrl}\" en el endpoint {metodo} {endpoint}.\nEl response debe devolver: {responseStructure}\nDebe validar: {validaciones}\nUtilizando de manera correcta Serenity Screenplay.",
          "exampleComplete": {
            "userRequest": "Necesito implementar la HU-001 para visualizar todos los personajes en la url \"https://rickandmortyapi.com/api\" en el endpoint GET /character.\nEl response debe devolver: info:{count:Integer,pages:Integer,next:String,prev:String}, results:List<Object>\nDebe validar que el statusCode sea 200.\nUtilizando de manera correcta Serenity Screenplay.",
            "parsedInfo": {
              "id": "HU-001",
              "nombre": "Visualizar todos los personajes",
              "baseUrl": "https://rickandmortyapi.com/api",
              "endpoint": "/character",
              "metodo": "GET",
              "responseFields": [
                {
                  "path": "info.count",
                  "type": "Integer",
                  "description": "Total de personajes"
                },
                {
                  "path": "info.pages",
                  "type": "Integer",
                  "description": "Total de páginas"
                },
                {
                  "path": "info.next",
                  "type": "String",
                  "description": "URL siguiente página"
                },
                {
                  "path": "info.prev",
                  "type": "String",
                  "description": "URL página anterior"
                },
                {
                  "path": "results",
                  "type": "List<Object>",
                  "description": "Lista de personajes"
                }
              ],
              "validaciones": [
                {
                  "type": "statusCode",
                  "expectedValue": 200
                },
                {
                  "type": "field",
                  "path": "info",
                  "validation": "not null"
                },
                {
                  "type": "field",
                  "path": "results",
                  "validation": "not null"
                }
              ]
            },
            "artifactsToGenerate": [
              "Feature file (character.feature)",
              "StepDefinitions (CharacterStepDefinitions.java)",
              "Task (GetAllCharacters.java)",
              "Interaction (GetRequest.java)",
              "Questions (ResponseStatusCode.java, ResponseInfoField.java, ResponseResults.java)",
              "Model (CharacterResponse.java con Info y Results)",
              "Endpoint (CharacterEndpoints.java con BASE_URL y GET_ALL)",
              "Builder (CharacterResponseBuilder.java - si se necesita para tests)"
            ]
          },
          "bestPractices": [
            "✅ Especificar SIEMPRE la URL base completa",
            "✅ Indicar el método HTTP antes del endpoint (GET /character)",
            "✅ Describir la estructura del response con tipos de datos",
            "✅ Listar todas las validaciones esperadas",
            "✅ Mencionar 'Serenity Screenplay' para aplicar el estándar correcto",
            "✅ Para objetos anidados usar notación de puntos: info.count, data.user.name",
            "✅ Especificar tipos Java: Integer, String, Boolean, List<Object>, etc."
          ],
          "commonMistakes": [
            "❌ No especificar la URL base (solo poner el endpoint)",
            "❌ No indicar los tipos de datos del response",
            "❌ Decir solo 'validar el response' sin especificar qué",
            "❌ No mencionar el método HTTP",
            "❌ Solicitud ambigua como 'hacer un test de la API'"
          ],
          "withJsonSchema": {
            "description": "Cómo hacer la solicitud cuando tienes el schema del response en un archivo JSON",
            "option1": {
              "name": "Pasar el JSON completo en el prompt",
              "template": "Necesito implementar la {id} para {nombre} en la url \"{baseUrl}\" en el endpoint {metodo} {endpoint}.\n\nEl response debe tener esta estructura:\n```json\n{schema JSON aquí}\n```\n\nDebe validar:\n- {validaciones}\n\nUtilizando de manera correcta Serenity Screenplay.",
              "example": "Necesito implementar la HU-001 para visualizar todos los personajes en la url \"https://rickandmortyapi.com/api\" en el endpoint GET /character.\n\nEl response debe tener esta estructura:\n```json\n{\n  \"info\": {\n    \"count\": 826,\n    \"pages\": 42,\n    \"next\": \"https://rickandmortyapi.com/api/character?page=2\",\n    \"prev\": null\n  },\n  \"results\": [\n    {\n      \"id\": 1,\n      \"name\": \"Rick Sanchez\",\n      \"status\": \"Alive\",\n      \"species\": \"Human\",\n      \"type\": \"\",\n      \"gender\": \"Male\",\n      \"origin\": {\"name\": \"Earth (C-137)\", \"url\": \"https://rickandmortyapi.com/api/location/1\"},\n      \"location\": {\"name\": \"Citadel of Ricks\", \"url\": \"https://rickandmortyapi.com/api/location/3\"},\n      \"image\": \"https://rickandmortyapi.com/api/character/avatar/1.jpeg\",\n      \"episode\": [\"https://rickandmortyapi.com/api/episode/1\",\"https://rickandmortyapi.com/api/episode/2\"],\n      \"url\": \"https://rickandmortyapi.com/api/character/1\",\n      \"created\": \"2017-11-04T18:48:46.250Z\"\n    }\n  ]\n}\n```\n\nDebe validar:\n- statusCode sea 200\n- info no sea null\n- info.count sea mayor a 0\n- results no sea null\n- results contenga al menos 1 elemento\n\nUtilizando de manera correcta Serenity Screenplay.",
              "pros": "El sistema puede inferir automáticamente los tipos de datos",
              "parsing": "El sistema analiza el JSON y determina: String, Integer, Boolean, Object, Array según los valores"
            },
            "option2": {
              "name": "Referenciar archivo JSON externo",
              "template": "Necesito implementar la {id} para {nombre} en la url \"{baseUrl}\" en el endpoint {metodo} {endpoint}.\n\nEl response schema está en el archivo: {rutaArchivo}\n\nDebe validar:\n- {validaciones}\n\nUtilizando de manera correcta Serenity Screenplay.",
              "example": "Necesito implementar la HU-001 para visualizar todos los personajes en la url \"https://rickandmortyapi.com/api\" en el endpoint GET /character.\n\nEl response schema está en el archivo: schemas/character-response.json\n\nDebe validar:\n- statusCode sea 200\n- info no sea null\n- results contenga elementos\n\nUtilizando de manera correcta Serenity Screenplay.",
              "pros": "Más limpio cuando el schema es muy grande",
              "note": "El sistema puede leer el archivo y parsear el schema automáticamente"
            },
            "jsonToJavaMapping": {
              "description": "Mapeo automático de tipos JSON a tipos Java",
              "mappings": {
                "number (entero)": "Integer o Long",
                "number (decimal)": "Double o Float",
                "string": "String",
                "boolean": "Boolean",
                "object": "Object o crear clase POJO",
                "array": "List<T> donde T es el tipo del contenido",
                "null": "Se ignora (usa @JsonIgnoreProperties)"
              },
              "examples": {
                "count: 826": "Integer count",
                "name: \"Rick\"": "String name",
                "alive: true": "Boolean alive",
                "price: 19.99": "Double price",
                "tags: []": "List<String> tags",
                "user: {}": "User user (crear clase User)"
              }
            },
            "validationsFromSchema": {
              "description": "Validaciones comunes que se pueden inferir del schema",
              "automatic": [
                "Campos requeridos (los que aparecen en el schema) → validar not null",
                "Arrays → validar que no esté vacío si se espera contenido",
                "Números → validar tipo correcto (no String)",
                "Booleans → validar true/false según lógica de negocio"
              ],
              "recommended": "Especificar validaciones explícitas aunque el schema las implique"
            }
          },
          "crossReferences": {
            "description": "Referencias a estándares relacionados para consistencia",
            "webStandard": {
              "file": "serenity-web-screenplay.standard.json",
              "version": "1.3.0",
              "sharedSections": [
                "principles.screenplayFirst",
                "namingConventions.language",
                "projectStructure.buildTools",
                "gherkinStandards (similar pero adaptado a Web)"
              ],
              "differences": [
                "API: Enfoque en HTTP methods y JSON",
                "Web: Enfoque en UI interactions y locators",
                "Ambos: Mismo patrón Screenplay y estructura de proyecto"
              ]
            },
            "consistencyRules": [
              "Mismos principios de Screenplay en API y Web",
              "Convenciones de naming consistentes",
              "Estructura de proyecto similar",
              "Mismo approach para Gherkin (modular by default)",
              "Validaciones similares de patrones"
            ]
          }
        }
      },
      "FEATURE": {
        "name": "Feature sin API",
        "description": "Solo archivo .feature sin implementación técnica",
        "requires": [
          "descripcion",
          "escenarios"
        ],
        "generates": [
          "feature"
        ],
        "notRequires": [
          "tasks",
          "interactions",
          "models",
          "endpoints"
        ],
        "rules": {
          "featureOnly": true,
          "noImplementation": true
        }
      },
      "REFACTOR": {
        "name": "Refactorización técnica",
        "description": "Cambio técnico en código existente, sin generar features",
        "requires": [
          "objetivo",
          "modulosAfectados"
        ],
        "generates": [
          "analysis",
          "suggestions"
        ],
        "notRequires": [
          "features",
          "newCode"
        ],
        "rules": {
          "analyzeOnly": true,
          "noGeneration": true,
          "validateStandards": true
        }
      },
      "VALIDATION": {
        "name": "Validación de código",
        "description": "Validar código existente contra estándares",
        "requires": [
          "codigo",
          "tipo"
        ],
        "generates": [
          "validationReport"
        ],
        "notRequires": [
          "generation"
        ],
        "rules": {
          "validateOnly": true,
          "noGeneration": true
        }
      }
    }
  },
  "principles": {
    "screenplayFirst": {
      "enabled": true,
      "description": "Screenplay first - NO usar @Steps, NO lógica en step definitions",
      "forbidden": [
        "@Steps annotation",
        "Lógica en step definitions"
      ],
      "required": [
        "Toda acción debe ser un Task, Interaction o Question"
      ]
    },
    "separationOfResponsibilities": {
      "enabled": true,
      "layers": {
        "feature": {
          "responsibility": "Lenguaje de negocio",
          "format": "Gherkin"
        },
        "stepDefinitions": {
          "responsibility": "Orquestación mínima",
          "maxLines": 3,
          "forbidden": [
            "Lógica",
            "Aserciones técnicas"
          ]
        },
        "tasks": {
          "responsibility": "Acciones sobre la API",
          "language": "Lenguaje de negocio",
          "forbidden": [
            "HTTP directo"
          ]
        },
        "interactions": {
          "responsibility": "Acciones técnicas (HTTP)",
          "allowed": [
            "HTTP calls"
          ],
          "forbidden": [
            "Aserciones"
          ]
        },
        "questions": {
          "responsibility": "Validaciones",
          "mustReturn": "Boolean o valor"
        },
        "models": {
          "responsibility": "Request / Response",
          "dataOnly": true,
          "forbidden": [
            "Lógica"
          ]
        },
        "builders": {
          "responsibility": "Construcción de requests",
          "purpose": "Generar escenarios de prueba"
        }
      }
    }
  },
  "projectStructure": {
    "mandatory": true,
    "buildTools": {
      "supported": [
        "Gradle",
        "Maven"
      ],
      "description": "El proyecto puede usar Gradle o Maven como herramienta de build"
    },
    "basePackage": "com.{company}",
    "example": "com.rimac, com.sistecredito, com.bancolombia",
    "rootStructureGradle": {
      "gradle/": "Configuración de Gradle Wrapper",
      "src/": "Código fuente del proyecto",
      ".gitignore": "Archivos ignorados por Git",
      "README.md": "Documentación del proyecto",
      "build.gradle": "Configuración de build y dependencias",
      "gradlew": "Gradle Wrapper Unix",
      "gradlew.bat": "Gradle Wrapper Windows",
      "settings.gradle": "Configuración del proyecto Gradle"
    },
    "rootStructureMaven": {
      "src/": "Código fuente del proyecto",
      ".gitignore": "Archivos ignorados por Git",
      "README.md": "Documentación del proyecto",
      "pom.xml": "Configuración de build y dependencias Maven",
      ".mvn/": "Maven Wrapper (opcional)",
      "mvnw": "Maven Wrapper Unix (opcional)",
      "mvnw.cmd": "Maven Wrapper Windows (opcional)"
    },
    "sourceStructure": {
      "src/main/java/com/{company}/": {
        "tasks/": {
          "description": "Tareas de negocio de alto nivel",
          "naming": "{Action}{Resource}.java",
          "examples": [
            "CreateUser.java",
            "GetPolicy.java",
            "UpdateCustomer.java"
          ]
        },
        "interactions/": {
          "description": "Acciones técnicas HTTP (Post, Get, Put, Delete, Patch)",
          "naming": "{HttpMethod}Request.java",
          "examples": [
            "PostRequest.java",
            "GetRequest.java",
            "PutRequest.java",
            "DeleteRequest.java"
          ]
        },
        "questions/": {
          "description": "Validaciones que retornan valores",
          "naming": "{What}Question.java o {What}.java",
          "examples": [
            "ResponseStatusCode.java",
            "ResponseBodyField.java"
          ]
        },
        "models/": {
          "description": "POJOs Request/Response DTOs",
          "naming": "{Resource}Request.java, {Resource}Response.java",
          "examples": [
            "CreateUserRequest.java",
            "UserResponse.java"
          ]
        },
        "builders/": {
          "description": "Construcción de datos de prueba",
          "naming": "{Resource}Builder.java",
          "examples": [
            "UserBuilder.java",
            "PolicyBuilder.java"
          ]
        },
        "endpoints/": {
          "description": "URLs de la API",
          "naming": "{Resource}Endpoints.java",
          "examples": [
            "UserEndpoints.java",
            "PolicyEndpoints.java"
          ]
        },
        "utils/": {
          "description": "Código de utilidades (opcional)",
          "naming": "{Utility}.java",
          "examples": [
            "Constants.java",
            "DateUtils.java",
            "JsonUtils.java"
          ]
        }
      },
      "src/test/java/com/{company}/": {
        "stepdefinitions/": {
          "description": "Step Definitions - Glue code Cucumber (máx 3 líneas por método)",
          "naming": "{Feature}StepDefinitions.java",
          "examples": [
            "UserStepDefinitions.java",
            "PolicyStepDefinitions.java"
          ]
        },
        "runners/": {
          "description": "Runners - Ejecutores de tests",
          "naming": "{Feature}Runner.java",
          "examples": [
            "UserManagementRunner.java",
            "PolicyRunner.java"
          ]
        }
      },
      "src/test/resources/": {
        "features/": {
          "description": "Feature files - Escenarios Gherkin",
          "naming": "{feature}.feature",
          "examples": [
            "user_management.feature",
            "policy_creation.feature"
          ]
        }
      },
      "serenity.properties": {
        "location": "Raíz del proyecto (fuera de src/)",
        "description": "Configuración de Serenity BDD - DEBE estar en la raíz del proyecto"
      }
    },
    "notes": [
      "NO incluir carpeta 'api' en el package (usar com.{company} directamente)",
      "builders/ para construcción de datos de prueba (opcional)",
      "endpoints/ separado para URLs de la API",
      "utils/ solo para utilidades generales (opcional)",
      "serenity.properties DEBE estar en la raíz del proyecto (fuera de src/), tanto en Maven como en Gradle",
      "stepdefinitions en minúscula (convención)",
      "Order: tasks -> interactions -> questions -> models -> builders -> endpoints -> utils"
    ]
  },
  "namingConventions": {
    "language": {
      "rule": "TODO en ESPAÑOL excepto nombres del framework y dependencias externas",
      "inSpanish": [
        "Nombres de clases personalizadas (Tasks, Interactions, Questions, Models)",
        "Nombres de métodos propios",
        "Variables locales",
        "Comentarios y documentación",
        "Mensajes de validación y excepciones",
        "Nombres de packages personalizados (com.empresa.proyecto)"
      ],
      "inEnglish": [
        "Palabras clave del framework: Task, Interaction, Question, Actor",
        "Métodos del framework: performAs(), answeredBy(), attemptsTo()",
        "Clases de Serenity: SerenityRest, CallAnApi, OnStage",
        "Anotaciones: @Step, @When, @Then, @Given",
        "Imports de librerías externas",
        "Tipos de datos Java: String, Integer, Boolean, List"
      ],
      "examples": {
        "taskName": {
          "incorrect": "CreateUser",
          "correct": "CrearUsuario",
          "reason": "Nombres propios deben estar en español"
        },
        "methodName": {
          "incorrect": "public static CreateUser with(CreateUserRequest request)",
          "correct": "public static CrearUsuario con(SolicitudCrearUsuario request)",
          "reason": "Métodos y parámetros propios en español"
        },
        "variable": {
          "incorrect": "String endpoint = \"/users\";",
          "correct": "String puntoFinal = \"/users\";",
          "reason": "Variables locales en español"
        },
        "frameworkMethod": {
          "correct": "@Override\npublic <T extends Actor> void performAs(T actor)",
          "reason": "performAs() es del framework, se mantiene en inglés"
        },
        "annotation": {
          "correct": "@Step(\"{0} crea un nuevo usuario\")",
          "reason": "Anotación en inglés, mensaje en español"
        }
      }
    },
    "tasks": {
      "pattern": "Verbo en infinitivo + Recurso en español",
      "examples": [
        "CrearUsuario",
        "ObtenerPoliza",
        "ActualizarCliente",
        "EliminarProducto"
      ],
      "format": "PascalCase",
      "factoryMethod": "con(), desde(), para(), usando()",
      "fullExample": {
        "className": "ObtenerTodosLosPersonajes",
        "factoryMethod": "desdeApi()",
        "usage": "ObtenerTodosLosPersonajes.desdeApi()"
      }
    },
    "interactions": {
      "pattern": "Acción técnica + Request/Solicitud",
      "examples": [
        "SolicitudPost",
        "SolicitudGet",
        "SolicitudPut",
        "SolicitudDelete"
      ],
      "alternativePattern": "Mantener nombres técnicos reconocibles",
      "recommended": [
        "PostRequest",
        "GetRequest",
        "PutRequest",
        "DeleteRequest"
      ],
      "format": "PascalCase",
      "reason": "Interactions son muy técnicas, pueden mantenerse en inglés para claridad",
      "factoryMethod": "a(), hacia(), desde()"
    },
    "questions": {
      "pattern": "Qué se obtiene + Del/De + Origen",
      "examples": [
        "CodigoDeEstadoRespuesta",
        "CampoDelCuerpo",
        "MensajeDeError",
        "ListaDeResultados"
      ],
      "mustReturn": true,
      "format": "PascalCase",
      "factoryMethod": "valor(), obtenido(), actual()",
      "fullExample": {
        "className": "CodigoDeEstadoRespuesta",
        "factoryMethod": "valor()",
        "usage": "CodigoDeEstadoRespuesta.valor()"
      }
    },
    "models": {
      "pattern": "Nombre del recurso + Solicitud/Respuesta",
      "examples": [
        "SolicitudCrearUsuario",
        "RespuestaUsuario",
        "SolicitudActualizarPoliza"
      ],
      "format": "PascalCase",
      "fields": "Nombres de campos en español: nombre, correo, fechaCreacion",
      "fullExample": {
        "request": "SolicitudCrearUsuario",
        "response": "RespuestaUsuario",
        "fields": "private String nombre;\nprivate String correo;\nprivate Integer edad;"
      }
    },
    "builders": {
      "pattern": "Constructor + Nombre del Modelo",
      "examples": [
        "ConstructorSolicitudCrearUsuario",
        "ConstructorActualizarPoliza"
      ],
      "format": "PascalCase",
      "methods": "conDatosValidos(), conDatosInvalidos(), conCampoVacio()",
      "fullExample": {
        "className": "ConstructorSolicitudCrearUsuario",
        "method": "conDatosValidos()",
        "usage": "ConstructorSolicitudCrearUsuario.conDatosValidos()"
      }
    },
    "stepDefinitions": {
      "pattern": "Nombre del Recurso + DefinicionesDePasos",
      "examples": [
        "UsuarioDefinicionesDePasos",
        "PersonajeDefinicionesDePasos"
      ],
      "format": "PascalCase",
      "methods": "Nombres descriptivos en español: elUsuarioConsultaTodosLosPersonajes()"
    },
    "endpoints": {
      "className": "Pattern: PuntosFinal + Recurso o Recurso + Endpoints (técnico reconocible)",
      "examples": [
        "PersonajeEndpoints",
        "UsuarioEndpoints"
      ],
      "format": "PascalCase",
      "constants": "En español: CREAR_USUARIO, OBTENER_TODOS, ACTUALIZAR_POR_ID",
      "reason": "Endpoints puede mantenerse por ser término técnico universal"
    }
  },
  "standards": {
    "endpoints": {
      "className": "Pattern: {Resource}Endpoints",
      "example": "UserEndpoints",
      "rules": [
        "NO hardcodear URLs en Tasks",
        "Siempre versionar (ej: /v1)",
        "Usar constantes public static final String"
      ],
      "template": "public class {Resource}Endpoints {\n    public static final String CREATE_{RESOURCE} = \"/v1/{resource}s\";\n    public static final String GET_{RESOURCE} = \"/v1/{resource}s/{id}\";\n}"
    },
    "models": {
      "rules": [
        "Solo datos (sin lógica)",
        "Nombres alineados al contrato API",
        "Usar getters y setters",
        "Pueden usar Lombok para reducir boilerplate"
      ],
      "template": "public class {Name}Request {\n    private String field1;\n    private String field2;\n    \n    // getters & setters\n}"
    },
    "builders": {
      "rules": [
        "Builders generan escenarios",
        "No lógica de envío",
        "Métodos estáticos con nombres descriptivos",
        "Prefijo: with..."
      ],
      "template": "public class {Name}RequestBuilder {\n    public static {Name}Request withValidData() {\n        return new {Name}Request(\"value1\", \"value2\");\n    }\n    \n    public static {Name}Request withInvalidData() {\n        return new {Name}Request(\"invalid1\", \"invalid2\");\n    }\n}",
      "methodPatterns": [
        "withValidData()",
        "withInvalidEmail()",
        "withMissingField()",
        "withEmptyData()"
      ],
      "javadocRequirement": {
        "description": "Todos los Builders deben tener documentación Javadoc",
        "required": true,
        "example": "/**\n * Builder para construir requests de creación de usuario\n * Responsabilidad: Generar datos de prueba para diferentes escenarios\n * \n * @author Equipo QA\n * @version 1.0\n */\npublic class UserBuilder {\n    \n    /**\n     * Crea un request con datos válidos\n     * @return CreateUserRequest con todos los campos válidos\n     */\n    public static CreateUserRequest withValidData() {\n        return new CreateUserRequest(\n            \"John Doe\",\n            \"john.doe@example.com\",\n            \"password123\"\n        );\n    }\n    \n    /**\n     * Crea un request con email inválido\n     * @return CreateUserRequest con email en formato incorrecto\n     */\n    public static CreateUserRequest withInvalidEmail() {\n        return new CreateUserRequest(\n            \"John Doe\",\n            \"invalid-email\",\n            \"password123\"\n        );\n    }\n}"
      }
    },
    "interactions": {
      "rules": [
        "HTTP vive aquí",
        "Reutilizable",
        "Sin aserciones",
        "Implementa Interaction",
        "Método estático para construcción"
      ],
      "template": "public class {HttpMethod}Request implements Interaction {\n    private final String endpoint;\n    private final Object body;\n    \n    public {HttpMethod}Request(String endpoint, Object body) {\n        this.endpoint = endpoint;\n        this.body = body;\n    }\n    \n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            {HttpMethod}.to(endpoint)\n                .with(request -> request\n                    .contentType(ContentType.JSON)\n                    .body(body)\n                )\n        );\n    }\n    \n    public static {HttpMethod}Request to(String endpoint, Object body) {\n        return new {HttpMethod}Request(endpoint, body);\n    }\n}",
      "availableTypes": [
        "PostRequest",
        "GetRequest",
        "PutRequest",
        "DeleteRequest",
        "PatchRequest"
      ],
      "specializedInteractions": {
        "description": "Interacciones especializadas opcionales para casos de uso específicos",
        "responseStorage": {
          "name": "GuardarRespuesta",
          "description": "Interaction para guardar respuestas de API en memoria para reutilización entre escenarios",
          "when": "Usar cuando necesites compartir datos de respuesta entre múltiples escenarios o pasos",
          "template": "package {package}.interactions;\n\nimport net.serenitybdd.screenplay.Actor;\nimport net.serenitybdd.screenplay.Interaction;\nimport {package}.abilities.LlamarAPIsRimac;\n\nimport java.util.function.Consumer;\n\n/**\n * Interaction para guardar respuestas de API en memoria\n * Responsabilidad: Extraer y almacenar la respuesta deserializada para uso posterior\n * \n * @param <T> Tipo de la clase de respuesta\n */\npublic class GuardarRespuesta<T> implements Interaction {\n\n    private final Class<T> responseClass;\n    private final Consumer<T> setter;\n    private final String nombreServicio;\n\n    /**\n     * Constructor privado\n     * @param responseClass Clase del modelo de respuesta\n     * @param setter Consumer que guarda la respuesta\n     * @param nombreServicio Nombre del servicio para logging\n     */\n    private GuardarRespuesta(Class<T> responseClass, Consumer<T> setter, String nombreServicio) {\n        this.responseClass = responseClass;\n        this.setter = setter;\n        this.nombreServicio = nombreServicio;\n    }\n\n    /**\n     * Factory method para crear la interacción\n     * @param responseClass Clase del modelo de respuesta\n     * @param setter Consumer que guarda la respuesta\n     * @param nombreServicio Nombre del servicio para logging\n     * @return Instancia de GuardarRespuesta\n     */\n    public static <T> GuardarRespuesta<T> de(Class<T> responseClass, Consumer<T> setter, String nombreServicio) {\n        return new GuardarRespuesta<>(responseClass, setter, nombreServicio);\n    }\n\n    @Override\n    public <A extends Actor> void performAs(A actor) {\n        LlamarAPIsRimac ability = actor.abilityTo(LlamarAPIsRimac.class);\n        T body = ability.getResponse()\n                .then()\n                .extract()\n                .body()\n                .as(responseClass);\n\n        // Guardamos la respuesta usando el setter\n        setter.accept(body);\n\n        System.out.println(\"Respuesta de '\" + nombreServicio + \"' guardada en memoria\");\n    }\n}",
          "usage": {
            "description": "Cómo usar GuardarRespuesta en un Task",
            "example": "actor.attemptsTo(\n    ConfigurarEndpoint.conServicio(\"ObtenerCliente\"),\n    ConfigurarAutenticacion.conCredencialesAWS(),\n    AgregarParametros.query(\n        \"page\", \"1\",\n        \"pageSize\", \"10\",\n        \"idProducto\", idProducto,\n        \"nroPoliza\", nroPoliza\n    ),\n    EjecutarLlamadaAPI.get(),\n    GuardarRespuesta.de(ValidarObtenerCliente.class, RespuestaObtenerCliente::setRespuesta, \"Obtener Datos Cliente\")\n);"
          },
          "rules": [
            "Usar generics para type safety",
            "Usar Consumer<T> para flexibilidad",
            "Incluir logging para debugging",
            "Guardar después de ejecutar la llamada API",
            "Nombre del servicio descriptivo para logs"
          ]
        }
      }
    },
    "responseStorage": {
      "description": "Patrón para almacenar y recuperar respuestas de API entre escenarios",
      "when": "Usar cuando los datos de una respuesta API se necesiten en escenarios posteriores",
      "pattern": "Clase estática con getter/setter para cada tipo de respuesta",
      "location": "{package}.util.storage o {package}.storage",
      "rules": [
        "Una clase de storage por tipo de respuesta",
        "Usar static para compartir entre escenarios",
        "Nombres descriptivos que indiquen qué almacenan",
        "Métodos getter/setter claros",
        "Thread-safe si es necesario (considerar ThreadLocal para ejecución paralela)"
      ],
      "template": "package {package}.util.storage.{module};\n\nimport {package}.response.{module}.{ResponseModel};\n\n/**\n * Clase de almacenamiento para respuestas de {ServiceName}\n * Responsabilidad: Mantener en memoria la respuesta para uso entre escenarios\n */\npublic class Respuesta{ServiceName} {\n\n    private static {ResponseModel} response;\n\n    /**\n     * Guarda la respuesta del servicio\n     * @param respuesta Respuesta a almacenar\n     */\n    public static void setRespuesta({ResponseModel} respuesta) {\n        response = respuesta;\n    }\n\n    /**\n     * Obtiene la respuesta almacenada\n     * @return Respuesta guardada previamente\n     */\n    public static {ResponseModel} getRespuesta() {\n        return response;\n    }\n}",
      "threadSafeTemplate": "package {package}.util.storage.{module};\n\nimport {package}.response.{module}.{ResponseModel};\n\n/**\n * Clase de almacenamiento thread-safe para respuestas de {ServiceName}\n * Responsabilidad: Mantener en memoria la respuesta de forma segura para ejecución paralela\n */\npublic class Respuesta{ServiceName} {\n\n    private static ThreadLocal<{ResponseModel}> response = new ThreadLocal<>();\n\n    /**\n     * Guarda la respuesta del servicio para el thread actual\n     * @param respuesta Respuesta a almacenar\n     */\n    public static void setRespuesta({ResponseModel} respuesta) {\n        response.set(respuesta);\n    }\n\n    /**\n     * Obtiene la respuesta almacenada para el thread actual\n     * @return Respuesta guardada previamente\n     */\n    public static {ResponseModel} getRespuesta() {\n        return response.get();\n    }\n\n    /**\n     * Limpia la respuesta almacenada para el thread actual\n     */\n    public static void limpiar() {\n        response.remove();\n    }\n}",
      "example": {
        "storageClass": "package rimac.api.util.storage.endoso;\n\nimport rimac.api.response.endoso.ValidarObtenerCliente;\n\n/**\n * Almacenamiento para respuestas de Obtener Cliente\n */\npublic class RespuestaObtenerCliente {\n\n    private static ValidarObtenerCliente response;\n\n    public static void setRespuesta(ValidarObtenerCliente respuesta) {\n        response = respuesta;\n    }\n\n    public static ValidarObtenerCliente getRespuesta() {\n        return response;\n    }\n}",
        "responseModel": "package rimac.api.response.endoso;\n\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.gson.annotations.Expose;\nimport com.google.gson.annotations.SerializedName;\nimport lombok.Data;\n\nimport java.util.List;\n\n/**\n * Modelo de respuesta para Obtener Cliente\n */\n@Data\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class ValidarObtenerCliente {\n\n    @SerializedName(\"payload\")\n    @Expose\n    private Payload payload;\n\n    @Data\n    @JsonIgnoreProperties(ignoreUnknown = true)\n    public static class Payload {\n\n        @SerializedName(\"items\")\n        @JsonProperty(\"items\")\n        private List<Item> items;\n\n        @SerializedName(\"totalItems\")\n        @JsonProperty(\"totalItems\")\n        private int totalItems;\n    }\n\n    @Data\n    @JsonIgnoreProperties(ignoreUnknown = true)\n    public static class Item {\n\n        @SerializedName(\"idCliente\")\n        @JsonProperty(\"idCliente\")\n        private String idCliente;\n\n        @SerializedName(\"cliente\")\n        @JsonProperty(\"cliente\")\n        private String cliente;\n\n        @SerializedName(\"nroDocumento\")\n        @JsonProperty(\"nroDocumento\")\n        private String nroDocumento;\n    }\n}",
        "taskUsage": "package rimac.api.tasks.endosos.valoresDeclarados;\n\nimport net.serenitybdd.screenplay.Actor;\nimport net.serenitybdd.screenplay.Task;\nimport rimac.api.interactions.*;\nimport rimac.api.response.endoso.ValidarObtenerCliente;\nimport rimac.api.util.storage.endoso.RespuestaObtenerCliente;\n\n/**\n * Task para obtener datos de cliente\n */\npublic class ObtenerDatosCliente implements Task {\n\n    private final String idProducto;\n    private final String nroPoliza;\n\n    private ObtenerDatosCliente(String idProducto, String nroPoliza) {\n        this.idProducto = idProducto;\n        this.nroPoliza = nroPoliza;\n    }\n\n    public static ObtenerDatosCliente conParametros(String idProducto, String nroPoliza) {\n        return new ObtenerDatosCliente(idProducto, nroPoliza);\n    }\n\n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n                ConfigurarEndpoint.conServicio(\"ObtenerCliente\"),\n                ConfigurarAutenticacion.conCredencialesAWS(),\n                AgregarParametros.query(\n                        \"page\", \"1\",\n                        \"pageSize\", \"10\",\n                        \"idProducto\", idProducto,\n                        \"nroPoliza\", nroPoliza),\n                EjecutarLlamadaAPI.get(),\n                GuardarRespuesta.de(ValidarObtenerCliente.class, RespuestaObtenerCliente::setRespuesta, \"Obtener Datos Cliente\")\n        );\n    }\n}",
        "reuseInAnotherTask": "// En otro Task o Step, recuperar los datos almacenados\nValidarObtenerCliente clienteGuardado = RespuestaObtenerCliente.getRespuesta();\nString idCliente = clienteGuardado.getPayload().getItems().get(0).getIdCliente();\n\n// Usar el dato en una nueva llamada\nactor.attemptsTo(\n    ConfigurarEndpoint.conServicio(\"ActualizarCliente\"),\n    AgregarParametros.path(\"idCliente\", idCliente),\n    EjecutarLlamadaAPI.put()\n);"
      },
      "bestPractices": [
        "Documentar claramente qué se almacena y por qué",
        "Usar ThreadLocal para ejecución paralela de tests",
        "Considerar limpiar el storage en @After hooks",
        "No abusar del patrón - solo para casos necesarios",
        "Validar que la respuesta no sea null antes de usar",
        "Preferir pasar datos entre steps cuando sea posible"
      ],
      "antiPatterns": [
        "Almacenar todas las respuestas innecesariamente",
        "No limpiar el storage entre escenarios",
        "Compartir estado sin ThreadLocal en tests paralelos",
        "Acceder al storage sin validar null",
        "Usar para datos que pueden pasarse como parámetros"
      ]
    },
    "tasks": {
      "rules": [
        "Lenguaje de negocio",
        "No HTTP directo",
        "Reutilizable",
        "Implementa Task",
        "Método estático para construcción"
      ],
      "template": "public class {TaskName} implements Task {\n    private final {Model}Request request;\n    \n    public {TaskName}({Model}Request request) {\n        this.request = request;\n    }\n    \n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            {Interaction}.to({Endpoint}, request)\n        );\n    }\n    \n    public static {TaskName} with({Model}Request request) {\n        return new {TaskName}(request);\n    }\n}"
    },
    "questions": {
      "rules": [
        "Implementa Question<T>",
        "Debe retornar un valor",
        "Sin lógica compleja",
        "Método estático para construcción"
      ],
      "template": "public class {QuestionName} implements Question<{ReturnType}> {\n    @Override\n    public {ReturnType} answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().{method}();\n    }\n    \n    public static {QuestionName} value() {\n        return new {QuestionName}();\n    }\n}",
      "commonQuestions": [
        {
          "name": "ResponseStatusCode",
          "returns": "Integer",
          "method": "statusCode()"
        },
        {
          "name": "ResponseBodyField",
          "returns": "String",
          "method": "jsonPath().getString(field)"
        },
        {
          "name": "ErrorMessage",
          "returns": "String",
          "method": "jsonPath().getString(\"message\")"
        }
      ]
    },
    "stepDefinitions": {
      "rules": [
        "Máximo 3 líneas",
        "No lógica",
        "No aserciones técnicas",
        "Solo orquestación"
      ],
      "template": "@{Cucumber}(\"{text}\")\npublic void {methodName}({params}) {\n    actor.attemptsTo(\n        {Task}.with({Builder}.{method}())\n    );\n}",
      "validationTemplate": "@Then(\"{validation text}\")\npublic void {methodName}({type} {param}) {\n    actor.should(\n        seeThat(\"{description}\", {Question}.value(), equalTo({param}))\n    );\n}",
      "note": "El primer parámetro de seeThat() es una descripción que mejora el reporte y ayuda con la inferencia de tipos"
    }
  },
  "mandatoryValidations": {
    "description": "Cada escenario debe validar mínimo:",
    "required": [
      {
        "validation": "Status code",
        "example": "actor.should(seeThat(\"El código de respuesta\", ResponseStatusCode.value(), equalTo(200)))"
      },
      {
        "validation": "Un campo del body",
        "example": "actor.should(seeThat(\"El campo name del response\", ResponseBodyField.of(\"name\"), equalTo(\"Daniel\")))"
      },
      {
        "validation": "Mensaje de error (si aplica)",
        "example": "actor.should(seeThat(\"El mensaje de error\", ErrorMessage.value(), containsString(\"invalid\")))"
      }
    ]
  },
  "completeExample": {
    "feature": "Feature: Gestión de usuarios\n  Scenario: Crear usuario válido\n    When el usuario crea un usuario valido\n    Then la respuesta debe ser 201\n    And el body debe contener el nombre del usuario",
    "endpoint": "public class UserEndpoints {\n    public static final String CREATE_USER = \"/v1/users\";\n    public static final String GET_USER = \"/v1/users/{id}\";\n}",
    "model": "public class CreateUserRequest {\n    private String name;\n    private String email;\n    \n    public CreateUserRequest(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n    // getters & setters\n}",
    "builder": "public class CreateUserRequestBuilder {\n    public static CreateUserRequest withValidData() {\n        return new CreateUserRequest(\"Daniel\", \"daniel@test.com\");\n    }\n    \n    public static CreateUserRequest withInvalidEmail() {\n        return new CreateUserRequest(\"Daniel\", \"invalid-email\");\n    }\n}",
    "interaction": "public class PostRequest implements Interaction {\n    private final String endpoint;\n    private final Object body;\n    \n    public PostRequest(String endpoint, Object body) {\n        this.endpoint = endpoint;\n        this.body = body;\n    }\n    \n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            Post.to(endpoint)\n                .with(request -> request\n                    .contentType(ContentType.JSON)\n                    .body(body)\n                )\n        );\n    }\n    \n    public static PostRequest to(String endpoint, Object body) {\n        return new PostRequest(endpoint, body);\n    }\n}",
    "task": "public class CreateUser implements Task {\n    private final CreateUserRequest request;\n    \n    public CreateUser(CreateUserRequest request) {\n        this.request = request;\n    }\n    \n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            PostRequest.to(UserEndpoints.CREATE_USER, request)\n        );\n    }\n    \n    public static CreateUser with(CreateUserRequest request) {\n        return new CreateUser(request);\n    }\n}",
    "question": "public class ResponseStatusCode implements Question<Integer> {\n    @Override\n    public Integer answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().statusCode();\n    }\n    \n    public static ResponseStatusCode value() {\n        return new ResponseStatusCode();\n    }\n}",
    "stepDefinition": "@When(\"el usuario crea un usuario valido\")\npublic void createUser() {\n    actor.attemptsTo(\n        CreateUser.with(CreateUserRequestBuilder.withValidData())\n    );\n}\n\n@Then(\"la respuesta debe ser {int}\")\npublic void validateStatus(int status) {\n    actor.should(\n        seeThat(\"El código de respuesta\", ResponseStatusCode.value(), equalTo(status))\n    );\n}\n\n@And(\"el body debe contener el nombre del usuario\")\npublic void validateBodyField() {\n    actor.should(\n        seeThat(\"El campo name del response\", ResponseBodyField.of(\"name\"), equalTo(\"Daniel\"))\n    );\n}"
  },
  "forbidden": [
    "Usar @Steps",
    "Lógica en step definitions",
    "HTTP directo en Tasks",
    "Aserciones en Interactions",
    "URLs hardcodeadas",
    "Lógica en Models",
    "Endpoints sin versión",
    "Usar lambdas con seeThat() - SIEMPRE usar Question implementación",
    "Usar is() con tipos no-Boolean - usar equalTo() para Integer, String, etc",
    "Omitir descripción en seeThat() - SIEMPRE incluir el primer parámetro descriptivo"
  ],
  "requiredArtifacts": [
    "Feature (.feature)",
    "StepDefinitions (Java)",
    "Task (Java - implements Task)",
    "Interaction (Java - implements Interaction)",
    "Question (Java - implements Question<T>)",
    "Model (Java POJO)",
    "Builder (Java con métodos estáticos)",
    "Endpoints (Java con constantes)"
  ],
  "serenityBdd4Migration": {
    "description": "Cambios críticos en Serenity BDD 4.x que debes conocer",
    "deprecatedClasses": [
      {
        "old": "net.serenitybdd.cucumber.CucumberSerenityRunner",
        "new": "net.serenitybdd.cucumber.CucumberWithSerenity",
        "reason": "Clase deprecada y eliminada en Serenity 4.x",
        "severity": "CRÍTICO",
        "errorType": "Compilación",
        "fix": {
          "import": "import net.serenitybdd.cucumber.CucumberWithSerenity;",
          "annotation": "@RunWith(CucumberWithSerenity.class)"
        }
      }
    ],
    "runnerTemplate": "package com.{company}.runners;\n\nimport io.cucumber.junit.CucumberOptions;\nimport net.serenitybdd.cucumber.CucumberWithSerenity;\nimport org.junit.runner.RunWith;\n\n/**\n * Runner principal para la ejecución de tests con Serenity BDD y Cucumber\n * Proyecto: {projectName}\n */\n@RunWith(CucumberWithSerenity.class)\n@CucumberOptions(\n    features = \"src/test/resources/features\",\n    glue = \"com.{company}.stepdefinitions\",\n    tags = \"not @ignore\",\n    snippets = CucumberOptions.SnippetType.CAMELCASE,\n    plugin = {\"pretty\", \"json:target/cucumber-reports/cucumber.json\"}\n)\npublic class ApiTestRunner {\n    // Runner configurado para ejecutar features con Serenity Screenplay\n}"
  },
  "serenityRestApiChanges": {
    "description": "Cambios en la API de REST Assured con Serenity 4.x",
    "criticalChanges": [
      {
        "method": "Get.to()",
        "status": "DEPRECADO",
        "replacement": "Get.resource()",
        "severity": "CRÍTICO",
        "errorType": "Compilación",
        "errorMessage": "cannot find symbol - method to(String)",
        "reason": "En Serenity BDD 4.x el método estático cambió de nombre",
        "fix": {
          "before": "Get.to(endpoint)",
          "after": "Get.resource(endpoint)"
        },
        "example": {
          "incorrect": "actor.attemptsTo(\n    Get.to(\"/api/users\")\n        .with(request -> request.contentType(ContentType.JSON))\n);",
          "correct": "actor.attemptsTo(\n    Get.resource(\"/api/users\")\n        .with(request -> request.contentType(ContentType.JSON))\n);"
        }
      }
    ],
    "httpMethods": {
      "GET": "Get.resource(endpoint)",
      "POST": "Post.to(endpoint)",
      "PUT": "Put.to(endpoint)",
      "DELETE": "Delete.from(endpoint)",
      "PATCH": "Patch.to(endpoint)"
    },
    "interactionTemplate": "public class GetRequest implements Interaction {\n    \n    private final String endpoint;\n    \n    public GetRequest(String endpoint) {\n        if (endpoint == null || endpoint.isEmpty()) {\n            throw new IllegalArgumentException(\"Endpoint cannot be null or empty\");\n        }\n        this.endpoint = endpoint;\n    }\n    \n    @Step(\"{0} envía petición GET a {1}\")\n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            Get.resource(endpoint)  // ✅ CORRECTO: Get.resource()\n                .with(request -> request\n                    .contentType(ContentType.JSON)\n                    .relaxedHTTPSValidation()\n                )\n        );\n    }\n    \n    public static GetRequest to(String endpoint) {\n        return instrumented(GetRequest.class, endpoint);\n    }\n}"
  },
  "byteBuddyRequirements": {
    "description": "Serenity usa ByteBuddy para crear proxies dinámicos - Requisitos obligatorios",
    "reason": "ByteBuddy necesita instanciar clases para logging, screenshots y reportes",
    "criticalRules": [
      {
        "rule": "Tasks DEBEN tener constructor público",
        "severity": "CRÍTICO",
        "errorType": "Runtime",
        "forbidden": "private constructor",
        "required": "public constructor o sin modificador (default = public)",
        "errorMessage": "java.lang.NoSuchMethodException: com.example.tasks.TaskName$ByteBuddy.<init>()",
        "fix": "Remover palabra 'private' del constructor"
      },
      {
        "rule": "Interactions DEBEN tener constructor público",
        "severity": "CRÍTICO",
        "errorType": "Runtime",
        "forbidden": "private constructor",
        "required": "public constructor o sin modificador (default = public)",
        "errorMessage": "java.lang.NullPointerException: Cannot invoke Object.getClass()",
        "fix": "Remover palabra 'private' del constructor"
      },
      {
        "rule": "Questions NO requieren constructor público (pueden ser default)",
        "severity": "INFO",
        "reason": "Questions usan 'new' directamente, no necesitan ByteBuddy",
        "recommended": "Sin modificador o public constructor",
        "notRequired": "instrumented() - NO usar con Questions"
      },
      {
        "rule": "Clases NO deben ser final",
        "severity": "CRÍTICO",
        "reason": "ByteBuddy no puede crear subclases de clases final",
        "forbidden": "final class"
      },
      {
        "rule": "NUNCA usar 'new' para instanciar Tasks/Interactions (SÍ para Questions)",
        "severity": "CRÍTICO",
        "errorType": "Runtime",
        "forbidden": "return new Task() o return new Interaction()",
        "required": "return instrumented(Task.class) o return instrumented(Interaction.class)",
        "allowed": "return new Question() - Questions SÍ usan new",
        "errorMessage": "java.lang.NoSuchMethodException: Cannot create StepFactory",
        "reason": "Tasks/Interactions necesitan instrumentación ByteBuddy. Questions NO.",
        "fix": "Usar Tasks.instrumented() para Tasks/Interactions - usar new para Questions"
      }
    ],
    "instrumentationPattern": {
      "description": "Patrón de instanciación en Screenplay - CRÍTICO: Tasks/Interactions vs Questions",
      "import": "import static net.serenitybdd.screenplay.Tasks.instrumented;",
      "reason": "instrumented() permite a Serenity interceptar llamadas para generar reportes detallados",
      "criticalRule": "📚 Regla en Screenplay:\nTasks e Interactions → Usar instrumented() (tienen lógica compleja)\nQuestions → Usar new directamente (solo consultan estado)",
      "rules": [
        "Tasks: SIEMPRE usar 'instrumented(Task.class)' en factory methods",
        "Interactions: SIEMPRE usar 'instrumented(Interaction.class)' en factory methods",
        "Questions: NUNCA usar instrumented() - usar 'new Question()' directamente",
        "Constructor debe ser público para Tasks e Interactions (ByteBuddy)",
        "Questions pueden tener constructor sin modificador (default)"
      ],
      "examples": {
        "taskWithoutParameters": {
          "incorrect": "public static GetAllCharacters fromApi() {\n    return new GetAllCharacters();  // ❌ ERROR: Causa NoSuchMethodException\n}",
          "correct": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic static GetAllCharacters fromApi() {\n    return instrumented(GetAllCharacters.class);  // ✅ CORRECTO\n}"
        },
        "taskWithParameters": {
          "incorrect": "public static CreateUser with(CreateUserRequest request) {\n    return new CreateUser(request);  // ❌ ERROR\n}",
          "correct": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic static CreateUser with(CreateUserRequest request) {\n    return instrumented(CreateUser.class, request);  // ✅ CORRECTO\n}"
        },
        "interactionWithParameters": {
          "incorrect": "public static GetRequest to(String endpoint) {\n    return new GetRequest(endpoint);  // ❌ ERROR\n}",
          "correct": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic static GetRequest to(String endpoint) {\n    return instrumented(GetRequest.class, endpoint);  // ✅ CORRECTO\n}"
        },
        "questionWithoutInstrumented": {
          "incorrect": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic static ResponseStatusCode value() {\n    return instrumented(ResponseStatusCode.class);  // ❌ ERROR: Questions NO usan instrumented()\n}",
          "correct": "public static ResponseStatusCode value() {\n    return new ResponseStatusCode();  // ✅ CORRECTO: Questions usan new directamente\n}",
          "explanation": "Questions solo consultan estado, no ejecutan lógica compleja. No necesitan instrumentación de ByteBuddy."
        }
      }
    },
    "bestPractice": {
      "description": "Usar constructor público + factory method con instrumented() para Tasks/Interactions - new para Questions",
      "taskExample": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic class CreateUser implements Task {\n    private final CreateUserRequest request;\n    \n    // Constructor público (permite a ByteBuddy instrumentar)\n    public CreateUser(CreateUserRequest request) {\n        if (request == null) {\n            throw new IllegalArgumentException(\"Request cannot be null\");\n        }\n        this.request = request;\n    }\n    \n    @Step(\"{0} crea un usuario\")\n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            PostRequest.to(UserEndpoints.CREATE_USER, request)\n        );\n    }\n    \n    public static CreateUser with(CreateUserRequest request) {\n        return instrumented(CreateUser.class, request);  // ✅ CORRECTO\n    }\n}",
      "interactionExample": "import static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic class PostRequest implements Interaction {\n    private final String endpoint;\n    private final Object body;\n    \n    // Constructor público\n    public PostRequest(String endpoint, Object body) {\n        if (endpoint == null || endpoint.isEmpty()) {\n            throw new IllegalArgumentException(\"Endpoint cannot be null or empty\");\n        }\n        this.endpoint = endpoint;\n        this.body = body;\n    }\n    \n    @Step(\"{0} envía POST a {1}\")\n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            Post.to(endpoint).with(request -> request.contentType(ContentType.JSON).body(body))\n        );\n    }\n    \n    public static PostRequest to(String endpoint, Object body) {\n        return instrumented(PostRequest.class, endpoint, body);  // ✅ CORRECTO\n    }\n}",
      "questionExample": "public class ResponseStatusCode implements Question<Integer> {\n    \n    @Step(\"{0} obtiene el status code de la respuesta\")\n    @Override\n    public Integer answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().statusCode();\n    }\n    \n    public static ResponseStatusCode value() {\n        return new ResponseStatusCode();  // ✅ CORRECTO: Questions usan new\n    }\n}",
      "howToRequestQuestions": {
        "description": "Guía para solicitar la generación de Questions con diferentes tipos de retorno",
        "tool": "generateQuestion",
        "requiredParameters": {
          "questionName": "Nombre de la clase (ej: ResponseStatusCode, UserName, ErrorMessage)",
          "returnType": "Tipo de dato Java que retorna (Integer, String, Boolean, Object, List<String>, etc.)",
          "method": "Método de extracción de SerenityRest.lastResponse() que retorna ese tipo"
        },
        "examples": {
          "statusCode": {
            "request": "Necesito una Question para validar el status code de la respuesta",
            "parameters": {
              "questionName": "ResponseStatusCode",
              "returnType": "Integer",
              "method": "statusCode()"
            },
            "generated": "public class ResponseStatusCode implements Question<Integer> {\n    @Override\n    public Integer answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().statusCode();\n    }\n    public static ResponseStatusCode value() {\n        return new ResponseStatusCode();\n    }\n}"
          },
          "stringField": {
            "request": "Necesito una Question para obtener el campo 'name' del body de la respuesta",
            "parameters": {
              "questionName": "ResponseName",
              "returnType": "String",
              "method": "jsonPath().getString(\"name\")"
            },
            "generated": "public class ResponseName implements Question<String> {\n    @Override\n    public String answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().jsonPath().getString(\"name\");\n    }\n    public static ResponseName value() {\n        return new ResponseName();\n    }\n}"
          },
          "booleanField": {
            "request": "Necesito una Question para validar si el campo 'active' es true",
            "parameters": {
              "questionName": "IsUserActive",
              "returnType": "Boolean",
              "method": "jsonPath().getBoolean(\"active\")"
            },
            "generated": "public class IsUserActive implements Question<Boolean> {\n    @Override\n    public Boolean answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().jsonPath().getBoolean(\"active\");\n    }\n    public static IsUserActive value() {\n        return new IsUserActive();\n    }\n}"
          },
          "objectField": {
            "request": "Necesito una Question para obtener el objeto completo 'user' de la respuesta",
            "parameters": {
              "questionName": "ResponseUserObject",
              "returnType": "Object",
              "method": "jsonPath().getObject(\"user\", Object.class)"
            },
            "generated": "public class ResponseUserObject implements Question<Object> {\n    @Override\n    public Object answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().jsonPath().getObject(\"user\", Object.class);\n    }\n    public static ResponseUserObject value() {\n        return new ResponseUserObject();\n    }\n}"
          },
          "listField": {
            "request": "Necesito una Question para obtener la lista de 'results' de la respuesta",
            "parameters": {
              "questionName": "ResponseResultsList",
              "returnType": "List<Object>",
              "method": "jsonPath().getList(\"results\")"
            },
            "generated": "public class ResponseResultsList implements Question<List<Object>> {\n    @Override\n    public List<Object> answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().jsonPath().getList(\"results\");\n    }\n    public static ResponseResultsList value() {\n        return new ResponseResultsList();\n    }\n}"
          },
          "nestedField": {
            "request": "Necesito una Question para obtener el campo anidado 'data.user.email'",
            "parameters": {
              "questionName": "ResponseUserEmail",
              "returnType": "String",
              "method": "jsonPath().getString(\"data.user.email\")"
            },
            "generated": "public class ResponseUserEmail implements Question<String> {\n    @Override\n    public String answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().jsonPath().getString(\"data.user.email\");\n    }\n    public static ResponseUserEmail value() {\n        return new ResponseUserEmail();\n    }\n}"
          }
        },
        "jsonPathMethods": {
          "description": "Métodos comunes de jsonPath() según tipo de dato",
          "Integer": "jsonPath().getInt(\"campo\")",
          "String": "jsonPath().getString(\"campo\")",
          "Boolean": "jsonPath().getBoolean(\"campo\")",
          "Object": "jsonPath().getObject(\"campo\", Object.class)",
          "List": "jsonPath().getList(\"campo\")",
          "Map": "jsonPath().getMap(\"campo\")",
          "Long": "jsonPath().getLong(\"campo\")",
          "Float": "jsonPath().getFloat(\"campo\")",
          "Double": "jsonPath().getDouble(\"campo\")"
        },
        "bestPractices": [
          "Usar nombres descriptivos: ResponseStatusCode, UserName, ErrorMessage",
          "Tipo de retorno debe coincidir con el método jsonPath",
          "Para campos anidados usar dot notation: 'data.user.name'",
          "Para listas especificar el tipo genérico: List<String>, List<Object>",
          "Siempre incluir el método completo: jsonPath().getString() no solo getString()"
        ]
      }
    }
  },
  "actorManagement": {
    "description": "Patrón obligatorio para gestión de actores en Serenity Screenplay",
    "reason": "Actores creados con Actor.named() NO están gestionados por Serenity",
    "problems": [
      "No lifecycle management",
      "No aparece en reportes",
      "Falta inyección de dependencias",
      "State leaks entre escenarios"
    ],
    "required": {
      "separateHooksClass": "OBLIGATORIO - Crear clase Hooks separada de StepDefinitions",
      "hooksImports": [
        "import io.cucumber.java.Before;",
        "import io.cucumber.java.After;",
        "import net.serenitybdd.screenplay.actors.OnStage;",
        "import net.serenitybdd.screenplay.actors.OnlineCast;"
      ],
      "stepDefinitionsImports": [
        "import static net.serenitybdd.screenplay.actors.OnStage.theActorCalled;",
        "import static net.serenitybdd.screenplay.actors.OnStage.theActorInTheSpotlight;"
      ]
    },
    "hooksTemplate": "package com.screenplay.api.hooks;\n\nimport io.cucumber.java.Before;\nimport io.cucumber.java.After;\nimport net.serenitybdd.screenplay.actors.OnStage;\nimport net.serenitybdd.screenplay.actors.OnlineCast;\n\n/**\n * Hooks: Configuración de actores antes y después de cada escenario\n * Responsabilidad: Inicializar OnStage y liberar recursos\n * CRÍTICO: Debe ejecutarse antes de cualquier StepDefinition\n */\npublic class Hooks {\n\n    @Before(order = 0)\n    public void setTheStage() {\n        OnStage.setTheStage(new OnlineCast());\n    }\n\n    @After(order = 1)\n    public void tearDown() {\n        OnStage.drawTheCurtain();\n    }\n}",
    "stepDefinitionsTemplate": "package com.screenplay.api.stepdefinitions;\n\nimport io.cucumber.java.es.*;\nimport static net.serenitybdd.screenplay.actors.OnStage.*;\nimport static net.serenitybdd.screenplay.GivenWhenThen.seeThat;\nimport static org.hamcrest.Matchers.*;\n\npublic class UserStepDefinitions {\n\n    @Cuando(\"el usuario crea un usuario valido\")\n    public void createUser() {\n        theActorCalled(\"Usuario\")\n            .whoCan(CallAnApi.at(UserEndpoints.BASE_URL));\n        \n        theActorInTheSpotlight()\n            .attemptsTo(CreateUser.with(CreateUserRequestBuilder.withValidData()));\n    }\n\n    @Entonces(\"la respuesta debe ser {int}\")\n    public void validateStatus(int status) {\n        theActorInTheSpotlight()\n            .should(seeThat(\"El código de respuesta\", ResponseStatusCode.value(), equalTo(status)));\n    }\n}",
    "methods": [
      {
        "name": "OnStage.setTheStage()",
        "description": "Inicializa el sistema de actores",
        "usage": "En @Before hook",
        "parameter": "new OnlineCast()"
      },
      {
        "name": "theActorCalled(String name)",
        "description": "Crea o recupera un actor por nombre",
        "usage": "Primera aparición del actor en el escenario",
        "returns": "Actor gestionado"
      },
      {
        "name": "theActorInTheSpotlight()",
        "description": "Obtiene el actor actual (último usado)",
        "usage": "En steps subsecuentes del mismo escenario",
        "returns": "Actor con el spotlight"
      }
    ],
    "forbidden": [
      "private Actor actor = Actor.named(\"Usuario\");",
      "Actor actor = Actor.named(\"Usuario\");",
      "Crear actores sin OnStage",
      "@Before en StepDefinitions - debe ir en clase Hooks separada",
      "OnStage.setTheStage() en StepDefinitions - debe ir en clase Hooks separada"
    ],
    "criticalRule": {
      "title": "NUNCA poner @Before/@After en StepDefinitions",
      "reason": "Viola separación de responsabilidades y causa duplicación",
      "correct": "Crear clase Hooks SEPARADA con @Before/@After",
      "incorrect": "Poner @Before/@After dentro de StepDefinitions",
      "example": {
        "wrong": "public class UserStepDefinitions {\n    @Before\n    public void setTheStage() { // ❌ MAL - No hacer esto\n        OnStage.setTheStage(new OnlineCast());\n    }\n}",
        "right": "// Hooks.java - Clase SEPARADA\npublic class Hooks {\n    @Before\n    public void setTheStage() { // ✅ BIEN\n        OnStage.setTheStage(new OnlineCast());\n    }\n}\n\n// UserStepDefinitions.java - Sin @Before/@After\npublic class UserStepDefinitions {\n    @When(\"...\")\n    public void step() { // ✅ BIEN - Solo steps\n        theActorCalled(\"Usuario\")...;\n    }\n}"
      }
    },
    "stepDefinitionsExamples": {
      "description": "Ejemplos completos de StepDefinitions usando el patrón Actor correctamente",
      "basicExample": "package com.screenplay.api.stepdefinitions;\n\nimport io.cucumber.java.es.*;\nimport static net.serenitybdd.screenplay.actors.OnStage.*;\nimport static net.serenitybdd.screenplay.GivenWhenThen.seeThat;\nimport static org.hamcrest.Matchers.*;\nimport net.serenitybdd.screenplay.rest.abilities.CallAnApi;\n\n/**\n * Step Definitions para gestión de usuarios\n * Responsabilidad: Orquestar Tasks y Questions usando Actor\n * CRÍTICO: Máximo 3 líneas por método, sin lógica\n */\npublic class UserStepDefinitions {\n\n    @Dado(\"que el servicio de usuarios está disponible\")\n    public void serviceIsAvailable() {\n        theActorCalled(\"Usuario\")\n            .whoCan(CallAnApi.at(UserEndpoints.BASE_URL));\n    }\n\n    @Cuando(\"el usuario crea un nuevo usuario con datos válidos\")\n    public void createUser() {\n        theActorInTheSpotlight()\n            .attemptsTo(CreateUser.with(UserBuilder.withValidData()));\n    }\n\n    @Entonces(\"el código de respuesta debe ser {int}\")\n    public void validateStatusCode(int expectedStatus) {\n        theActorInTheSpotlight()\n            .should(seeThat(\"El código de respuesta\", ResponseStatusCode.value(), equalTo(expectedStatus)));\n    }\n\n    @Y(\"el response debe contener el campo {string}\")\n    public void validateFieldExists(String fieldName) {\n        theActorInTheSpotlight()\n            .should(seeThat(\"El campo \" + fieldName + \" existe\", ResponseBodyField.called(fieldName), notNullValue()));\n    }\n}",
      "advancedExample": "package com.screenplay.api.stepdefinitions;\n\nimport io.cucumber.java.es.*;\nimport static net.serenitybdd.screenplay.actors.OnStage.*;\nimport static net.serenitybdd.screenplay.GivenWhenThen.seeThat;\nimport static org.hamcrest.Matchers.*;\nimport net.serenitybdd.screenplay.rest.abilities.CallAnApi;\n\npublic class CharacterStepDefinitions {\n\n    @Dado(\"que el usuario puede acceder a la API de Rick and Morty\")\n    public void setupApiAccess() {\n        theActorCalled(\"Consumidor\")\n            .whoCan(CallAnApi.at(\"https://rickandmortyapi.com/api\"));\n    }\n\n    @Cuando(\"el usuario consulta todos los personajes\")\n    public void getAllCharacters() {\n        theActorInTheSpotlight()\n            .attemptsTo(GetAllCharacters.from());\n    }\n\n    @Entonces(\"la respuesta debe tener código {int}\")\n    public void validateStatus(int status) {\n        theActorInTheSpotlight()\n            .should(seeThat(\"Status code\", ResponseStatusCode.value(), equalTo(status)));\n    }\n\n    @Y(\"el campo {string} debe existir\")\n    public void fieldExists(String field) {\n        theActorInTheSpotlight()\n            .should(seeThat(\"Campo \" + field, ResponseBodyField.called(field), notNullValue()));\n    }\n\n    @Y(\"el campo {string} debe contener al menos {int} elemento(s)\")\n    public void fieldHasMinElements(String field, int minElements) {\n        theActorInTheSpotlight()\n            .should(seeThat(\"Tamaño de \" + field, ResponseArraySize.of(field), greaterThanOrEqualTo(minElements)));\n    }\n}",
      "commonMistakes": {
        "mistake1": {
          "title": "❌ NO usar Actor directamente",
          "wrong": "public class UserStepDefinitions {\n    private Actor actor = Actor.named(\"Usuario\"); // ❌ MAL\n    \n    @When(\"...\")\n    public void step() {\n        actor.attemptsTo(...); // ❌ Actor no gestionado\n    }\n}",
          "right": "public class UserStepDefinitions {\n    // ✅ NO declarar Actor como field\n    \n    @When(\"...\")\n    public void step() {\n        theActorInTheSpotlight() // ✅ Usar OnStage\n            .attemptsTo(...);\n    }\n}"
        },
        "mistake2": {
          "title": "❌ NO poner lógica en StepDefinitions",
          "wrong": "@Then(\"validar respuesta\")\npublic void validate() {\n    Response response = actor.asksFor(LastResponse.received());\n    if (response.statusCode() == 200) { // ❌ Lógica\n        // validaciones...\n    }\n}",
          "right": "@Then(\"el código de respuesta debe ser {int}\")\npublic void validateStatus(int status) {\n    theActorInTheSpotlight()\n        .should(seeThat(\"Status\", ResponseStatusCode.value(), equalTo(status)));\n    // ✅ Sin lógica, solo orquestación\n}"
        },
        "mistake3": {
          "title": "❌ NO usar assertThat directamente",
          "wrong": "@Then(\"validar campo\")\npublic void validate() {\n    String value = actor.asksFor(ResponseField.called(\"name\"));\n    assertThat(value, equalTo(\"expected\")); // ❌ assertThat directo\n}",
          "right": "@Then(\"el campo {string} debe ser {string}\")\npublic void validateField(String field, String expected) {\n    theActorInTheSpotlight()\n        .should(seeThat(\"Campo \" + field, ResponseField.called(field), equalTo(expected)));\n    // ✅ Usar seeThat con Question\n}"
        }
      }
    }
  },
  "jacksonAnnotations": {
    "description": "Anotaciones obligatorias para serialización JSON con Jackson",
    "mandatory": "@JsonIgnoreProperties(ignoreUnknown = true)",
    "reason": "APIs externas pueden devolver más campos de los que necesitas mapear",
    "severity": "CRÍTICO",
    "errorType": "Runtime - Deserialización",
    "errorMessage": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field",
    "required": {
      "allModels": "Todos los modelos Request y Response DEBEN tener la anotación",
      "import": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;"
    },
    "template": "@JsonIgnoreProperties(ignoreUnknown = true)\npublic class CreateUserRequest {\n    @JsonProperty(\"name\")\n    private String name;\n    \n    @JsonProperty(\"email\")\n    private String email;\n    \n    // Constructor, getters, setters\n}",
    "bestPractices": [
      "Mapear solo los campos necesarios para tus tests",
      "La API puede cambiar sin romper tus tests",
      "Facilita mantenimiento a largo plazo"
    ],
    "whenToUse": [
      "APIs externas (siempre)",
      "Testing (mapear solo lo necesario)",
      "Versionado de APIs (compatibilidad)",
      "Microservicios (contratos flexibles)"
    ]
  },
  "httpStatusCodes": {
    "description": "Status codes HTTP correctos según operación REST",
    "mandatory": "Usar el status code correcto según el método HTTP",
    "rules": [
      {
        "method": "GET",
        "success": 200,
        "description": "OK - Recurso(s) encontrado(s) y devueltos",
        "error": 404,
        "errorDescription": "Not Found - Recurso no existe",
        "forbidden": [
          201
        ],
        "example": "GET /characters → 200 OK"
      },
      {
        "method": "POST",
        "success": 201,
        "description": "Created - Recurso creado exitosamente",
        "alternatives": [
          200
        ],
        "alternativeNote": "200 OK es posible pero 201 es más específico",
        "error": 400,
        "errorDescription": "Bad Request - Datos inválidos",
        "example": "POST /users → 201 Created"
      },
      {
        "method": "PUT",
        "success": 200,
        "description": "OK - Recurso actualizado y devuelto",
        "alternatives": [
          204
        ],
        "alternativeNote": "204 No Content si no se devuelve el recurso",
        "error": 404,
        "errorDescription": "Not Found - Recurso no existe",
        "example": "PUT /users/1 → 200 OK"
      },
      {
        "method": "PATCH",
        "success": 200,
        "description": "OK - Recurso parcialmente actualizado",
        "alternatives": [
          204
        ],
        "alternativeNote": "204 No Content si no se devuelve el recurso",
        "error": 404,
        "errorDescription": "Not Found - Recurso no existe",
        "example": "PATCH /users/1 → 200 OK"
      },
      {
        "method": "DELETE",
        "success": 204,
        "description": "No Content - Recurso eliminado",
        "alternatives": [
          200
        ],
        "alternativeNote": "200 OK si se devuelve confirmación",
        "error": 404,
        "errorDescription": "Not Found - Recurso no existe",
        "forbidden": [
          201
        ],
        "example": "DELETE /users/1 → 204 No Content"
      }
    ],
    "commonMistakes": [
      {
        "mistake": "Usar 201 para GET",
        "correct": "200 OK",
        "explanation": "GET no crea recursos, solo los recupera"
      },
      {
        "mistake": "Usar 200 para POST de creación",
        "correct": "201 Created",
        "explanation": "201 es más semánticamente correcto para creación"
      },
      {
        "mistake": "Usar 201 para DELETE",
        "correct": "204 No Content",
        "explanation": "DELETE no crea recursos, los elimina"
      }
    ]
  },
  "stepAnnotations": {
    "description": "Anotación @Step recomendada para mejor reporting",
    "optional": true,
    "recommended": true,
    "benefits": [
      "Mejora reportes HTML de Serenity",
      "Permite usar placeholders como {0} para el actor",
      "Hace el reporte más legible",
      "Facilita debugging"
    ],
    "usage": {
      "import": "import net.serenitybdd.annotations.Step;",
      "taskExample": "@Step(\"{0} crea un usuario con datos válidos\")\n@Override\npublic <T extends Actor> void performAs(T actor) {\n    actor.attemptsTo(\n        PostRequest.to(UserEndpoints.CREATE_USER, request)\n    );\n}",
      "interactionExample": "@Step(\"{0} envía petición POST a {1}\")\n@Override\npublic <T extends Actor> void performAs(T actor) {\n    actor.attemptsTo(\n        Post.to(endpoint).with(request -> request.contentType(ContentType.JSON).body(body))\n    );\n}",
      "questionExample": "@Step(\"{0} obtiene el status code de la respuesta\")\n@Override\npublic Integer answeredBy(Actor actor) {\n    return SerenityRest.lastResponse().statusCode();\n}"
    },
    "placeholders": [
      "{0} - Nombre del actor",
      "{1} - Primer parámetro del método",
      "{2} - Segundo parámetro del método"
    ]
  },
  "troubleshooting": {
    "description": "Guía rápida para resolver errores comunes - Basado en casos reales",
    "errors": [
      {
        "id": 1,
        "error": "cannot find symbol - method to(String)",
        "type": "Compilación",
        "component": "Get Interaction",
        "cause": "Método Get.to() deprecado en Serenity 4.x",
        "solution": "Cambiar Get.to() por Get.resource()",
        "fix": "// ❌ Incorrecto\nGet.to(endpoint)\n\n// ✅ Correcto\nGet.resource(endpoint)",
        "severity": "CRÍTICO"
      },
      {
        "id": 2,
        "error": "cannot find symbol: class CucumberSerenityRunner",
        "type": "Compilación",
        "component": "MainRunner",
        "cause": "Clase deprecada en Serenity 4.x",
        "solution": "Cambiar a CucumberWithSerenity",
        "fix": "// ❌ Incorrecto\nimport net.serenitybdd.cucumber.CucumberSerenityRunner;\n@RunWith(CucumberSerenityRunner.class)\n\n// ✅ Correcto\nimport net.serenitybdd.cucumber.CucumberWithSerenity;\n@RunWith(CucumberWithSerenity.class)",
        "severity": "CRÍTICO"
      },
      {
        "id": 3,
        "error": "java.lang.NoSuchMethodException: com.example.tasks.TaskName$ByteBuddy.<init>()",
        "type": "Runtime",
        "component": "Task/Interaction",
        "cause": "Constructor privado o uso de 'new' en lugar de instrumented()",
        "solution": "Constructor público + usar Tasks.instrumented()",
        "fix": "// ❌ Incorrecto\nprivate GetAllCharacters() {}\npublic static GetAllCharacters fromApi() {\n    return new GetAllCharacters();\n}\n\n// ✅ Correcto\nimport static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic GetAllCharacters() {}  // Constructor público\npublic static GetAllCharacters fromApi() {\n    return instrumented(GetAllCharacters.class);\n}",
        "severity": "CRÍTICO",
        "relatedError": "ByteBuddy no puede crear proxy de la clase"
      },
      {
        "id": 4,
        "error": "java.lang.NullPointerException: Cannot invoke Object.getClass() because object is null",
        "type": "Runtime",
        "component": "Actor/StepDefinitions",
        "cause": "Actor sin habilidad CallAnApi configurada",
        "solution": "Configurar CallAnApi en el actor usando OnStage pattern",
        "fix": "// ❌ Incorrecto - NO crear actores con Actor.named()\nprivate Actor actor = Actor.named(\"Usuario\");\nactor.attemptsTo(GetRequest.to(\"/endpoint\"));\n\n// ❌ Incorrecto - NO poner @Before en StepDefinitions\n@Before\npublic void setTheStage() {\n    OnStage.setTheStage(new OnlineCast());\n}\n\n// ✅ Correcto - Crear clase Hooks SEPARADA\npackage com.screenplay.api.hooks;\n\nimport io.cucumber.java.Before;\nimport io.cucumber.java.After;\nimport net.serenitybdd.screenplay.actors.OnStage;\nimport net.serenitybdd.screenplay.actors.OnlineCast;\n\npublic class Hooks {\n    @Before(order = 0)\n    public void setTheStage() {\n        OnStage.setTheStage(new OnlineCast());\n    }\n    \n    @After(order = 1)\n    public void tearDown() {\n        OnStage.drawTheCurtain();\n    }\n}\n\n// ✅ Correcto - StepDefinitions solo usan OnStage methods\npackage com.screenplay.api.stepdefinitions;\n\nimport static net.serenitybdd.screenplay.actors.OnStage.*;\n\npublic class UserStepDefinitions {\n    @When(\"el usuario consulta\")\n    public void consultar() {\n        theActorCalled(\"Usuario\")\n            .whoCan(CallAnApi.at(BASE_URL))\n            .attemptsTo(GetRequest.to(\"/endpoint\"));\n    }\n}",
        "severity": "CRÍTICO",
        "additionalInfo": "También puede ocurrir si el constructor es privado"
      },
      {
        "id": 5,
        "error": "UnrecognizedPropertyException: Unrecognized field",
        "type": "Runtime - Deserialización",
        "component": "Model",
        "cause": "Falta @JsonIgnoreProperties en modelo",
        "solution": "Agregar anotación al modelo",
        "fix": "// ❌ Incorrecto\npublic class UserResponse {\n    private String name;\n}\n\n// ✅ Correcto\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class UserResponse {\n    private String name;\n}",
        "severity": "MEDIO"
      },
      {
        "id": 6,
        "error": "AssertionError: Expected status 201 but was 200",
        "type": "Assertion",
        "component": "Question/Validation",
        "cause": "Status code incorrecto para operación GET",
        "solution": "Usar 200 para GET, 201 para POST",
        "fix": "# ❌ Incorrecto\nCuando el usuario consulta todos los personajes\nEntonces la respuesta debe ser 201\n\n# ✅ Correcto\nCuando el usuario consulta todos los personajes\nEntonces la respuesta debe ser 200",
        "severity": "BAJO",
        "reference": "Ver httpStatusCodes section"
      },
      {
        "id": 7,
        "error": "no suitable method found for seeThat(()->net.serenitybdd.rest.SerenityRest.lastResponse().statusCode(),Matcher<Integer>)",
        "type": "Compilación",
        "component": "StepDefinitions",
        "cause": "Usar lambda expressions con seeThat() en lugar de Question implementations",
        "solution": "SIEMPRE usar Question implementación, NUNCA lambdas. Incluir descripción como primer parámetro.",
        "fix": "// ❌ INCORRECTO - Lambda expression NO funciona con seeThat()\ntheActorInTheSpotlight().should(\n    seeThat(() -> SerenityRest.lastResponse().statusCode(), is(200))\n);\n\n// ❌ INCORRECTO - Sin descripción (causa problemas de inferencia de tipos)\ntheActorInTheSpotlight().should(\n    seeThat(ResponseStatusCode.value(), equalTo(200))\n);\n\n// ✅ CORRECTO - Question implementation + descripción\ntheActorInTheSpotlight().should(\n    seeThat(\"El código de respuesta\", ResponseStatusCode.value(), equalTo(200))\n);\n\n// Implementación de Question:\npublic class ResponseStatusCode implements Question<Integer> {\n    @Override\n    public Integer answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().statusCode();\n    }\n    \n    public static ResponseStatusCode value() {\n        return new ResponseStatusCode();\n    }\n}",
        "severity": "CRÍTICO",
        "additionalInfo": "Java no puede inferir tipos de lambdas para el método seeThat(). La descripción ayuda con la inferencia y mejora los reportes.",
        "relatedErrors": [
          "cannot infer type-variable(s)",
          "argument mismatch; incompatible parameter types in lambda expression",
          "method GivenWhenThen.seeThat not applicable"
        ]
      }
    ],
    "checklist": [
      "✓ Runner usa CucumberWithSerenity (no CucumberSerenityRunner)",
      "✓ Usar Get.resource() en vez de Get.to() para peticiones GET",
      "✓ Tasks/Interactions tienen constructor público (sin 'private')",
      "✓ Factory methods usan Tasks.instrumented() (NO usar 'new')",
      "✓ Actor configurado con CallAnApi.at(BASE_URL)",
      "✓ Step Definitions usan OnStage pattern (theActorCalled/theActorInTheSpotlight)",
      "✓ Existe clase Hooks SEPARADA con @Before para OnStage.setTheStage()",
      "✓ StepDefinitions NO tienen @Before ni @After - solo métodos de steps",
      "✓ Modelos tienen @JsonIgnoreProperties(ignoreUnknown = true)",
      "✓ Status codes correctos (GET=200, POST=201, DELETE=204)",
      "✓ Anotación @Step en Tasks/Interactions (opcional pero recomendada)",
      "✓ seeThat() SIEMPRE con 3 parámetros: descripción, Question, matcher",
      "✓ NUNCA usar lambdas con seeThat() - solo Question implementations",
      "✓ Usar equalTo() para Integer/String, is() solo para Boolean"
    ],
    "realWorldCasesFixed": {
      "description": "Errores reales encontrados durante implementación HU-001 (Rick and Morty API)",
      "project": "rickandmorty-api-automation",
      "totalErrors": 4,
      "errorsSummary": [
        "Error #1: Get.to() → Get.resource() (Método deprecado)",
        "Error #2: CucumberSerenityRunner → CucumberWithSerenity (Clase deprecada)",
        "Error #3: new Task() → instrumented() (Instanciación incorrecta)",
        "Error #4: Actor sin CallAnApi (Habilidad faltante)"
      ],
      "result": "BUILD SUCCESSFUL - Todos los errores corregidos aplicando este estándar",
      "testsPassed": true
    }
  },
  "gherkinStandards": {
    "description": "Estándares para escribir escenarios Gherkin modulares y descriptivos según el tipo de HU",
    "version": "1.1.0",
    "philosophy": {
      "modularByDefault": "Los escenarios DEBEN ser modulares por defecto para favorecer reutilización y mantenimiento",
      "descriptiveWhenRequired": "Usar escenarios descriptivos solo cuando la HU específicamente lo requiera para comunicación con negocio",
      "businessReadable": "Los escenarios deben ser legibles para negocio, pero técnicamente ejecutables"
    },
    "scenarioTypes": {
      "modularScenarios": {
        "description": "Escenarios modulares enfocados en acciones técnicas reutilizables",
        "whenToUse": [
          "HU técnicas con operaciones CRUD estándar",
          "APIs con comportamientos repetitivos",
          "Testing de integración y contrato",
          "Automatización de regression"
        ],
        "characteristics": [
          "Acciones técnicas claras (GET, POST, PUT, DELETE)",
          "Validaciones específicas (status codes, campos)",
          "Parámetros data-driven con Examples",
          "Reutilizables entre diferentes HU"
        ],
        "patterns": {
          "getOperation": {
            "template": "Feature: Consulta de recursos API\n\n  @HU-001 @api\n  Scenario Outline: Consultar <recurso> por <parametro>\n    Given el servicio de <API> está disponible\n    When envío una petición GET a \"<endpoint>\" con parámetro \"<parametro>\" = \"<valor>\"\n    Then el código de respuesta debe ser <status>\n    And el body debe contener el campo \"<campo>\" con valor \"<valorEsperado>\"\n\n    Examples:\n      | recurso | parametro | valor | endpoint | status | campo | valorEsperado |\n      | usuario | id       | 1     | /users   | 200    | name  | John Doe      |",
            "benefits": [
              "Reutilizable para diferentes recursos",
              "Data-driven con Examples table",
              "Parámetros configurables",
              "Fácil mantenimiento"
            ]
          },
          "createOperation": {
            "template": "Feature: Creación de recursos API\n\n  @HU-002 @api\n  Scenario Outline: Crear <recurso> con datos válidos\n    Given el servicio de <API> está disponible\n    When envío una petición POST a \"<endpoint>\" con body:\n      \"\"\"\n      <json_template>\n      \"\"\"\n    Then el código de respuesta debe ser <status>\n    And el body debe contener el campo \"id\" generado\n    And el campo \"<campo>\" debe ser \"<valor>\"\n\n    Examples:\n      | recurso | endpoint | status | json_template | campo | valor |\n      | usuario | /users   | 201    | {\"name\":\"John\"} | name | John |",
            "benefits": [
              "Plantillas JSON reutilizables",
              "Validación de campos requeridos",
              "Idempotencia verificada"
            ]
          },
          "updateOperation": {
            "template": "Feature: Actualización de recursos API\n\n  @HU-003 @api\n  Scenario Outline: Actualizar <recurso> existente\n    Given existe un <recurso> con id <id>\n    When envío una petición PUT a \"<endpoint>/<id>\" con body:\n      \"\"\"\n      <json_update>\n      \"\"\"\n    Then el código de respuesta debe ser <status>\n    And el campo \"<campo>\" debe ser \"<valor_actualizado>\"\n\n    Examples:\n      | recurso | id | endpoint | status | json_update | campo | valor_actualizado |\n      | usuario | 1  | /users   | 200    | {\"name\":\"Jane\"} | name | Jane |",
            "benefits": [
              "Precondiciones claras (Given existe...)",
              "Validación de estado final",
              "Pruebas de modificación"
            ]
          },
          "deleteOperation": {
            "template": "Feature: Eliminación de recursos API\n\n  @HU-004 @api\n  Scenario Outline: Eliminar <recurso> existente\n    Given existe un <recurso> con id <id>\n    When envío una petición DELETE a \"<endpoint>/<id>\"\n    Then el código de respuesta debe ser <status>\n    And al consultar GET \"<endpoint>/<id>\" obtengo status <status_get>\n\n    Examples:\n      | recurso | id | endpoint | status | status_get |\n      | usuario | 1  | /users   | 204    | 404        |",
            "benefits": [
              "Validación de eliminación efectiva",
              "Verificación de idempotencia",
              "Pruebas de integridad"
            ]
          }
        }
      },
      "descriptiveScenarios": {
        "description": "Escenarios descriptivos enfocados en valor de negocio y legibilidad",
        "whenToUse": [
          "HU de negocio complejas",
          "Casos de uso específicos del negocio",
          "Documentación viva para stakeholders",
          "HU que requieren explicación detallada del flujo"
        ],
        "characteristics": [
          "Lenguaje de negocio natural",
          "Flujos completos end-to-end",
          "Menos parámetros técnicos",
          "Enfocados en valor de negocio"
        ],
        "patterns": {
          "businessWorkflow": {
            "template": "Feature: Gestión de pedidos de cliente\n\n  @HU-010 @business\n  Scenario: Cliente completa compra exitosamente\n    Given Juan es un cliente registrado en la plataforma\n    And tiene productos en su carrito de compras\n    When completa el proceso de checkout\n    And proporciona información de pago válida\n    And confirma la orden\n    Then debe recibir confirmación de la orden\n    And debe recibir un email con los detalles de la compra\n    And el inventario debe actualizarse correctamente",
            "benefits": [
              "Lenguaje natural del negocio",
              "Flujo completo visible",
              "Ideal para documentación",
              "Fácil comprensión por stakeholders"
            ]
          },
          "errorHandling": {
            "template": "Feature: Manejo de errores en autenticación\n\n  @HU-015 @error-handling\n  Scenario: Usuario intenta login con credenciales inválidas\n    Given María intenta acceder al sistema\n    When ingresa un usuario válido pero contraseña incorrecta\n    And hace clic en el botón de login\n    Then debe ver un mensaje de error \"Usuario o contraseña incorrectos\"\n    And debe permanecer en la página de login\n    And no debe tener acceso al sistema",
            "benefits": [
              "Casos de error documentados",
              "Comportamiento esperado claro",
              "Validación de UX en errores"
            ]
          },
          "integrationScenario": {
            "template": "Feature: Integración con pasarela de pagos\n\n  @HU-020 @integration\n  Scenario: Procesamiento exitoso de pago\n    Given el sistema de pagos está disponible\n    And un cliente ha seleccionado productos\n    When inicia el proceso de pago con tarjeta de crédito\n    And la pasarela procesa la transacción\n    Then debe recibir confirmación de pago aprobado\n    And el estado del pedido debe cambiar a \"Pagado\"\n    And debe generarse recibo de compra",
            "benefits": [
              "Integraciones críticas documentadas",
              "Flujos cross-system visibles",
              "Validación de contratos de integración"
            ]
          }
        }
      }
    },
    "gherkinBestPractices": {
      "structure": {
        "feature": {
          "rules": [
            "Una Feature por HU o conjunto de HU relacionadas",
            "Nombre descriptivo en imperativo (Gestión de..., Consulta de...)",
            "Descripción opcional pero recomendada",
            "Tags: @HU-XXX, @api/@web, @smoke/@regression"
          ],
          "template": "Feature: <Nombre descriptivo de la funcionalidad>\n\n  Como <rol>\n  Quiero <funcionalidad>\n  Para <beneficio>\n\n  @HU-XXX @<tipo>\n  Scenario: <Descripción del escenario>"
        },
        "scenario": {
          "rules": [
            "Nombre descriptivo que explique qué hace",
            "Estructura Given-When-Then clara",
            "Background para pasos comunes",
            "Scenario Outline para data-driven",
            "Tags específicos del escenario"
          ],
          "maxLength": "Máximo 3 líneas por step para mantener legibilidad"
        }
      },
      "stepPatterns": {
        "givenPatterns": [
          "Given el servicio está disponible",
          "Given existe un <recurso> con <propiedad>",
          "Given el usuario está autenticado como <rol>",
          "Given tengo acceso a <sistema/funcionalidad>"
        ],
        "whenPatterns": [
          "When envío una petición <METHOD> a \"<endpoint>\"",
          "When completo el formulario con datos válidos",
          "When realizo la acción \"<acción>\"",
          "When ejecuto la operación <operación>"
        ],
        "thenPatterns": [
          "Then el código de respuesta debe ser <status>",
          "Then el body debe contener <campo> = \"<valor>\"",
          "Then debe mostrar el mensaje \"<mensaje>\"",
          "Then el sistema debe <acción esperada>"
        ]
      },
      "dataDriven": {
        "whenToUse": [
          "Múltiples combinaciones de datos",
          "Validación de edge cases",
          "Pruebas de compatibilidad",
          "Regresión con diferentes inputs"
        ],
        "examplesTemplate": "Examples:\n  | parametro1 | parametro2 | resultadoEsperado |\n  | valor1     | valor2     | esperado1          |\n  | valor3     | valor4     | esperado2          |",
        "bestPractices": [
          "Nombres descriptivos en headers",
          "Valores representativos del negocio",
          "Incluir casos positivos y negativos",
          "No más de 5-7 columnas por tabla"
        ]
      },
      "tagsStrategy": {
        "featureLevel": [
          "@HU-XXX - Identificador único de HU",
          "@api/@web - Tipo de automatización",
          "@smoke/@regression - Nivel de prueba",
          "@manual - Solo pruebas manuales",
          "@deprecated - HU obsoleta"
        ],
        "scenarioLevel": [
          "@happy-path - Flujo principal exitoso",
          "@negative - Casos de error",
          "@edge-case - Casos límite",
          "@integration - Pruebas de integración",
          "@performance - Pruebas de performance"
        ],
        "executionTags": [
          "@smokeTest - Ejecución rápida diaria",
          "@fullRegression - Suite completa",
          "@critical - HU críticas para negocio",
          "@blocked - HU bloqueada por dependencias"
        ]
      }
    },
    "modularVsDescriptive": {
      "decisionMatrix": {
        "chooseModularWhen": [
          "HU es técnica y reutilizable",
          "Operaciones CRUD estándar",
          "API testing puro",
          "Necesitas data-driven testing",
          "Mantenimiento técnico frecuente"
        ],
        "chooseDescriptiveWhen": [
          "HU es de negocio crítico",
          "Necesitas documentación viva",
          "Stakeholders requieren legibilidad",
          "Flujo end-to-end complejo",
          "Comunicación con negocio no técnico"
        ],
        "hybridApproach": "Usar modular para la implementación técnica y descriptive para casos de negocio específicos"
      },
      "migrationGuide": {
        "fromDescriptiveToModular": {
          "steps": [
            "Identificar patrones repetitivos en escenarios",
            "Extraer acciones comunes a step definitions reutilizables",
            "Convertir datos hardcodeados en parámetros",
            "Crear Examples tables para variaciones",
            "Documentar el patrón para reutilización futura"
          ],
          "benefits": "Reducción de duplicación, mejor mantenimiento, ejecución más rápida"
        },
        "fromModularToDescriptive": {
          "steps": [
            "Traducir términos técnicos a lenguaje de negocio",
            "Agregar contexto del flujo completo",
            "Incluir precondiciones y postcondiciones de negocio",
            "Documentar el valor de negocio entregado",
            "Agregar explicaciones para stakeholders no técnicos"
          ],
          "benefits": "Mejor comunicación, documentación viva, alineación con negocio"
        }
      }
    },
    "validationRules": {
      "syntaxValidation": [
        "Feature debe tener nombre descriptivo",
        "Scenario debe tener Given-When-Then",
        "Steps deben ser imperativos (no 'I should see')",
        "Tags deben seguir convención @HU-XXX",
        "Examples tables deben tener headers descriptivos"
      ],
      "businessValidation": [
        "Escenario debe representar valor de negocio real",
        "Precondiciones deben ser verificables",
        "Validaciones deben ser observables por usuario",
        "Flujo debe ser realista y completo"
      ],
      "technicalValidation": [
        "Step definitions deben existir para cada step",
        "Parámetros deben mapear correctamente",
        "Examples data debe ser válida",
        "Tags deben estar configurados en runners"
      ]
    },
    "commonPitfalls": [
      {
        "problem": "Steps demasiado técnicos",
        "solution": "Usar lenguaje de negocio en Given/When/Then",
        "example": "❌ When envío petición GET\n✅ When consulto la información del usuario"
      },
      {
        "problem": "Escenarios demasiado largos",
        "solution": "Dividir en escenarios más pequeños y enfocados",
        "example": "Un escenario de 15 steps → 3 escenarios de 5 steps cada uno"
      },
      {
        "problem": "Datos hardcodeados",
        "solution": "Usar Examples tables y parámetros",
        "example": "❌ Given usuario con id 123\n✅ Given usuario con id <userId>"
      },
      {
        "problem": "Validaciones UI en API testing",
        "solution": "Enfocarse en respuestas HTTP y datos",
        "example": "❌ Then debe mostrar popup\n✅ Then response status es 201"
      }
    ]
  },
  "commonIssuesAndFixes": {
    "description": "Problemas comunes encontrados en proyectos Serenity BDD y sus soluciones definitivas. Esta sección documenta errores frecuentes que pueden causar que las pruebas no se detecten, no compilen o fallen inesperadamente.",
    "lastUpdated": "2026-02-04",
    "sourceDocument": "Rick and Morty API - Documento de Solución de Problemas",
    "criticalIssues": {
      "testsNotDetected": {
        "symptom": "Tests run: 0 - Las pruebas existen pero el runner no las ejecuta",
        "rootCause": "Incompatibilidad entre JUnit 4 y JUnit 5. El runner está configurado con @RunWith (JUnit 4) pero el pom.xml usa JUnit 5",
        "impact": "CRÍTICO - Las pruebas no se ejecutan en absoluto",
        "solution": {
          "summary": "Actualizar el runner de Cucumber de JUnit 4 a JUnit 5 Platform Suite",
          "before": {
            "file": "src/test/java/.../runners/CucumberTestRunner.java",
            "code": "package co.com.rickandmorty.runners;\n\nimport io.cucumber.junit.CucumberOptions;\nimport net.serenitybdd.cucumber.CucumberWithSerenity;\nimport org.junit.runner.RunWith;\n\n@RunWith(CucumberWithSerenity.class)\n@CucumberOptions(\n    features = \"src/test/resources/features\",\n    glue = {\"co.com.rickandmorty.stepdefinitions\", \"co.com.rickandmorty.hooks\"},\n    plugin = {\"pretty\", \"json:target/cucumber-report.json\"},\n    tags = \"@API-HU-002\"\n)\npublic class CucumberTestRunner {\n    // Runner para ejecutar los features de API\n}",
            "issues": [
              "@RunWith es de JUnit 4",
              "CucumberWithSerenity.class incompatible con JUnit 5",
              "@CucumberOptions no funciona con JUnit Platform"
            ]
          },
          "after": {
            "file": "src/test/java/.../runners/CucumberTestRunner.java",
            "code": "package co.com.rickandmorty.runners;\n\nimport io.cucumber.junit.platform.engine.Constants;\nimport org.junit.platform.suite.api.ConfigurationParameter;\nimport org.junit.platform.suite.api.IncludeEngines;\nimport org.junit.platform.suite.api.SelectClasspathResource;\nimport org.junit.platform.suite.api.Suite;\n\n@Suite\n@IncludeEngines(\"cucumber\")\n@SelectClasspathResource(\"features\")\n@ConfigurationParameter(key = Constants.GLUE_PROPERTY_NAME, value = \"co.com.rickandmorty.stepdefinitions,co.com.rickandmorty.hooks\")\n@ConfigurationParameter(key = Constants.FILTER_TAGS_PROPERTY_NAME, value = \"@API-HU-002\")\n@ConfigurationParameter(key = Constants.PLUGIN_PROPERTY_NAME, value = \"pretty,json:target/cucumber-report.json\")\npublic class CucumberTestRunner {\n    // Runner para ejecutar los features de API\n}",
            "changes": [
              "Eliminado @RunWith(CucumberWithSerenity.class)",
              "Agregado @Suite (JUnit 5)",
              "Agregado @IncludeEngines(\"cucumber\")",
              "Reemplazado @CucumberOptions por @ConfigurationParameter",
              "Cambiado features path de 'src/test/resources/features' a 'features'",
              "Imports actualizados a JUnit Platform Suite API"
            ]
          },
          "requiredDependencies": [
            {
              "groupId": "io.cucumber",
              "artifactId": "cucumber-junit-platform-engine",
              "version": "7.18.0",
              "scope": "test",
              "reason": "Necesaria para ejecutar Cucumber con JUnit 5"
            },
            {
              "groupId": "org.junit.platform",
              "artifactId": "junit-platform-suite",
              "version": "1.9.2",
              "scope": "test",
              "reason": "Necesaria para el @Suite annotation"
            }
          ],
          "verification": [
            "mvn clean compile → BUILD SUCCESS",
            "mvn clean test → Tests run: 1 (o más)",
            "En el output debe aparecer: 'Running ...CucumberTestRunner'",
            "En el output deben aparecer los scenarios ejecutados"
          ]
        }
      },
      "missingMavenPlugins": {
        "symptom": "No se generan reportes de Serenity o las pruebas de integración no se ejecutan",
        "rootCause": "Faltan plugins esenciales de Maven para Serenity BDD",
        "impact": "MEDIO - Las pruebas se ejecutan pero no se generan reportes completos",
        "solution": {
          "summary": "Agregar serenity-maven-plugin y maven-failsafe-plugin al pom.xml",
          "requiredPlugins": [
            {
              "name": "serenity-maven-plugin",
              "purpose": "Genera reportes HTML de Serenity BDD",
              "configuration": {
                "groupId": "net.serenity-bdd.maven.plugins",
                "artifactId": "serenity-maven-plugin",
                "version": "${serenity.version}",
                "executions": {
                  "execution": {
                    "id": "serenity-reports",
                    "phase": "post-integration-test",
                    "goals": [
                      "aggregate"
                    ]
                  }
                }
              },
              "usage": "mvn clean verify → Genera reportes en target/site/serenity/"
            },
            {
              "name": "maven-failsafe-plugin",
              "purpose": "Ejecuta pruebas de integración",
              "configuration": {
                "groupId": "org.apache.maven.plugins",
                "artifactId": "maven-failsafe-plugin",
                "version": "3.0.0",
                "configuration": {
                  "includes": [
                    "**/runners/**/*.java"
                  ],
                  "argLine": "--add-opens java.base/java.lang=ALL-UNNAMED"
                },
                "executions": {
                  "execution": {
                    "goals": [
                      "integration-test",
                      "verify"
                    ]
                  }
                }
              },
              "usage": "mvn clean verify → Ejecuta tests de integración"
            }
          ],
          "pomXmlExample": "<build>\n  <plugins>\n    <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-surefire-plugin</artifactId>\n      <version>3.0.0</version>\n      <configuration>\n        <includes>\n          <include>**/runners/**/*.java</include>\n        </includes>\n        <argLine>--add-opens java.base/java.lang=ALL-UNNAMED</argLine>\n      </configuration>\n    </plugin>\n    <plugin>\n      <groupId>net.serenity-bdd.maven.plugins</groupId>\n      <artifactId>serenity-maven-plugin</artifactId>\n      <version>${serenity.version}</version>\n      <executions>\n        <execution>\n          <id>serenity-reports</id>\n          <phase>post-integration-test</phase>\n          <goals>\n            <goal>aggregate</goal>\n          </goals>\n        </execution>\n      </executions>\n    </plugin>\n    <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-failsafe-plugin</artifactId>\n      <version>3.0.0</version>\n      <configuration>\n        <includes>\n          <include>**/runners/**/*.java</include>\n        </includes>\n        <argLine>--add-opens java.base/java.lang=ALL-UNNAMED</argLine>\n      </configuration>\n      <executions>\n        <execution>\n          <goals>\n            <goal>integration-test</goal>\n            <goal>verify</goal>\n          </goals>\n        </execution>\n      </executions>\n    </plugin>\n  </plugins>\n</build>"
        }
      },
      "incorrectEndpointUrlConstruction": {
        "symptom": "URLs duplicadas o malformadas en las peticiones HTTP",
        "rootCause": "El endpoint incluye la URL base completa cuando el Hook ya la configura con CallAnApi.at()",
        "impact": "ALTO - Las peticiones fallan con URLs incorrectas",
        "solution": {
          "summary": "Los endpoints deben devolver solo el path relativo, NO la URL completa",
          "antipattern": {
            "file": "src/main/java/.../endpoints/PersonajeEndpoints.java",
            "code": "public class PersonajeEndpoints {\n    public static final String BASE_URL = \"https://rickandmortyapi.com\";\n    public static final String CHARACTER_BY_ID = \"/api/character/%d\";\n\n    public static String obtenerPersonajePorId(int id) {\n        return BASE_URL + String.format(CHARACTER_BY_ID, id);\n    }\n}",
            "problem": "BASE_URL se duplica porque el Hook ya configura baseURL con CallAnApi.at()"
          },
          "correctPattern": {
            "file": "src/main/java/.../endpoints/PersonajeEndpoints.java",
            "code": "public class PersonajeEndpoints {\n    public static final String CHARACTER_BY_ID = \"/api/character/%d\";\n\n    public static String obtenerPersonajePorId(int id) {\n        return String.format(CHARACTER_BY_ID, id);\n    }\n}",
            "explanation": [
              "NO incluir BASE_URL en la clase de endpoints",
              "El baseURL se configura en Hooks.java con CallAnApi.at(baseUrl)",
              "Los endpoints solo devuelven el path relativo",
              "Serenity concatena automáticamente baseURL + relativePath"
            ]
          },
          "hooksConfiguration": {
            "file": "src/test/java/.../hooks/Hooks.java",
            "code": "@Before(order = 0)\npublic void configuracionBaseUrl() {\n    OnStage.setTheStage(new OnlineCast());\n    theActorCalled(\"Usuario\");\n    EnvironmentVariables environmentVariables = SystemEnvironmentVariables.currentEnvironmentVariables();\n    String theRestApiBaseUrl = environmentVariables.optionalProperty(\"URL_QA\")\n        .orElse(\"https://rickandmortyapi.com\");\n    theActorInTheSpotlight().whoCan(CallAnApi.at(theRestApiBaseUrl));\n}",
            "explanation": "El Hook configura el baseURL, por eso los endpoints NO deben incluirlo"
          }
        }
      },
      "overlyComplexInteractions": {
        "symptom": "Errores HTTP 403 Forbidden o conflictos con contentType/headers",
        "rootCause": "Interacciones sobrecargadas con configuraciones innecesarias que causan conflictos",
        "impact": "MEDIO - Las peticiones funcionan para algunos endpoints pero fallan para otros",
        "solution": {
          "summary": "Simplificar las interacciones eliminando configuraciones innecesarias",
          "antipattern": {
            "file": "src/main/java/.../interactions/GetRequest.java",
            "code": "public class GetRequest implements Interaction {\n    private final String url;\n\n    public GetRequest(String url) {\n        this.url = url;\n    }\n\n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            Get.resource(url)\n                .with(request -> request.contentType(ContentType.JSON))\n        );\n    }\n\n    public static GetRequest to(String url) {\n        return Tasks.instrumented(GetRequest.class, url);\n    }\n}",
            "problems": [
              "contentType(ContentType.JSON) puede causar conflictos con APIs que no lo requieren",
              "Tasks.instrumented() es innecesario para interacciones simples",
              "Constructor público expone implementación"
            ]
          },
          "correctPattern": {
            "file": "src/main/java/.../interactions/GetRequest.java",
            "code": "public class GetRequest implements Interaction {\n    private final String resource;\n\n    private GetRequest(String resource) {\n        this.resource = resource;\n    }\n\n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(Get.resource(resource));\n    }\n\n    public static Interaction to(String resource) {\n        return new GetRequest(resource);\n    }\n}",
            "improvements": [
              "Constructor privado (mejor práctica de encapsulación)",
              "Eliminado contentType - dejar que Serenity lo maneje",
              "Eliminado Tasks.instrumented() - innecesario",
              "Factory method retorna Interaction (más genérico)",
              "Implementación más simple y robusta"
            ]
          },
          "whenToAddHeaders": {
            "rule": "Solo agregar headers cuando la API explícitamente los requiere",
            "examples": {
              "needed": [
                "Authorization: Bearer token",
                "X-API-Key: apikey123",
                "Custom-Header requerido por la API"
              ],
              "notNeeded": [
                "Content-Type (Serenity lo maneja automáticamente)",
                "Accept (generalmente innecesario)",
                "User-Agent (puede causar bloqueos)"
              ]
            }
          }
        }
      },
      "loggingAndDebugging": {
        "symptom": "Difícil debuggear problemas porque no hay visibilidad de las peticiones/respuestas",
        "rootCause": "Logging deshabilitado o configurado en modo QUIET",
        "impact": "BAJO - No afecta funcionalidad pero dificulta troubleshooting",
        "solution": {
          "summary": "Configurar logging verbose en serenity.properties para desarrollo/debugging",
          "serenityPropertiesRecommended": {
            "file": "serenity.properties",
            "configuration": "serenity.project.name=co.com.rickandmorty.api\nserenity.test.root=net.serenitybdd.junit5\nwebdriver.driver=chrome\nserenity.take.screenshots=FOR_FAILURES\nserenity.reports.show.step.details=true\nserenity.console.headings=normal\nserenity.logging=VERBOSE\nrestassured.log=ALL\nURL_QA=http://localhost:8080/api",
            "keySettings": {
              "serenity.logging": {
                "development": "VERBOSE",
                "production": "NORMAL",
                "ci": "QUIET"
              },
              "restassured.log": {
                "development": "ALL",
                "production": "NONE",
                "explanation": "Muestra todas las peticiones y respuestas HTTP"
              }
            }
          },
          "debuggingInStepDefinitions": {
            "description": "Agregar debug temporal en step definitions para ver request/response",
            "example": "@Cuando(\"envío una petición GET a {int}\")\npublic void envioUnaPeticionGETA(int id) {\n    this.id = id;\n    OnStage.theActorInTheSpotlight().attemptsTo(\n        ObtenerInformacionDeUnPersonaje.conId(id)\n    );\n    // Debug temporal - eliminar después\n    System.out.println(\"=== DEBUG ===\");\n    System.out.println(\"URL: \" + SerenityRest.lastResponse().then().extract().request().getURI());\n    System.out.println(\"Status: \" + SerenityRest.lastResponse().statusCode());\n    System.out.println(\"Body: \" + SerenityRest.lastResponse().body().asString());\n    System.out.println(\"=============\");\n}",
            "warning": "Eliminar código de debug antes de commit final"
          }
        }
      }
    },
    "dependenciesReference": {
      "description": "Dependencias correctas para Serenity BDD + Cucumber + JUnit 4 (REQUERIDO para @RunWith)",
      "criticalNote": "⚠️ IMPORTANTE: JUnit 4.13.2 es OBLIGATORIO para usar @RunWith(CucumberWithSerenity.class). JUnit 5 NO soporta @RunWith.",
      "minimumRequired": {
        "serenity": [
          {
            "groupId": "net.serenity-bdd",
            "artifactId": "serenity-core",
            "version": "4.3.4",
            "required": true,
            "criticalForDiagnostic": true,
            "reason": "Core framework de Serenity BDD"
          },
          {
            "groupId": "net.serenity-bdd",
            "artifactId": "serenity-cucumber",
            "version": "4.3.4",
            "required": true,
            "criticalForDiagnostic": true,
            "reason": "Integración con Cucumber para BDD"
          },
          {
            "groupId": "net.serenity-bdd",
            "artifactId": "serenity-rest-assured",
            "version": "4.3.4",
            "required": true,
            "criticalForDiagnostic": true,
            "scope": "API projects only",
            "reason": "Soporte para pruebas de API REST"
          },
          {
            "groupId": "net.serenity-bdd",
            "artifactId": "serenity-screenplay",
            "version": "4.3.4",
            "required": true,
            "reason": "Patrón Screenplay (Actor, Task, Question)"
          },
          {
            "groupId": "net.serenity-bdd",
            "artifactId": "serenity-screenplay-rest",
            "version": "4.3.4",
            "required": true,
            "criticalForDiagnostic": true,
            "scope": "API projects only",
            "reason": "Screenplay REST capabilities (CallAnApi, etc)"
          }
        ],
        "cucumber": [
          {
            "groupId": "io.cucumber",
            "artifactId": "cucumber-java",
            "version": "7.18.0",
            "required": true,
            "reason": "Lenguaje Java para step definitions"
          }
        ],
        "junit4": [
          {
            "groupId": "junit",
            "artifactId": "junit",
            "version": "4.13.2",
            "scope": "test",
            "required": true,
            "criticalForDiagnostic": true,
            "reason": "CRÍTICO: Requerido para @RunWith(CucumberWithSerenity.class). JUnit 5 NO soporta @RunWith.",
            "mustHave": true
          }
        ],
        "restAssured": [
          {
            "groupId": "io.rest-assured",
            "artifactId": "rest-assured",
            "version": "5.3.0",
            "required": true,
            "scope": "API projects only",
            "reason": "Cliente HTTP para pruebas de API"
          }
        ]
      },
      "versionCompatibility": {
        "serenityVersion": "4.3.4",
        "cucumberVersion": "7.18.0",
        "junit4Version": "4.13.2",
        "restAssuredVersion": "5.3.0",
        "warning": "⚠️ USAR JUnit 4.13.2 (NO JUnit 5) para compatibilidad con @RunWith(CucumberWithSerenity.class)"
      },
      "mavenExample": "<properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <serenity.version>4.3.4</serenity.version>\n    <cucumber.version>7.18.0</cucumber.version>\n    <junit4.version>4.13.2</junit4.version>\n</properties>\n\n<dependencies>\n    <!-- Serenity BDD Core -->\n    <dependency>\n        <groupId>net.serenity-bdd</groupId>\n        <artifactId>serenity-core</artifactId>\n        <version>${serenity.version}</version>\n        <scope>test</scope>\n    </dependency>\n    \n    <!-- Serenity Cucumber Integration -->\n    <dependency>\n        <groupId>net.serenity-bdd</groupId>\n        <artifactId>serenity-cucumber</artifactId>\n        <version>${serenity.version}</version>\n        <scope>test</scope>\n    </dependency>\n    \n    <!-- Serenity Screenplay -->\n    <dependency>\n        <groupId>net.serenity-bdd</groupId>\n        <artifactId>serenity-screenplay</artifactId>\n        <version>${serenity.version}</version>\n        <scope>test</scope>\n    </dependency>\n    \n    <!-- Serenity REST Assured (API Testing) -->\n    <dependency>\n        <groupId>net.serenity-bdd</groupId>\n        <artifactId>serenity-rest-assured</artifactId>\n        <version>${serenity.version}</version>\n        <scope>test</scope>\n    </dependency>\n    \n    <!-- Serenity Screenplay REST -->\n    <dependency>\n        <groupId>net.serenity-bdd</groupId>\n        <artifactId>serenity-screenplay-rest</artifactId>\n        <version>${serenity.version}</version>\n        <scope>test</scope>\n    </dependency>\n    \n    <!-- Cucumber Java -->\n    <dependency>\n        <groupId>io.cucumber</groupId>\n        <artifactId>cucumber-java</artifactId>\n        <version>${cucumber.version}</version>\n        <scope>test</scope>\n    </dependency>\n    \n    <!-- JUnit 4 - CRÍTICO para @RunWith -->\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>${junit4.version}</version>\n        <scope>test</scope>\n    </dependency>\n    \n    <!-- REST Assured -->\n    <dependency>\n        <groupId>io.rest-assured</groupId>\n        <artifactId>rest-assured</artifactId>\n        <version>5.3.0</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>",
      "gradleExample": "ext {\n    serenityVersion = '4.3.4'\n    cucumberVersion = '7.18.0'\n    junit4Version = '4.13.2'\n    restAssuredVersion = '5.3.0'\n}\n\ndependencies {\n    // Serenity BDD Core\n    testImplementation \"net.serenity-bdd:serenity-core:${serenityVersion}\"\n    \n    // Serenity Cucumber Integration\n    testImplementation \"net.serenity-bdd:serenity-cucumber:${serenityVersion}\"\n    \n    // Serenity Screenplay\n    testImplementation \"net.serenity-bdd:serenity-screenplay:${serenityVersion}\"\n    \n    // Serenity REST Assured (API Testing)\n    testImplementation \"net.serenity-bdd:serenity-rest-assured:${serenityVersion}\"\n    \n    // Serenity Screenplay REST\n    testImplementation \"net.serenity-bdd:serenity-screenplay-rest:${serenityVersion}\"\n    \n    // Cucumber Java\n    testImplementation \"io.cucumber:cucumber-java:${cucumberVersion}\"\n    \n    // JUnit 4 - CRÍTICO para @RunWith\n    testImplementation \"junit:junit:${junit4Version}\"\n    \n    // REST Assured\n    testImplementation \"io.rest-assured:rest-assured:${restAssuredVersion}\"\n}"
    },
    "mavenCommandsReference": {
      "description": "Comandos Maven esenciales para trabajar con Serenity BDD",
      "commands": [
        {
          "command": "mvn clean compile",
          "purpose": "Compilar el proyecto",
          "when": "Después de cambios en código fuente",
          "expectedOutput": "BUILD SUCCESS"
        },
        {
          "command": "mvn clean test",
          "purpose": "Ejecutar solo pruebas unitarias",
          "when": "Desarrollo rápido, verificar que tests se detectan",
          "expectedOutput": "Tests run: X, Failures: Y"
        },
        {
          "command": "mvn clean verify",
          "purpose": "Ejecutar pruebas de integración y generar reportes Serenity",
          "when": "Antes de commit, para reportes completos",
          "expectedOutput": "BUILD SUCCESS + reportes en target/site/serenity/"
        },
        {
          "command": "mvn serenity:aggregate",
          "purpose": "Generar solo reportes Serenity (sin ejecutar tests)",
          "when": "Ya ejecutaste tests y solo quieres regenerar reportes",
          "expectedOutput": "Reportes actualizados en target/site/serenity/"
        },
        {
          "command": "mvn clean test -Dcucumber.filter.tags=\"@API-HU-001\"",
          "purpose": "Ejecutar solo tests con tag específico",
          "when": "Quieres ejecutar una HU específica",
          "expectedOutput": "Solo scenarios con ese tag se ejecutan"
        },
        {
          "command": "mvn clean test -Dserenity.verbose=true",
          "purpose": "Ejecutar con logging verbose",
          "when": "Debugging de problemas",
          "expectedOutput": "Output detallado de Serenity y REST Assured"
        }
      ],
      "troubleshootingCommands": [
        {
          "problem": "Tests run: 0",
          "commands": [
            "mvn clean test -X",
            "Verificar que el runner use JUnit 5 (@Suite)",
            "Verificar que existan las dependencias JUnit 5"
          ]
        },
        {
          "problem": "No se generan reportes",
          "commands": [
            "mvn clean verify",
            "Verificar que existe serenity-maven-plugin en pom.xml",
            "Verificar target/site/serenity/"
          ]
        }
      ]
    },
    "projectStructureReference": {
      "description": "Estructura correcta para proyectos Serenity Screenplay API",
      "structure": "co.com.{company}.api/\n├── pom.xml\n├── serenity.properties\n├── src/\n│   ├── main/java/co/com/{company}/\n│   │   ├── endpoints/\n│   │   │   └── {Resource}Endpoints.java\n│   │   ├── interactions/\n│   │   │   ├── GetRequest.java\n│   │   │   ├── PostRequest.java\n│   │   │   ├── PutRequest.java\n│   │   │   └── DeleteRequest.java\n│   │   ├── models/\n│   │   │   ├── {Resource}Request.java\n│   │   │   └── {Resource}Response.java\n│   │   ├── questions/\n│   │   │   ├── ResponseStatusCode.java\n│   │   │   └── ResponseField.java\n│   │   ├── tasks/\n│   │   │   └── {BusinessAction}.java\n│   │   └── builders/\n│   │       └── {Resource}RequestBuilder.java\n│   └── test/\n│       ├── java/co/com/{company}/\n│       │   ├── hooks/\n│       │   │   └── Hooks.java\n│       │   ├── runners/\n│       │   │   └── CucumberTestRunner.java (JUnit 5!)\n│       │   └── stepdefinitions/\n│       │       └── {Resource}StepDefinitions.java\n│       └── resources/\n│           └── features/\n│               └── {resource}.feature",
      "criticalFiles": {
        "CucumberTestRunner.java": {
          "location": "src/test/java/.../runners/",
          "mustUse": "JUnit 5 Platform Suite (@Suite, @IncludeEngines)",
          "mustNotUse": "JUnit 4 (@RunWith)"
        },
        "Hooks.java": {
          "location": "src/test/java/.../hooks/",
          "purpose": "Configurar baseURL con CallAnApi.at()",
          "mustHave": "@Before para OnStage setup"
        },
        "pom.xml": {
          "mustHave": [
            "serenity-cucumber dependency",
            "cucumber-junit-platform-engine dependency",
            "junit-platform-suite dependency",
            "serenity-maven-plugin",
            "maven-failsafe-plugin"
          ]
        },
        "serenity.properties": {
          "mustHave": [
            "serenity.project.name",
            "serenity.test.root=net.serenitybdd.junit5",
            "URL_QA (o variable de ambiente para baseURL)"
          ]
        }
      }
    },
    "checklistBeforeDeployment": {
      "description": "Checklist para verificar que un proyecto está correctamente configurado",
      "items": [
        {
          "category": "Runner Configuration",
          "checks": [
            "✓ Runner usa @Suite (JUnit 5) NO @RunWith (JUnit 4)",
            "✓ Runner tiene @IncludeEngines(\"cucumber\")",
            "✓ Features path es 'features' NO 'src/test/resources/features'",
            "✓ Glue packages están correctos",
            "✓ Tags están configurados si es necesario"
          ]
        },
        {
          "category": "Dependencies",
          "checks": [
            "✓ cucumber-junit-platform-engine está en pom.xml",
            "✓ junit-platform-suite está en pom.xml",
            "✓ NO hay dependencias de JUnit 4 (junit:junit:4.x)",
            "✓ Versiones de Serenity son consistentes (usar ${serenity.version})"
          ]
        },
        {
          "category": "Maven Plugins",
          "checks": [
            "✓ maven-surefire-plugin configurado",
            "✓ serenity-maven-plugin agregado",
            "✓ maven-failsafe-plugin agregado"
          ]
        },
        {
          "category": "Endpoints",
          "checks": [
            "✓ Endpoints devuelven paths relativos (NO URLs completas)",
            "✓ Hook configura baseURL con CallAnApi.at()",
            "✓ No hay duplicación de BASE_URL"
          ]
        },
        {
          "category": "Interactions",
          "checks": [
            "✓ Interacciones son simples (no sobrecargadas)",
            "✓ No hay contentType innecesarios",
            "✓ Constructor es privado",
            "✓ Factory method retorna Interaction"
          ]
        },
        {
          "category": "Compilation & Execution",
          "checks": [
            "✓ mvn clean compile → BUILD SUCCESS",
            "✓ mvn clean test → Tests run > 0",
            "✓ mvn clean verify → Genera reportes en target/site/serenity/",
            "✓ Tests se detectan y ejecutan correctamente"
          ]
        }
      ]
    },
    "quickReferenceCard": {
      "description": "Tarjeta de referencia rápida para problemas comunes",
      "problems": [
        {
          "symptom": "Tests run: 0",
          "quickFix": "Runner debe usar @Suite (JUnit 5) NO @RunWith. Agregar cucumber-junit-platform-engine y junit-platform-suite al pom.xml"
        },
        {
          "symptom": "No se generan reportes Serenity",
          "quickFix": "Agregar serenity-maven-plugin al pom.xml y ejecutar 'mvn clean verify'"
        },
        {
          "symptom": "URL duplicada o malformada",
          "quickFix": "Endpoints deben devolver solo path relativo. Hook configura baseURL con CallAnApi.at()"
        },
        {
          "symptom": "HTTP 403 Forbidden",
          "quickFix": "Simplificar interacción: eliminar contentType y headers innecesarios. Usar solo Get.resource(endpoint)"
        },
        {
          "symptom": "Cannot find symbol @RunWith",
          "quickFix": "Estás mezclando JUnit 4 y 5. Usar @Suite en lugar de @RunWith"
        },
        {
          "symptom": "No tests were found",
          "quickFix": "Verificar que features path sea 'features' NO 'src/test/resources/features' en JUnit 5"
        }
      ]
    }
  },
  "dependencies": {
    "description": "Dependencias obligatorias para proyectos Serenity Screenplay API",
    "framework": "Serenity BDD 4.3.4",
    "testRunner": "JUnit 4.13.2 (OBLIGATORIO para @RunWith)",
    "bddTool": "Cucumber 7.18.0",
    "criticalDependencies": [
      {
        "name": "Serenity BDD 4.3.4",
        "artifacts": [
          "serenity-core",
          "serenity-cucumber",
          "serenity-rest-assured",
          "serenity-screenplay",
          "serenity-screenplay-rest"
        ],
        "criticalForDiagnostic": true
      },
      {
        "name": "JUnit 4.13.2",
        "artifact": "junit:junit",
        "criticalForDiagnostic": true,
        "reason": "OBLIGATORIO para @RunWith(CucumberWithSerenity.class)"
      },
      {
        "name": "Cucumber 7.18.0",
        "artifact": "cucumber-java",
        "criticalForDiagnostic": false
      },
      {
        "name": "REST Assured 5.3.0",
        "artifact": "rest-assured",
        "criticalForDiagnostic": false
      }
    ],
    "diagnosticChecklist": {
      "description": "Validaciones que realiza la herramienta de diagnóstico",
      "checks": [
        "✅ Serenity BDD 4.3.4 está configurado",
        "✅ JUnit 4.13.2 está configurado",
        "✅ serenity-cucumber está configurado",
        "✅ serenity-rest-assured está configurado",
        "✅ serenity-screenplay-rest está configurado"
      ]
    }
  },
  "documentationRequirements": {
    "description": "Requisitos de documentación Javadoc para todos los componentes",
    "mandatory": true,
    "reason": "Mejorar mantenibilidad y comprensión del código",
    "requiredForComponents": [
      "Tasks",
      "Interactions",
      "Questions",
      "Models",
      "Builders",
      "Endpoints",
      "StepDefinitions"
    ],
    "minimumRequirements": {
      "classLevel": [
        "Descripción de la responsabilidad de la clase",
        "Tag @author (opcional)",
        "Tag @version (opcional)"
      ],
      "methodLevel": [
        "Descripción de qué hace el método",
        "Tag @param para cada parámetro",
        "Tag @return si retorna valor"
      ]
    },
    "examples": {
      "Task": "/**\n * Task para crear un usuario en el sistema\n * Responsabilidad: Enviar request POST con datos de usuario\n * \n * @author Equipo QA\n */\npublic class CreateUser implements Task {\n    \n    private final CreateUserRequest request;\n    \n    /**\n     * Constructor privado\n     * @param request Datos del usuario a crear\n     */\n    private CreateUser(CreateUserRequest request) {\n        this.request = request;\n    }\n    \n    /**\n     * Factory method para crear instancia del Task\n     * @param request Datos del usuario\n     * @return Task instrumentado por Serenity\n     */\n    public static CreateUser with(CreateUserRequest request) {\n        return Tasks.instrumented(CreateUser.class, request);\n    }\n    \n    @Override\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n            PostRequest.to(UserEndpoints.CREATE_USER).with(req -> req.body(request))\n        );\n    }\n}",
      "Question": "/**\n * Question para obtener el código de estado de la respuesta HTTP\n * Responsabilidad: Extraer status code del último response\n * \n * @author Equipo QA\n */\npublic class ResponseStatusCode implements Question<Integer> {\n    \n    /**\n     * Factory method para crear instancia\n     * @return Question que retorna el status code\n     */\n    public static Question<Integer> value() {\n        return new ResponseStatusCode();\n    }\n    \n    /**\n     * Obtiene el status code del response\n     * @param actor Actor que ejecuta la consulta\n     * @return Código de estado HTTP\n     */\n    @Override\n    public Integer answeredBy(Actor actor) {\n        return SerenityRest.lastResponse().statusCode();\n    }\n}",
      "Model": "/**\n * Modelo de request para crear usuario\n * Responsabilidad: Estructura de datos para POST /users\n * \n * @author Equipo QA\n */\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class CreateUserRequest {\n    \n    private String name;\n    private String email;\n    private String password;\n    \n    /**\n     * Constructor completo\n     * @param name Nombre del usuario\n     * @param email Email del usuario\n     * @param password Contraseña del usuario\n     */\n    public CreateUserRequest(String name, String email, String password) {\n        this.name = name;\n        this.email = email;\n        this.password = password;\n    }\n    \n    // Getters y setters...\n}"
    }
  }
}