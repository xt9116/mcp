// Generator para código Java básico

export interface JavaClassConfig {
  className: string;
  packageName: string;
  type: 'class' | 'interface' | 'enum';
  fields?: JavaField[];
  methods?: JavaMethod[];
  implements?: string[];
  extends?: string;
  isAbstract?: boolean;
  isFinal?: boolean;
}

export interface JavaField {
  name: string;
  type: string;
  visibility: 'private' | 'public' | 'protected';
  isStatic?: boolean;
  isFinal?: boolean;
  defaultValue?: string;
}

export interface JavaMethod {
  name: string;
  returnType: string;
  visibility: 'private' | 'public' | 'protected';
  parameters?: JavaParameter[];
  body?: string;
  isStatic?: boolean;
  isFinal?: boolean;
  isAbstract?: boolean;
  annotations?: string[];
}

export interface JavaParameter {
  name: string;
  type: string;
}

export function generateJavaClass(config: JavaClassConfig): string {
  const lines: string[] = [];
  
  // Package declaration
  lines.push(`package ${config.packageName};`);
  lines.push('');
  
  // Imports (básicos)
  lines.push('import java.util.*;');
  lines.push('import java.util.stream.*;');
  lines.push('');
  
  // Javadoc
  lines.push('/**');
  lines.push(` * ${config.className}`);
  lines.push(' * @author Generated by Serenity Automation MCP');
  lines.push(' * @version 1.0');
  lines.push(' */');
  
  // Class declaration
  let classDeclaration = 'public ';
  if (config.isAbstract) classDeclaration += 'abstract ';
  if (config.isFinal) classDeclaration += 'final ';
  classDeclaration += `${config.type} ${config.className}`;
  
  if (config.extends) {
    classDeclaration += ` extends ${config.extends}`;
  }
  
  if (config.implements && config.implements.length > 0) {
    classDeclaration += ` implements ${config.implements.join(', ')}`;
  }
  
  lines.push(classDeclaration + ' {');
  lines.push('');
  
  // Fields
  if (config.fields && config.fields.length > 0) {
    lines.push('    // Fields');
    config.fields.forEach(field => {
      let fieldDeclaration = `    ${field.visibility} `;
      if (field.isStatic) fieldDeclaration += 'static ';
      if (field.isFinal) fieldDeclaration += 'final ';
      fieldDeclaration += `${field.type} ${field.name}`;
      if (field.defaultValue) {
        fieldDeclaration += ` = ${field.defaultValue}`;
      }
      fieldDeclaration += ';';
      lines.push(fieldDeclaration);
    });
    lines.push('');
  }
  
  // Constructor (if class has fields)
  if (config.fields && config.fields.length > 0 && config.type === 'class') {
    lines.push('    // Constructor');
    const constructorParams = config.fields
      .filter(f => !f.isStatic)
      .map(f => `${f.type} ${f.name}`)
      .join(', ');
    
    lines.push(`    public ${config.className}(${constructorParams}) {`);
    config.fields.filter(f => !f.isStatic).forEach(f => {
      lines.push(`        this.${f.name} = ${f.name};`);
    });
    lines.push('    }');
    lines.push('');
  }
  
  // Methods
  if (config.methods && config.methods.length > 0) {
    lines.push('    // Methods');
    config.methods.forEach(method => {
      // Method javadoc
      if (method.parameters && method.parameters.length > 0) {
        lines.push('    /**');
        lines.push(`     * ${method.name}`);
        method.parameters.forEach(p => {
          lines.push(`     * @param ${p.name} ${p.type}`);
        });
        if (method.returnType !== 'void') {
          lines.push(`     * @return ${method.returnType}`);
        }
        lines.push('     */');
      }
      
      // Annotations
      if (method.annotations) {
        method.annotations.forEach(annotation => {
          lines.push(`    ${annotation}`);
        });
      }
      
      // Method declaration
      let methodDeclaration = `    ${method.visibility} `;
      if (method.isStatic) methodDeclaration += 'static ';
      if (method.isFinal) methodDeclaration += 'final ';
      if (method.isAbstract) methodDeclaration += 'abstract ';
      methodDeclaration += `${method.returnType} ${method.name}(`;
      
      if (method.parameters) {
        const params = method.parameters.map(p => `${p.type} ${p.name}`).join(', ');
        methodDeclaration += params;
      }
      
      methodDeclaration += ')';
      
      if (method.isAbstract) {
        methodDeclaration += ';';
        lines.push(methodDeclaration);
      } else {
        methodDeclaration += ' {';
        lines.push(methodDeclaration);
        
        if (method.body) {
          const bodyLines = method.body.split('\n');
          bodyLines.forEach(line => {
            lines.push(`        ${line}`);
          });
        } else {
          if (method.returnType !== 'void') {
            lines.push(`        return null; // TODO: Implement`);
          }
        }
        
        lines.push('    }');
      }
      lines.push('');
    });
  }
  
  // Getters and Setters
  if (config.fields && config.fields.length > 0 && config.type === 'class') {
    lines.push('    // Getters and Setters');
    config.fields.filter(f => !f.isStatic).forEach(field => {
      // Getter
      const getterName = `get${capitalize(field.name)}`;
      lines.push(`    public ${field.type} ${getterName}() {`);
      lines.push(`        return this.${field.name};`);
      lines.push('    }');
      lines.push('');
      
      // Setter (if not final)
      if (!field.isFinal) {
        const setterName = `set${capitalize(field.name)}`;
        lines.push(`    public void ${setterName}(${field.type} ${field.name}) {`);
        lines.push(`        this.${field.name} = ${field.name};`);
        lines.push('    }');
        lines.push('');
      }
    });
  }
  
  // Close class
  lines.push('}');
  
  return lines.join('\n');
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

export function generateJavaInterface(config: JavaClassConfig): string {
  const lines: string[] = [];
  
  lines.push(`package ${config.packageName};`);
  lines.push('');
  lines.push('/**');
  lines.push(` * ${config.className} Interface`);
  lines.push(' */');
  lines.push(`public interface ${config.className} {`);
  lines.push('');
  
  if (config.methods) {
    config.methods.forEach(method => {
      let methodDeclaration = `    ${method.returnType} ${method.name}(`;
      if (method.parameters) {
        const params = method.parameters.map(p => `${p.type} ${p.name}`).join(', ');
        methodDeclaration += params;
      }
      methodDeclaration += ');';
      lines.push(methodDeclaration);
    });
  }
  
  lines.push('}');
  
  return lines.join('\n');
}

export function generateJavaEnum(config: JavaClassConfig): string {
  const lines: string[] = [];
  
  lines.push(`package ${config.packageName};`);
  lines.push('');
  lines.push('/**');
  lines.push(` * ${config.className} Enum`);
  lines.push(' */');
  lines.push(`public enum ${config.className} {`);
  lines.push('    // TODO: Add enum constants');
  lines.push('}');
  
  return lines.join('\n');
}

export function generatePOJO(className: string, packageName: string, fields: JavaField[]): string {
  return generateJavaClass({
    className,
    packageName,
    type: 'class',
    fields
  });
}

export function generateBuilder(className: string, packageName: string, fields: JavaField[]): string {
  const builderClassName = `${className}Builder`;
  const lines: string[] = [];
  
  lines.push(`package ${packageName};`);
  lines.push('');
  lines.push('/**');
  lines.push(` * Builder for ${className}`);
  lines.push(' */');
  lines.push(`public class ${builderClassName} {`);
  lines.push('');
  
  // Builder fields
  fields.forEach(field => {
    lines.push(`    private ${field.type} ${field.name};`);
  });
  lines.push('');
  
  // With methods
  fields.forEach(field => {
    const methodName = `with${capitalize(field.name)}`;
    lines.push(`    public ${builderClassName} ${methodName}(${field.type} ${field.name}) {`);
    lines.push(`        this.${field.name} = ${field.name};`);
    lines.push(`        return this;`);
    lines.push('    }');
    lines.push('');
  });
  
  // Build method
  lines.push(`    public ${className} build() {`);
  const constructorParams = fields.map(f => `this.${f.name}`).join(', ');
  lines.push(`        return new ${className}(${constructorParams});`);
  lines.push('    }');
  
  lines.push('}');
  
  return lines.join('\n');
}